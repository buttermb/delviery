# Supabase Integration Rules

Complete reference for BigMike Wholesale Platform Supabase integration.

## üö® Critical Auto-Generated Files

**NEVER EDIT THESE FILES - They are auto-generated by Supabase:**

```
src/integrations/supabase/client.ts
src/integrations/supabase/types.ts
supabase/config.toml (project_id, api keys)
.env (Supabase credentials)
```

Any edits will be overwritten when Supabase regenerates them.

## üîí SECURITY DEFINER Functions

**Rule:** ALL `SECURITY DEFINER` functions MUST include `SET search_path = public`

### ‚úÖ CORRECT Example:

```sql
CREATE OR REPLACE FUNCTION has_role(role_name text)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public  -- ‚ö†Ô∏è ALWAYS INCLUDE THIS
AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM user_roles
    WHERE user_id = auth.uid()
    AND role = role_name
    AND is_active = true
  );
END;
$$;
```

### ‚ùå WRONG Example:

```sql
CREATE OR REPLACE FUNCTION has_role(role_name text)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
-- Missing: SET search_path = public
AS $$
BEGIN
  -- Vulnerable to privilege escalation!
  RETURN EXISTS (SELECT 1 FROM user_roles WHERE user_id = auth.uid() AND role = role_name);
END;
$$;
```

**Why:** Without `SET search_path`, attackers can create malicious tables/functions in their schema and escalate privileges.

## üë§ User Roles Storage

**Rule:** Store roles in `user_roles` table, NEVER in `profiles` or `auth.users`

### ‚úÖ CORRECT Schema:

```sql
CREATE TABLE user_roles (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  tenant_id uuid NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
  role text NOT NULL CHECK (role IN ('super_admin', 'owner', 'manager', 'staff')),
  is_active boolean DEFAULT true,
  created_at timestamptz DEFAULT now(),
  UNIQUE(user_id, tenant_id)
);

-- RLS Policies
ALTER TABLE user_roles ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view their own roles"
  ON user_roles FOR SELECT
  USING (user_id = auth.uid());
```

### ‚ùå WRONG:

```sql
-- Don't add role column to profiles
ALTER TABLE profiles ADD COLUMN role text;
```

**Why:** Separation of concerns, proper RLS, multi-tenant support, audit trail.

## üîë Foreign Key References

**Rule:** Reference `public.profiles`, NEVER `auth.users`

### ‚úÖ CORRECT:

```sql
CREATE TABLE products (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  created_by uuid REFERENCES public.profiles(id) ON DELETE SET NULL,
  -- other columns
);
```

### ‚ùå WRONG:

```sql
CREATE TABLE products (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  created_by uuid REFERENCES auth.users(id),  -- ‚ùå Can't query auth.users from client
  -- other columns
);
```

**Why:** Client SDK cannot query `auth.users` table. Use `public.profiles` instead.

## üõ°Ô∏è Row Level Security (RLS)

**Rule:** Enable RLS on ALL tables (unless intentionally public)

### ‚úÖ CORRECT:

```sql
-- Enable RLS
ALTER TABLE products ENABLE ROW LEVEL SECURITY;

-- Create policies
CREATE POLICY "tenant_isolation" ON products
  FOR ALL
  USING (tenant_id = (auth.jwt() ->> 'tenant_id')::uuid);

CREATE POLICY "users_read_own" ON products
  FOR SELECT
  USING (created_by = auth.uid());

CREATE POLICY "admins_full_access" ON products
  FOR ALL
  USING (has_role('owner') OR has_role('manager'));
```

### ‚ùå WRONG:

```sql
-- Forgot to enable RLS - SECURITY VULNERABILITY!
CREATE TABLE products ( ... );
-- No ALTER TABLE ... ENABLE ROW LEVEL SECURITY
```

**Why:** Without RLS, any authenticated user can access ALL rows in the table.

## üè¢ Multi-Tenant Isolation

**Rule:** All tenant-specific tables MUST filter by `tenant_id` in RLS policies

### ‚úÖ CORRECT:

```sql
CREATE TABLE products (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id uuid NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
  -- other columns
);

ALTER TABLE products ENABLE ROW LEVEL SECURITY;

-- CRITICAL: Filter by tenant_id in RLS
CREATE POLICY "tenant_isolation" ON products
  FOR ALL
  USING (tenant_id = (auth.jwt() ->> 'tenant_id')::uuid);
```

### ‚ùå WRONG:

```sql
-- RLS policy missing tenant_id filter
CREATE POLICY "all_access" ON products
  FOR SELECT
  USING (true);  -- ‚ùå Exposes data across tenants!
```

**Why:** Without tenant isolation, users from different organizations can see each other's data.

## üìÖ Database Migrations

**Rule:** Use `YYYYMMDDHHMMSS_description.sql` format

### ‚úÖ CORRECT:

```
supabase/migrations/
  20241210120000_create_products_table.sql
  20241210123000_add_sku_validation.sql
  20241210125000_create_user_roles_table.sql
```

### ‚ùå WRONG:

```
supabase/migrations/
  migration_1.sql
  fix_products.sql
  update_2024.sql
```

**Why:** Timestamp prefix ensures migrations run in correct order across environments.

## ‚ö° Edge Functions

### 1. Shared Dependencies

**Rule:** Import from `_shared/deps.ts`

#### ‚úÖ CORRECT:

```typescript
// supabase/functions/_shared/deps.ts
export { serve } from 'https://deno.land/std@0.168.0/http/server.ts';
export { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
export { z } from 'https://deno.land/x/zod@v3.22.4/mod.ts';
export * as bcrypt from 'https://deno.land/x/bcrypt@v0.4.1/mod.ts';

// supabase/functions/my-function/index.ts
import { serve, z } from '../_shared/deps.ts';
```

#### ‚ùå WRONG:

```typescript
// Direct imports in each function
import { serve } from 'https://deno.land/std@0.168.0/http/server.ts';
```

**Why:** Centralized dependency management, consistent versions, easier updates.

### 2. Zod Validation (MANDATORY)

**Rule:** ALL `req.json()` calls MUST use Zod validation

#### ‚úÖ CORRECT:

```typescript
import { z } from '../_shared/deps.ts';

const createProductSchema = z.object({
  name: z.string().min(1).max(100),
  sku: z.string().min(1).max(50),
  price: z.number().positive(),
  category_id: z.string().uuid(),
});

serve(async (req) => {
  try {
    // Validate input
    const body = createProductSchema.parse(await req.json());
    
    // body is now type-safe and validated
    const { name, sku, price, category_id } = body;
    
    // ... rest of logic
  } catch (error) {
    if (error instanceof z.ZodError) {
      return new Response(
        JSON.stringify({ error: 'Invalid input', details: error.errors }),
        { status: 400, headers: corsHeaders }
      );
    }
    throw error;
  }
});
```

#### ‚ùå WRONG:

```typescript
serve(async (req) => {
  const body = await req.json();  // ‚ùå No validation!
  // body could be anything - security risk!
});
```

**Why:** Prevents injection attacks, ensures data integrity, provides type safety.

### 3. CORS Handling

**Rule:** Handle OPTIONS requests and include CORS headers in ALL responses

#### ‚úÖ CORRECT:

```typescript
const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

serve(async (req) => {
  // Handle preflight
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const data = { success: true };
    
    // Include CORS in response
    return new Response(
      JSON.stringify(data),
      { 
        headers: { 
          ...corsHeaders, 
          'Content-Type': 'application/json' 
        } 
      }
    );
  } catch (error) {
    // Include CORS in error response
    return new Response(
      JSON.stringify({ error: error.message }),
      { 
        status: 500, 
        headers: { 
          ...corsHeaders, 
          'Content-Type': 'application/json' 
        } 
      }
    );
  }
});
```

#### ‚ùå WRONG:

```typescript
serve(async (req) => {
  const data = { success: true };
  return new Response(JSON.stringify(data));  // ‚ùå No CORS headers!
});
```

**Why:** Enables cross-origin requests from frontend, handles preflight requests.

### 4. Password Hashing

**Rule:** Use bcrypt with 12 salt rounds, NEVER SHA-256

#### ‚úÖ CORRECT:

```typescript
import * as bcrypt from '../_shared/deps.ts';

const hashedPassword = await bcrypt.hash(password, 12);

// Verify
const isValid = await bcrypt.compare(inputPassword, hashedPassword);
```

#### ‚ùå WRONG:

```typescript
import { crypto } from 'https://deno.land/std/crypto/mod.ts';

// SHA-256 is NOT suitable for password hashing!
const hash = await crypto.subtle.digest(
  'SHA-256',
  new TextEncoder().encode(password)
);
```

**Why:** bcrypt is designed for passwords (slow, salted). SHA-256 is too fast (vulnerable to brute force).

### 5. JWT Verification

**Rule:** Set `verify_jwt` based on endpoint type in `supabase/config.toml`

#### ‚úÖ CORRECT:

```toml
# supabase/config.toml

# Public endpoints (no auth required)
[functions.public-menu-view]
verify_jwt = false

[functions.webhook-handler]
verify_jwt = false

# Protected endpoints (auth required)
[functions.create-product]
verify_jwt = true

[functions.get-analytics]
verify_jwt = true
```

**Why:** Public endpoints need `verify_jwt = false`, protected endpoints need `verify_jwt = true` for security.

## üö´ Forbidden Schema Modifications

**Rule:** NEVER modify these Supabase-managed schemas

```
‚ùå auth.*
‚ùå storage.*
‚ùå realtime.*
‚ùå vault.*
‚ùå supabase_functions.*
```

### ‚ùå WRONG:

```sql
-- Don't do this!
ALTER TABLE auth.users ADD COLUMN custom_field text;
CREATE TRIGGER my_trigger ON storage.objects ...;
```

**Why:** These schemas are managed by Supabase. Modifications can break functionality or be overwritten.

## ‚úÖ Pre-Push Checklist

Before pushing to GitHub:

- [ ] No edits to auto-generated files (client.ts, types.ts, config.toml, .env)
- [ ] All SECURITY DEFINER functions have `SET search_path = public`
- [ ] Roles stored in `user_roles` table
- [ ] Foreign keys reference `public.profiles`, not `auth.users`
- [ ] RLS enabled on all tables
- [ ] Multi-tenant tables filter by `tenant_id` in RLS
- [ ] No modifications to reserved schemas (auth, storage, etc.)
- [ ] Edge functions use Zod validation for `req.json()`
- [ ] Edge functions handle CORS properly
- [ ] Passwords hashed with bcrypt (12 rounds)
- [ ] JWT verification set correctly in config.toml
- [ ] Migration files use timestamp prefix

## üîß Validation

Install pre-push hook to validate automatically:

```bash
bash scripts/install-hooks.sh
```

The hook validates all these rules before allowing a push.

## üìö References

- [Supabase Security Best Practices](https://supabase.com/docs/guides/auth/row-level-security)
- [Edge Functions Guide](https://supabase.com/docs/guides/functions)
- [Database Migrations](https://supabase.com/docs/guides/cli/local-development)
