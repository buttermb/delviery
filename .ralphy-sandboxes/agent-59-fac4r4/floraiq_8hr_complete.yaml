name: FloraIQ Complete 8-Hour Overnight Development Sprint
description: >
  Comprehensive verification, security hardening, feature enhancement,
  performance optimization,

  and code quality improvements for FloraIQ cannabis wholesale SaaS platform.


  This sprint covers:

  - Critical bug fixes and build errors

  - Security hardening (RLS, auth, encryption)

  - All core feature verification and enhancement

  - UI/UX improvements and mobile optimization

  - Performance optimization and caching

  - Error handling and resilience

  - Code quality and TypeScript strictness

  - Documentation and testing

  - Edge function deployment and verification

  - Database optimization and indexing
version: 2.0.0
estimated_hours: 8
rules:
  - Use TypeScript strict mode with no any types unless absolutely necessary
  - Follow existing component patterns in src/components
  - Use Supabase client from @/integrations/supabase/client
  - ALWAYS include tenant_id isolation in ALL database queries - this is
    critical for multi-tenant security
  - Use TanStack Query patterns for all data fetching with proper cache
    invalidation
  - Follow shadcn/ui component conventions and use existing UI components
  - Never modify existing database migrations - always create new migration files
  - Add proper error handling with toast notifications for user feedback
  - Use the logger from @/lib/logger instead of console.log for production safety
  - Add loading states to all async operations
  - Add proper TypeScript types - no implicit any
  - Write self-documenting code with clear variable names
  - Add JSDoc comments for complex functions
  - Ensure all forms have proper validation with helpful error messages
  - Test edge cases like empty states, error states, and loading states
  - Ensure mobile responsiveness for all new UI changes
  - Follow accessibility best practices (proper labels, ARIA attributes,
    keyboard navigation)
  - Use optimistic updates where appropriate for better UX
  - Add proper error boundaries to prevent full page crashes
tasks:
  - id: fix-vendor-management-typescript-error
    title: Fix VendorManagement TypeScript Error TS2589 - Excessively Deep Type
      Instantiation
    priority: P0
    estimated_minutes: 20
    description: >
      ## Problem

      The VendorManagement.tsx file has a critical TypeScript error on line 81:

      "TS2589: Type instantiation is excessively deep and possibly infinite"


      This error blocks the entire build process and must be fixed first.


      ## Root Cause Analysis

      The Supabase client's .update(formData) and .insert() methods are causing
      TypeScript 

      to recursively infer types from the massive auto-generated types.ts file
      (15,743 lines).

      When TypeScript tries to infer the type of formData against all possible
      table schemas,

      it creates a recursive type instantiation that exceeds the compiler's
      depth limit.


      ## File to Modify

      src/pages/admin/VendorManagement.tsx


      ## Detailed Fix Instructions


      ### Step 1: Locate the update operation (around line 81-85)

      Find the code that looks like:

      ```typescript

      const { error } = await supabase
        .from('vendors')
        .update(formData)
        .eq('id', editingVendor.id)
        .eq('tenant_id', tenant.id);
      ```


      ### Step 2: Add explicit type cast to update operation

      Change it to:

      ```typescript

      const { error } = await supabase
        .from('vendors')
        .update(formData as Database['public']['Tables']['vendors']['Update'])
        .eq('id', editingVendor.id)
        .eq('tenant_id', tenant.id);
      ```


      If the Database type import is too complex, use a simpler cast:

      ```typescript

      const { error } = await supabase
        .from('vendors')
        .update(formData as Record<string, unknown>)
        .eq('id', editingVendor.id)
        .eq('tenant_id', tenant.id);
      ```


      ### Step 3: Locate the insert operation (around line 94-99)

      Find the code that looks like:

      ```typescript

      const { error } = await supabase
        .from('vendors')
        .insert({
          ...formData,
          tenant_id: tenant.id
        });
      ```


      ### Step 4: Add explicit type cast to insert operation

      Change it to:

      ```typescript

      const { error } = await supabase
        .from('vendors')
        .insert({
          ...formData,
          tenant_id: tenant.id
        } as Database['public']['Tables']['vendors']['Insert']);
      ```


      Or simpler:

      ```typescript

      const { error } = await supabase
        .from('vendors')
        .insert({
          ...formData,
          tenant_id: tenant.id
        } as Record<string, unknown>);
      ```


      ### Step 5: Check for similar issues in the file

      Search the entire file for other .update() and .insert() calls and apply
      the same fix.


      ### Step 6: Add proper type for formData

      At the top of the component or in a types file, define:

      ```typescript

      interface VendorFormData {
        name: string;
        contact_email?: string;
        contact_phone?: string;
        address?: string;
        city?: string;
        state?: string;
        zip_code?: string;
        license_number?: string;
        license_expiry?: string;
        payment_terms?: string;
        notes?: string;
        status: 'active' | 'inactive' | 'pending';
      }

      ```


      ### Step 7: Verify the fix

      Run `npm run build` or `npm run typecheck` to confirm the error is
      resolved.


      ## Additional Improvements While In This File


      1. Add loading state to the save button:

      ```typescript

      const [isSaving, setIsSaving] = useState(false);


      const handleSave = async () => {
        setIsSaving(true);
        try {
          // ... save logic
        } finally {
          setIsSaving(false);
        }
      };


      <Button disabled={isSaving}>
        {isSaving ? <Loader2 className="animate-spin" /> : 'Save'}
      </Button>

      ```


      2. Add form validation before submission

      3. Add confirmation dialog for delete operations

      4. Ensure proper error messages are shown to users
    acceptance_criteria:
      - npm run build completes without TS2589 error
      - npm run typecheck passes
      - Vendor create operation works correctly in the UI
      - Vendor update operation works correctly in the UI
      - No TypeScript errors in the file
      - Loading states shown during save operations
      - Error messages displayed on failure
    completed: true
  - id: fix-auth-token-refresh-401-error
    title: Fix Authentication Token Refresh 401 Error - Complete Auth Flow Overhaul
    priority: P0
    estimated_minutes: 45
    description: >
      ## Problem

      Users are experiencing 401 Unauthorized errors when their access token
      expires and

      the system attempts to refresh it. This causes users to be logged out
      unexpectedly

      or see blank screens, severely impacting user experience.


      ## Root Cause Analysis

      Multiple issues contribute to this problem:

      1. Stale tokens in localStorage not being cleared before new login

      2. Empty or invalid refresh tokens being sent to the refresh endpoint

      3. Race conditions when multiple requests try to refresh simultaneously

      4. Cookie/localStorage token mismatch after environment switches

      5. Missing error handling in the refresh flow


      ## Files to Modify


      ### File 1: src/pages/saas/LoginPage.tsx


      #### Problem

      When users log in, old stale tokens may still exist in localStorage and
      cookies,

      causing conflicts with the new session.


      #### Fix - Clear all auth state before login attempt


      Find the login function and add this BEFORE the signInWithPassword call:


      ```typescript

      const handleLogin = async (email: string, password: string) => {
        setIsLoading(true);
        setError(null);
        
        try {
          // STEP 1: Clear ALL stale authentication state
          // This prevents conflicts between old and new sessions
          
          // Clear localStorage tokens
          localStorage.removeItem('sb-access-token');
          localStorage.removeItem('sb-refresh-token');
          localStorage.removeItem('supabase.auth.token');
          
          // Clear any tenant-specific tokens
          const keys = Object.keys(localStorage);
          keys.forEach(key => {
            if (key.startsWith('sb-') || key.includes('supabase') || key.includes('auth')) {
              localStorage.removeItem(key);
            }
          });
          
          // Clear sessionStorage as well
          sessionStorage.clear();
          
          // Clear all cookies related to auth
          document.cookie.split(";").forEach(cookie => {
            const eqPos = cookie.indexOf("=");
            const name = eqPos > -1 ? cookie.substr(0, eqPos).trim() : cookie.trim();
            if (name.startsWith('sb-') || name.includes('access') || name.includes('refresh')) {
              document.cookie = name + "=;expires=Thu, 01 Jan 1970 00:00:00 GMT;path=/";
              document.cookie = name + "=;expires=Thu, 01 Jan 1970 00:00:00 GMT;path=/;domain=" + window.location.hostname;
            }
          });
          
          // Small delay to ensure cleanup is complete
          await new Promise(resolve => setTimeout(resolve, 100));
          
          // STEP 2: Now perform the actual login
          const { data, error } = await supabase.auth.signInWithPassword({
            email,
            password,
          });
          
          if (error) {
            // Handle specific error types
            if (error.message.includes('Invalid login credentials')) {
              setError('Invalid email or password. Please try again.');
            } else if (error.message.includes('Email not confirmed')) {
              setError('Please verify your email address before logging in.');
            } else {
              setError(error.message);
            }
            return;
          }
          
          // STEP 3: Store tokens properly after successful login
          if (data.session) {
            localStorage.setItem('sb-access-token', data.session.access_token);
            localStorage.setItem('sb-refresh-token', data.session.refresh_token);
          }
          
          // STEP 4: Redirect to dashboard
          navigate('/admin/dashboard');
          
        } catch (err) {
          console.error('Login error:', err);
          setError('An unexpected error occurred. Please try again.');
        } finally {
          setIsLoading(false);
        }
      };

      ```


      ### File 2: src/contexts/TenantAdminAuthContext.tsx


      #### Problem

      The token refresh function doesn't properly validate the refresh token
      before

      attempting to use it, and doesn't handle edge cases.


      #### Fix - Add comprehensive token refresh handling


      ```typescript

      const refreshToken = async (): Promise<boolean> => {
        // STEP 1: Get the current refresh token
        const currentRefreshToken = localStorage.getItem('sb-refresh-token');
        
        // STEP 2: Validate refresh token exists and is not empty
        if (!currentRefreshToken || currentRefreshToken === 'undefined' || currentRefreshToken === 'null') {
          console.warn('No valid refresh token available, logging out');
          await logout();
          return false;
        }
        
        // STEP 3: Check if refresh is already in progress (prevent race conditions)
        if (isRefreshing.current) {
          // Wait for the ongoing refresh to complete
          return new Promise((resolve) => {
            const checkRefresh = setInterval(() => {
              if (!isRefreshing.current) {
                clearInterval(checkRefresh);
                resolve(!!localStorage.getItem('sb-access-token'));
              }
            }, 100);
          });
        }
        
        isRefreshing.current = true;
        
        try {
          // STEP 4: Attempt to refresh the session
          const { data, error } = await supabase.auth.refreshSession({
            refresh_token: currentRefreshToken,
          });
          
          if (error) {
            console.error('Token refresh failed:', error.message);
            
            // If refresh fails, try the edge function as fallback
            try {
              const response = await fetch(
                `${import.meta.env.VITE_SUPABASE_URL}/functions/v1/tenant-admin-auth?action=refresh`,
                {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                  },
                  body: JSON.stringify({ refresh_token: currentRefreshToken }),
                  credentials: 'include',
                }
              );
              
              if (!response.ok) {
                throw new Error('Edge function refresh failed');
              }
              
              const refreshData = await response.json();
              
              if (refreshData.access_token) {
                localStorage.setItem('sb-access-token', refreshData.access_token);
                if (refreshData.refresh_token) {
                  localStorage.setItem('sb-refresh-token', refreshData.refresh_token);
                }
                return true;
              }
            } catch (fallbackError) {
              console.error('Fallback refresh also failed:', fallbackError);
            }
            
            // All refresh attempts failed, logout
            await logout();
            return false;
          }
          
          // STEP 5: Update tokens on successful refresh
          if (data.session) {
            localStorage.setItem('sb-access-token', data.session.access_token);
            localStorage.setItem('sb-refresh-token', data.session.refresh_token);
            
            // Update the Supabase client session
            await supabase.auth.setSession({
              access_token: data.session.access_token,
              refresh_token: data.session.refresh_token,
            });
            
            return true;
          }
          
          return false;
          
        } catch (err) {
          console.error('Unexpected error during token refresh:', err);
          await logout();
          return false;
        } finally {
          isRefreshing.current = false;
        }
      };


      // Add a ref to track refresh state

      const isRefreshing = useRef(false);

      ```


      #### Add automatic token refresh before expiry


      ```typescript

      useEffect(() => {
        // Set up automatic token refresh 5 minutes before expiry
        const setupAutoRefresh = () => {
          const accessToken = localStorage.getItem('sb-access-token');
          if (!accessToken) return;
          
          try {
            // Decode JWT to get expiry time
            const payload = JSON.parse(atob(accessToken.split('.')[1]));
            const expiryTime = payload.exp * 1000; // Convert to milliseconds
            const currentTime = Date.now();
            const timeUntilExpiry = expiryTime - currentTime;
            
            // Refresh 5 minutes before expiry
            const refreshTime = timeUntilExpiry - (5 * 60 * 1000);
            
            if (refreshTime > 0) {
              const timeoutId = setTimeout(() => {
                refreshToken();
              }, refreshTime);
              
              return () => clearTimeout(timeoutId);
            } else {
              // Token is about to expire or already expired, refresh now
              refreshToken();
            }
          } catch (e) {
            console.error('Error setting up auto refresh:', e);
          }
        };
        
        const cleanup = setupAutoRefresh();
        return cleanup;
      }, [user]);

      ```


      ### File 3: supabase/functions/tenant-admin-auth/index.ts


      #### Fix - Ensure cookies are set properly on refresh


      Find the refresh action handler and update it:


      ```typescript

      if (action === 'refresh') {
        const { refresh_token } = await req.json();
        
        if (!refresh_token) {
          return new Response(
            JSON.stringify({ error: 'Refresh token is required' }),
            { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
          );
        }
        
        const { data, error } = await supabaseAdmin.auth.refreshSession({
          refresh_token,
        });
        
        if (error || !data.session) {
          return new Response(
            JSON.stringify({ error: error?.message || 'Failed to refresh session' }),
            { status: 401, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
          );
        }
        
        // Set cookies for the new tokens
        const cookieOptions = [
          `sb-access-token=${data.session.access_token}`,
          'HttpOnly',
          'Secure',
          'SameSite=Lax',
          'Path=/',
          `Max-Age=${60 * 60 * 24 * 7}`, // 7 days
        ].join('; ');
        
        const refreshCookieOptions = [
          `sb-refresh-token=${data.session.refresh_token}`,
          'HttpOnly',
          'Secure',
          'SameSite=Lax',
          'Path=/',
          `Max-Age=${60 * 60 * 24 * 30}`, // 30 days
        ].join('; ');
        
        return new Response(
          JSON.stringify({
            access_token: data.session.access_token,
            refresh_token: data.session.refresh_token,
            expires_in: data.session.expires_in,
            user: data.user,
          }),
          {
            status: 200,
            headers: {
              ...corsHeaders,
              'Content-Type': 'application/json',
              'Set-Cookie': cookieOptions,
            },
          }
        );
      }

      ```
    acceptance_criteria:
      - Login works correctly after clearing browser storage
      - Token refresh succeeds automatically before expiry
      - 401 errors trigger proper logout instead of infinite retry loops
      - No blank screens on token expiration
      - Users stay logged in during normal usage
      - Multiple tabs don't cause refresh race conditions
      - Edge function refresh works as fallback
    completed: true
  - id: create-atomic-pos-transaction-rpc
    title: Create Atomic POS Transaction Database Function for Data Integrity
    priority: P0
    estimated_minutes: 30
    description: >
      ## Problem

      The current POS transaction system updates the transaction record and
      inventory

      in separate database calls. This creates a race condition where:

      1. Transaction could be created but inventory not decremented

      2. Inventory could be decremented but transaction fails

      3. Concurrent transactions could oversell products


      ## Solution

      Create a PostgreSQL function that handles the entire POS transaction
      atomically

      within a single database transaction. This ensures all-or-nothing
      behavior.


      ## File to Create

      supabase/migrations/[timestamp]_create_pos_transaction_atomic.sql


      Use the current timestamp for the migration file name, e.g.:

      20250121000001_create_pos_transaction_atomic.sql


      ## Complete Migration SQL


      ```sql

      -- Migration: Create atomic POS transaction function

      -- This function handles POS transactions atomically to ensure data
      integrity

      -- It creates the transaction, updates inventory, and handles edge cases


      -- First, drop the function if it exists (for idempotency)

      DROP FUNCTION IF EXISTS public.create_pos_transaction_atomic(UUID, JSONB,
      TEXT, NUMERIC, NUMERIC, NUMERIC, UUID, UUID);


      -- Create the atomic transaction function

      CREATE OR REPLACE FUNCTION public.create_pos_transaction_atomic(
        p_tenant_id UUID,
        p_items JSONB,
        p_payment_method TEXT,
        p_subtotal NUMERIC,
        p_tax_amount NUMERIC DEFAULT 0,
        p_discount_amount NUMERIC DEFAULT 0,
        p_customer_id UUID DEFAULT NULL,
        p_shift_id UUID DEFAULT NULL
      ) RETURNS JSONB

      LANGUAGE plpgsql

      SECURITY DEFINER

      SET search_path = public

      AS $$

      DECLARE
        v_transaction_id UUID;
        v_transaction_number TEXT;
        v_item JSONB;
        v_total NUMERIC;
        v_product_id UUID;
        v_quantity INTEGER;
        v_current_stock INTEGER;
        v_product_name TEXT;
        v_insufficient_items JSONB := '[]'::JSONB;
      BEGIN
        -- Calculate total amount
        v_total := COALESCE(p_subtotal, 0) + COALESCE(p_tax_amount, 0) - COALESCE(p_discount_amount, 0);
        
        -- Validate total is positive
        IF v_total < 0 THEN
          RETURN jsonb_build_object(
            'success', false,
            'error', 'Transaction total cannot be negative',
            'error_code', 'NEGATIVE_TOTAL'
          );
        END IF;
        
        -- Validate items array is not empty
        IF p_items IS NULL OR jsonb_array_length(p_items) = 0 THEN
          RETURN jsonb_build_object(
            'success', false,
            'error', 'Transaction must have at least one item',
            'error_code', 'EMPTY_CART'
          );
        END IF;
        
        -- STEP 1: Validate all items have sufficient stock BEFORE making any changes
        -- This prevents partial updates
        FOR v_item IN SELECT * FROM jsonb_array_elements(p_items)
        LOOP
          v_product_id := (v_item->>'id')::UUID;
          v_quantity := COALESCE((v_item->>'quantity')::INTEGER, 0);
          
          -- Validate quantity is positive
          IF v_quantity <= 0 THEN
            RETURN jsonb_build_object(
              'success', false,
              'error', format('Invalid quantity for product %s', v_product_id),
              'error_code', 'INVALID_QUANTITY'
            );
          END IF;
          
          -- Get current stock and product name
          SELECT stock_quantity, name INTO v_current_stock, v_product_name
          FROM products
          WHERE id = v_product_id
            AND tenant_id = p_tenant_id
          FOR UPDATE; -- Lock the row to prevent concurrent modifications
          
          -- Check if product exists
          IF NOT FOUND THEN
            RETURN jsonb_build_object(
              'success', false,
              'error', format('Product %s not found', v_product_id),
              'error_code', 'PRODUCT_NOT_FOUND'
            );
          END IF;
          
          -- Check if sufficient stock
          IF v_current_stock < v_quantity THEN
            v_insufficient_items := v_insufficient_items || jsonb_build_object(
              'product_id', v_product_id,
              'product_name', v_product_name,
              'requested', v_quantity,
              'available', v_current_stock
            );
          END IF;
        END LOOP;
        
        -- If any items have insufficient stock, return error with details
        IF jsonb_array_length(v_insufficient_items) > 0 THEN
          RETURN jsonb_build_object(
            'success', false,
            'error', 'Insufficient stock for one or more items',
            'error_code', 'INSUFFICIENT_STOCK',
            'insufficient_items', v_insufficient_items
          );
        END IF;
        
        -- STEP 2: Generate unique transaction number
        -- Format: POS-YYYYMMDD-XXXX where XXXX is a random 4-digit number
        -- We use a loop to handle the rare case of collision
        LOOP
          v_transaction_number := 'POS-' || to_char(now(), 'YYYYMMDD') || '-' || 
            lpad(floor(random() * 10000)::TEXT, 4, '0');
          
          -- Check if this transaction number already exists
          IF NOT EXISTS (
            SELECT 1 FROM pos_transactions 
            WHERE transaction_number = v_transaction_number 
            AND tenant_id = p_tenant_id
          ) THEN
            EXIT; -- Unique number found, exit loop
          END IF;
        END LOOP;
        
        -- STEP 3: Create the transaction record
        INSERT INTO pos_transactions (
          id,
          tenant_id, 
          transaction_number, 
          subtotal, 
          tax_amount, 
          discount_amount,
          total_amount, 
          payment_method, 
          payment_status, 
          items, 
          customer_id, 
          shift_id,
          created_at,
          updated_at
        )
        VALUES (
          gen_random_uuid(),
          p_tenant_id, 
          v_transaction_number, 
          COALESCE(p_subtotal, 0), 
          COALESCE(p_tax_amount, 0), 
          COALESCE(p_discount_amount, 0),
          v_total, 
          p_payment_method, 
          'completed', 
          p_items, 
          p_customer_id, 
          p_shift_id,
          now(),
          now()
        )
        RETURNING id INTO v_transaction_id;
        
        -- STEP 4: Update inventory for each item
        FOR v_item IN SELECT * FROM jsonb_array_elements(p_items)
        LOOP
          v_product_id := (v_item->>'id')::UUID;
          v_quantity := (v_item->>'quantity')::INTEGER;
          
          UPDATE products
          SET 
            stock_quantity = stock_quantity - v_quantity,
            updated_at = now()
          WHERE id = v_product_id
            AND tenant_id = p_tenant_id;
          
          -- Log the inventory movement for audit trail
          INSERT INTO inventory_movements (
            id,
            tenant_id,
            product_id,
            movement_type,
            quantity,
            reference_type,
            reference_id,
            notes,
            created_at
          )
          VALUES (
            gen_random_uuid(),
            p_tenant_id,
            v_product_id,
            'sale',
            -v_quantity,
            'pos_transaction',
            v_transaction_id,
            'POS Sale: ' || v_transaction_number,
            now()
          );
        END LOOP;
        
        -- STEP 5: Update shift totals if shift is provided
        IF p_shift_id IS NOT NULL THEN
          UPDATE pos_shifts
          SET 
            total_sales = COALESCE(total_sales, 0) + v_total,
            transaction_count = COALESCE(transaction_count, 0) + 1,
            updated_at = now()
          WHERE id = p_shift_id
            AND tenant_id = p_tenant_id;
        END IF;
        
        -- STEP 6: Return success response with transaction details
        RETURN jsonb_build_object(
          'success', true, 
          'transaction_id', v_transaction_id,
          'transaction_number', v_transaction_number,
          'total', v_total,
          'items_count', jsonb_array_length(p_items),
          'payment_method', p_payment_method,
          'created_at', now()
        );







        
      EXCEPTION
        WHEN OTHERS THEN
          -- Log the error and return failure response
          RAISE WARNING 'POS Transaction Error: %', SQLERRM;
          RETURN jsonb_build_object(
            'success', false, 
            'error', SQLERRM,
            'error_code', 'TRANSACTION_FAILED'
          );
      END;

      $$;


      -- Grant execute permission to authenticated users

      GRANT EXECUTE ON FUNCTION public.create_pos_transaction_atomic TO
      authenticated;


      -- Add comment for documentation

      COMMENT ON FUNCTION public.create_pos_transaction_atomic IS 
        'Atomically creates a POS transaction, updates inventory, and logs movements. 
         Returns JSON with success status and transaction details or error information.';

      -- Create the inventory_movements table if it doesn't exist

      CREATE TABLE IF NOT EXISTS public.inventory_movements (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        tenant_id UUID NOT NULL REFERENCES tenants(id),
        product_id UUID NOT NULL REFERENCES products(id),
        movement_type TEXT NOT NULL CHECK (movement_type IN ('sale', 'purchase', 'adjustment', 'transfer', 'return', 'damage', 'expired')),
        quantity INTEGER NOT NULL,
        reference_type TEXT,
        reference_id UUID,
        notes TEXT,
        created_by UUID REFERENCES auth.users(id),
        created_at TIMESTAMPTZ DEFAULT now()
      );


      -- Add index for faster queries

      CREATE INDEX IF NOT EXISTS idx_inventory_movements_tenant_product 
        ON inventory_movements(tenant_id, product_id);
      CREATE INDEX IF NOT EXISTS idx_inventory_movements_created_at 
        ON inventory_movements(created_at DESC);

      -- Add RLS policies for inventory_movements

      ALTER TABLE inventory_movements ENABLE ROW LEVEL SECURITY;


      DROP POLICY IF EXISTS "inventory_movements_tenant_select" ON
      inventory_movements;

      CREATE POLICY "inventory_movements_tenant_select" ON inventory_movements
        FOR SELECT USING (
          tenant_id IN (SELECT tu.tenant_id FROM tenant_users tu WHERE tu.user_id = auth.uid())
        );

      DROP POLICY IF EXISTS "inventory_movements_tenant_insert" ON
      inventory_movements;

      CREATE POLICY "inventory_movements_tenant_insert" ON inventory_movements
        FOR INSERT WITH CHECK (
          tenant_id IN (SELECT tu.tenant_id FROM tenant_users tu WHERE tu.user_id = auth.uid())
        );
      ```


      ## Frontend Integration


      After creating the migration, update the CashRegister.tsx to use this
      function:


      ```typescript

      const completeTransaction = async () => {
        if (cart.length === 0) {
          toast.error('Cart is empty');
          return;
        }
        
        setIsProcessing(true);
        
        try {
          const { data, error } = await supabase.rpc('create_pos_transaction_atomic', {
            p_tenant_id: tenant.id,
            p_items: cart.map(item => ({
              id: item.id,
              name: item.name,
              quantity: item.quantity,
              price: item.price,
              sku: item.sku
            })),
            p_payment_method: paymentMethod,
            p_subtotal: subtotal,
            p_tax_amount: taxAmount,
            p_discount_amount: discountAmount,
            p_customer_id: selectedCustomer?.id || null,
            p_shift_id: currentShift?.id || null
          });
          
          if (error) {
            throw error;
          }
          
          if (!data.success) {
            // Handle specific error codes
            if (data.error_code === 'INSUFFICIENT_STOCK') {
              const items = data.insufficient_items.map((item: any) => 
                `${item.product_name}: need ${item.requested}, have ${item.available}`
              ).join('\n');
              toast.error(`Insufficient stock:\n${items}`);
            } else {
              toast.error(data.error || 'Transaction failed');
            }
            return;
          }
          
          // Success!
          toast.success(`Transaction ${data.transaction_number} completed!`);
          
          // Print receipt
          await printReceipt({
            transactionNumber: data.transaction_number,
            items: cart,
            subtotal,
            tax: taxAmount,
            discount: discountAmount,
            total: data.total,
            paymentMethod,
            date: new Date()
          });
          
          // Clear cart
          setCart([]);
          setSelectedCustomer(null);
          setPaymentMethod('cash');
          setDiscountAmount(0);
          
          // Invalidate queries to refresh data
          queryClient.invalidateQueries(['products']);
          queryClient.invalidateQueries(['pos-transactions']);
          
        } catch (err) {
          console.error('Transaction error:', err);
          toast.error('Failed to complete transaction. Please try again.');
        } finally {
          setIsProcessing(false);
        }
      };

      ```
    acceptance_criteria:
      - Migration file created and runs successfully
      - RPC function can be called from frontend
      - Transaction and inventory update happen atomically (all or nothing)
      - Insufficient stock returns detailed error with affected items
      - Transaction numbers are unique
      - Inventory movements are logged for audit trail
      - Shift totals are updated
      - Concurrent transactions are handled correctly (row locking)
      - Frontend CashRegister uses the new RPC function
    completed: true
  - id: fix-all-rls-policies-comprehensive
    title: Fix All Overly Permissive RLS Policies - Complete Security Overhaul
    priority: P0
    estimated_minutes: 60
    description: |
      ## Critical Security Issue
      The database currently has 81+ overly permissive RLS policies using `USING (true)` 
      which allows any authenticated user to access any tenant's data. This is a severe 
      security vulnerability in a multi-tenant application.

      ## File to Create
      supabase/migrations/[timestamp]_fix_all_rls_policies.sql

      ## Complete Migration SQL

      ```sql
      -- Migration: Fix all overly permissive RLS policies
      -- This migration implements proper tenant isolation across all tables
      -- CRITICAL: This must be run to secure the multi-tenant system

      -- ============================================================================
      -- HELPER FUNCTION: Get user's tenant IDs
      -- ============================================================================

      CREATE OR REPLACE FUNCTION auth.user_tenant_ids()
      RETURNS SETOF UUID
      LANGUAGE sql
      SECURITY DEFINER
      STABLE
      SET search_path = public
      AS $$
        SELECT tenant_id FROM tenant_users WHERE user_id = auth.uid()
      $$;

      -- ============================================================================
      -- VENDORS TABLE
      -- ============================================================================

      -- Drop all existing policies
      DROP POLICY IF EXISTS "Allow all for authenticated" ON vendors;
      DROP POLICY IF EXISTS "vendors_select" ON vendors;
      DROP POLICY IF EXISTS "vendors_insert" ON vendors;
      DROP POLICY IF EXISTS "vendors_update" ON vendors;
      DROP POLICY IF EXISTS "vendors_delete" ON vendors;
      DROP POLICY IF EXISTS "Enable read access for authenticated users" ON vendors;
      DROP POLICY IF EXISTS "Enable insert for authenticated users" ON vendors;
      DROP POLICY IF EXISTS "Enable update for authenticated users" ON vendors;
      DROP POLICY IF EXISTS "Enable delete for authenticated users" ON vendors;

      -- Create tenant-isolated policies
      CREATE POLICY "vendors_tenant_select" ON vendors FOR SELECT
        USING (tenant_id IN (SELECT auth.user_tenant_ids()));

      CREATE POLICY "vendors_tenant_insert" ON vendors FOR INSERT
        WITH CHECK (tenant_id IN (SELECT auth.user_tenant_ids()));

      CREATE POLICY "vendors_tenant_update" ON vendors FOR UPDATE
        USING (tenant_id IN (SELECT auth.user_tenant_ids()))
        WITH CHECK (tenant_id IN (SELECT auth.user_tenant_ids()));

      CREATE POLICY "vendors_tenant_delete" ON vendors FOR DELETE
        USING (tenant_id IN (SELECT auth.user_tenant_ids()));

      -- ============================================================================
      -- PRODUCTS TABLE
      -- ============================================================================

      DROP POLICY IF EXISTS "Allow all for authenticated" ON products;
      DROP POLICY IF EXISTS "products_select" ON products;
      DROP POLICY IF EXISTS "products_insert" ON products;
      DROP POLICY IF EXISTS "products_update" ON products;
      DROP POLICY IF EXISTS "products_delete" ON products;
      DROP POLICY IF EXISTS "Enable read access for authenticated users" ON products;
      DROP POLICY IF EXISTS "Enable insert for authenticated users" ON products;
      DROP POLICY IF EXISTS "Enable update for authenticated users" ON products;
      DROP POLICY IF EXISTS "Enable delete for authenticated users" ON products;

      CREATE POLICY "products_tenant_select" ON products FOR SELECT
        USING (tenant_id IN (SELECT auth.user_tenant_ids()));

      CREATE POLICY "products_tenant_insert" ON products FOR INSERT
        WITH CHECK (tenant_id IN (SELECT auth.user_tenant_ids()));

      CREATE POLICY "products_tenant_update" ON products FOR UPDATE
        USING (tenant_id IN (SELECT auth.user_tenant_ids()))
        WITH CHECK (tenant_id IN (SELECT auth.user_tenant_ids()));

      CREATE POLICY "products_tenant_delete" ON products FOR DELETE
        USING (tenant_id IN (SELECT auth.user_tenant_ids()));

      -- ============================================================================
      -- ORDERS TABLE
      -- ============================================================================

      DROP POLICY IF EXISTS "Allow all for authenticated" ON orders;
      DROP POLICY IF EXISTS "orders_select" ON orders;
      DROP POLICY IF EXISTS "orders_insert" ON orders;
      DROP POLICY IF EXISTS "orders_update" ON orders;
      DROP POLICY IF EXISTS "orders_delete" ON orders;
      DROP POLICY IF EXISTS "Enable read access for authenticated users" ON orders;
      DROP POLICY IF EXISTS "Enable insert for authenticated users" ON orders;
      DROP POLICY IF EXISTS "Enable update for authenticated users" ON orders;
      DROP POLICY IF EXISTS "Enable delete for authenticated users" ON orders;

      -- Staff can manage all tenant orders
      CREATE POLICY "orders_staff_select" ON orders FOR SELECT
        USING (tenant_id IN (SELECT auth.user_tenant_ids()));

      -- Customers can see their own orders (for customer portal)
      CREATE POLICY "orders_customer_select" ON orders FOR SELECT
        USING (customer_id = auth.uid());

      CREATE POLICY "orders_tenant_insert" ON orders FOR INSERT
        WITH CHECK (tenant_id IN (SELECT auth.user_tenant_ids()));

      CREATE POLICY "orders_tenant_update" ON orders FOR UPDATE
        USING (tenant_id IN (SELECT auth.user_tenant_ids()))
        WITH CHECK (tenant_id IN (SELECT auth.user_tenant_ids()));

      CREATE POLICY "orders_tenant_delete" ON orders FOR DELETE
        USING (tenant_id IN (SELECT auth.user_tenant_ids()));

      -- ============================================================================
      -- CUSTOMERS TABLE
      -- ============================================================================

      DROP POLICY IF EXISTS "Allow all for authenticated" ON customers;
      DROP POLICY IF EXISTS "customers_select" ON customers;
      DROP POLICY IF EXISTS "customers_insert" ON customers;
      DROP POLICY IF EXISTS "customers_update" ON customers;
      DROP POLICY IF EXISTS "customers_delete" ON customers;
      DROP POLICY IF EXISTS "Enable read access for authenticated users" ON customers;
      DROP POLICY IF EXISTS "Enable insert for authenticated users" ON customers;
      DROP POLICY IF EXISTS "Enable update for authenticated users" ON customers;
      DROP POLICY IF EXISTS "Enable delete for authenticated users" ON customers;

      CREATE POLICY "customers_tenant_select" ON customers FOR SELECT
        USING (tenant_id IN (SELECT auth.user_tenant_ids()));

      CREATE POLICY "customers_tenant_insert" ON customers FOR INSERT
        WITH CHECK (tenant_id IN (SELECT auth.user_tenant_ids()));

      CREATE POLICY "customers_tenant_update" ON customers FOR UPDATE
        USING (tenant_id IN (SELECT auth.user_tenant_ids()))
        WITH CHECK (tenant_id IN (SELECT auth.user_tenant_ids()));

      CREATE POLICY "customers_tenant_delete" ON customers FOR DELETE
        USING (tenant_id IN (SELECT auth.user_tenant_ids()));

      -- ============================================================================
      -- INVOICES TABLE
      -- ============================================================================

      DROP POLICY IF EXISTS "Allow all for authenticated" ON invoices;
      DROP POLICY IF EXISTS "invoices_select" ON invoices;
      DROP POLICY IF EXISTS "invoices_insert" ON invoices;
      DROP POLICY IF EXISTS "invoices_update" ON invoices;
      DROP POLICY IF EXISTS "invoices_delete" ON invoices;
      DROP POLICY IF EXISTS "Enable read access for authenticated users" ON invoices;
      DROP POLICY IF EXISTS "Enable insert for authenticated users" ON invoices;
      DROP POLICY IF EXISTS "Enable update for authenticated users" ON invoices;
      DROP POLICY IF EXISTS "Enable delete for authenticated users" ON invoices;

      CREATE POLICY "invoices_tenant_select" ON invoices FOR SELECT
        USING (tenant_id IN (SELECT auth.user_tenant_ids()));

      CREATE POLICY "invoices_tenant_insert" ON invoices FOR INSERT
        WITH CHECK (tenant_id IN (SELECT auth.user_tenant_ids()));

      CREATE POLICY "invoices_tenant_update" ON invoices FOR UPDATE
        USING (tenant_id IN (SELECT auth.user_tenant_ids()))
        WITH CHECK (tenant_id IN (SELECT auth.user_tenant_ids()));

      CREATE POLICY "invoices_tenant_delete" ON invoices FOR DELETE
        USING (tenant_id IN (SELECT auth.user_tenant_ids()));

      -- ============================================================================
      -- POS_TRANSACTIONS TABLE
      -- ============================================================================

      DROP POLICY IF EXISTS "Allow all for authenticated" ON pos_transactions;
      DROP POLICY IF EXISTS "pos_transactions_select" ON pos_transactions;
      DROP POLICY IF EXISTS "pos_transactions_insert" ON pos_transactions;
      DROP POLICY IF EXISTS "pos_transactions_update" ON pos_transactions;
      DROP POLICY IF EXISTS "pos_transactions_delete" ON pos_transactions;
      DROP POLICY IF EXISTS "Enable read access for authenticated users" ON pos_transactions;
      DROP POLICY IF EXISTS "Enable insert for authenticated users" ON pos_transactions;
      DROP POLICY IF EXISTS "Enable update for authenticated users" ON pos_transactions;
      DROP POLICY IF EXISTS "Enable delete for authenticated users" ON pos_transactions;

      CREATE POLICY "pos_transactions_tenant_select" ON pos_transactions FOR SELECT
        USING (tenant_id IN (SELECT auth.user_tenant_ids()));

      CREATE POLICY "pos_transactions_tenant_insert" ON pos_transactions FOR INSERT
        WITH CHECK (tenant_id IN (SELECT auth.user_tenant_ids()));

      CREATE POLICY "pos_transactions_tenant_update" ON pos_transactions FOR UPDATE
        USING (tenant_id IN (SELECT auth.user_tenant_ids()))
        WITH CHECK (tenant_id IN (SELECT auth.user_tenant_ids()));

      -- No delete policy - POS transactions should never be deleted, only voided

      -- ============================================================================
      -- POS_SHIFTS TABLE
      -- ============================================================================

      DROP POLICY IF EXISTS "Allow all for authenticated" ON pos_shifts;
      DROP POLICY IF EXISTS "pos_shifts_select" ON pos_shifts;
      DROP POLICY IF EXISTS "pos_shifts_insert" ON pos_shifts;
      DROP POLICY IF EXISTS "pos_shifts_update" ON pos_shifts;
      DROP POLICY IF EXISTS "pos_shifts_delete" ON pos_shifts;

      CREATE POLICY "pos_shifts_tenant_select" ON pos_shifts FOR SELECT
        USING (tenant_id IN (SELECT auth.user_tenant_ids()));

      CREATE POLICY "pos_shifts_tenant_insert" ON pos_shifts FOR INSERT
        WITH CHECK (tenant_id IN (SELECT auth.user_tenant_ids()));

      CREATE POLICY "pos_shifts_tenant_update" ON pos_shifts FOR UPDATE
        USING (tenant_id IN (SELECT auth.user_tenant_ids()))
        WITH CHECK (tenant_id IN (SELECT auth.user_tenant_ids()));

      -- ============================================================================
      -- INVENTORY / STOCK TABLES
      -- ============================================================================

      -- Apply same pattern to: inventory, stock_adjustments, inventory_locations
      -- For each table that exists, drop old policies and create tenant-isolated ones

      DO $$
      DECLARE
        tables_to_fix TEXT[] := ARRAY[
          'inventory',
          'stock_adjustments', 
          'inventory_locations',
          'wholesale_clients',
          'wholesale_orders',
          'categories',
          'discounts',
          'promotions',
          'loyalty_programs',
          'loyalty_points',
          'delivery_zones',
          'delivery_drivers',
          'notifications',
          'audit_logs',
          'tenant_settings',
          'payment_methods',
          'tax_rates'
        ];
        tbl TEXT;
      BEGIN
        FOREACH tbl IN ARRAY tables_to_fix
        LOOP
          -- Check if table exists
          IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = tbl AND table_schema = 'public') THEN
            -- Drop old policies
            EXECUTE format('DROP POLICY IF EXISTS "Allow all for authenticated" ON %I', tbl);
            EXECUTE format('DROP POLICY IF EXISTS "%s_select" ON %I', tbl, tbl);
            EXECUTE format('DROP POLICY IF EXISTS "%s_insert" ON %I', tbl, tbl);
            EXECUTE format('DROP POLICY IF EXISTS "%s_update" ON %I', tbl, tbl);
            EXECUTE format('DROP POLICY IF EXISTS "%s_delete" ON %I', tbl, tbl);
            EXECUTE format('DROP POLICY IF EXISTS "Enable read access for authenticated users" ON %I', tbl);
            EXECUTE format('DROP POLICY IF EXISTS "Enable insert for authenticated users" ON %I', tbl);
            EXECUTE format('DROP POLICY IF EXISTS "Enable update for authenticated users" ON %I', tbl);
            EXECUTE format('DROP POLICY IF EXISTS "Enable delete for authenticated users" ON %I', tbl);
            
            -- Create new tenant-isolated policies
            EXECUTE format('
              CREATE POLICY "%s_tenant_select" ON %I FOR SELECT
                USING (tenant_id IN (SELECT auth.user_tenant_ids()))
            ', tbl, tbl);
            
            EXECUTE format('
              CREATE POLICY "%s_tenant_insert" ON %I FOR INSERT
                WITH CHECK (tenant_id IN (SELECT auth.user_tenant_ids()))
            ', tbl, tbl);
            
            EXECUTE format('
              CREATE POLICY "%s_tenant_update" ON %I FOR UPDATE
                USING (tenant_id IN (SELECT auth.user_tenant_ids()))
                WITH CHECK (tenant_id IN (SELECT auth.user_tenant_ids()))
            ', tbl, tbl);
            
            EXECUTE format('
              CREATE POLICY "%s_tenant_delete" ON %I FOR DELETE
                USING (tenant_id IN (SELECT auth.user_tenant_ids()))
            ', tbl, tbl);
            
            RAISE NOTICE 'Fixed RLS policies for table: %', tbl;
          END IF;
        END LOOP;
      END $$;

      -- ============================================================================
      -- FIX SECURITY DEFINER FUNCTIONS
      -- ============================================================================

      -- Find and fix all SECURITY DEFINER functions without search_path set
      DO $$
      DECLARE
        func_record RECORD;
      BEGIN
        FOR func_record IN 
          SELECT 
            n.nspname as schema_name,
            p.proname as function_name,
            pg_get_function_identity_arguments(p.oid) as args
          FROM pg_proc p
          JOIN pg_namespace n ON p.pronamespace = n.oid
          WHERE p.prosecdef = true
            AND n.nspname = 'public'
            AND NOT EXISTS (
              SELECT 1 FROM pg_proc_info 
              WHERE oid = p.oid 
              AND proconfig @> ARRAY['search_path=public']
            )
        LOOP
          BEGIN
            EXECUTE format(
              'ALTER FUNCTION %I.%I(%s) SET search_path = public',
              func_record.schema_name,
              func_record.function_name,
              func_record.args
            );
            RAISE NOTICE 'Fixed search_path for function: %.%', 
              func_record.schema_name, func_record.function_name;
          EXCEPTION WHEN OTHERS THEN
            RAISE NOTICE 'Could not fix function %.%: %', 
              func_record.schema_name, func_record.function_name, SQLERRM;
          END;
        END LOOP;
      END $$;

      -- ============================================================================
      -- VERIFY CHANGES
      -- ============================================================================

      -- Create a verification function
      CREATE OR REPLACE FUNCTION public.verify_rls_policies()
      RETURNS TABLE (
        table_name TEXT,
        policy_name TEXT,
        policy_type TEXT,
        is_permissive BOOLEAN
      )
      LANGUAGE sql
      SECURITY DEFINER
      SET search_path = public
      AS $$
        SELECT 
          schemaname || '.' || tablename as table_name,
          policyname as policy_name,
          cmd as policy_type,
          permissive = 'PERMISSIVE' as is_permissive
        FROM pg_policies
        WHERE schemaname = 'public'
        ORDER BY tablename, policyname;
      $$;
      ```
    acceptance_criteria:
      - All tables have tenant-isolated RLS policies
      - No policies use USING (true) for write operations
      - Cross-tenant data access is blocked
      - Users can only see/modify their own tenant's data
      - All SECURITY DEFINER functions have search_path set
      - verify_rls_policies() function works to audit policies
    completed: true
  - id: verify-enhance-cash-register
    title: Verify and Enhance Cash Register - Complete POS Overhaul
    priority: P1
    estimated_minutes: 45
    description: >
      ## Overview

      The Cash Register (POS) is a critical revenue-generating feature. This
      task

      involves thorough verification and enhancement of all POS functionality.


      ## File

      src/pages/admin/CashRegister.tsx


      ## Verification Checklist

      Go through each feature and ensure it works correctly:


      ### 1. Product Search

      - Search by product name works

      - Search by SKU works

      - Search by barcode works

      - Results filter in real-time

      - Empty search shows all products (or recent)

      - Category filter works alongside search


      ### 2. Add to Cart

      - Click product adds to cart

      - Quantity defaults to 1

      - Price shows correctly

      - Out of stock products show warning

      - Duplicate add increases quantity


      ### 3. Cart Operations

      - Quantity +/- buttons work

      - Quantity can't go below 1

      - Quantity can't exceed available stock

      - Remove item button works

      - Clear cart button works (with confirmation)

      - Subtotal calculates correctly


      ### 4. Discounts

      - Percentage discount works

      - Fixed amount discount works

      - Discount can't exceed subtotal

      - Discount shows in totals


      ### 5. Tax Calculation

      - Tax rate applies correctly

      - Tax calculated on subtotal after discount

      - Total = subtotal - discount + tax


      ### 6. Customer Selection

      - Search customers works

      - Select customer works

      - Customer name shows in cart

      - Clear customer works

      - Quick add new customer works


      ### 7. Payment

      - Cash payment works

      - Card payment works

      - Split payment works (if implemented)

      - Change calculation for cash


      ### 8. Complete Transaction

      - Uses atomic RPC function

      - Shows success message with transaction number

      - Clears cart after success

      - Handles errors gracefully

      - Shows insufficient stock details


      ### 9. Receipt

      - Receipt generates with all details

      - Print receipt works

      - Email receipt works (if implemented)

      - Receipt shows transaction number

      - Receipt shows itemized list

      - Receipt shows totals breakdown


      ### 10. Shift Management

      - Open shift with starting cash

      - Close shift with cash count

      - Variance calculation

      - Shift report generation


      ## Code Improvements Required


      ### Add Loading States

      ```typescript

      const [isSearching, setIsSearching] = useState(false);

      const [isProcessing, setIsProcessing] = useState(false);

      const [isPrinting, setIsPrinting] = useState(false);

      ```


      ### Add Error Boundary

      ```typescript

      // Wrap CashRegister in error boundary

      <ErrorBoundary
        fallback={
          <div className="p-8 text-center">
            <h2>Something went wrong</h2>
            <p>The POS system encountered an error.</p>
            <Button onClick={() => window.location.reload()}>
              Reload POS
            </Button>
          </div>
        }
      >
        <CashRegister />
      </ErrorBoundary>

      ```


      ### Add Keyboard Shortcuts

      ```typescript

      useEffect(() => {
        const handleKeyDown = (e: KeyboardEvent) => {
          // F2 - Focus search
          if (e.key === 'F2') {
            e.preventDefault();
            searchInputRef.current?.focus();
          }
          // F4 - Clear cart
          if (e.key === 'F4' && cart.length > 0) {
            e.preventDefault();
            if (confirm('Clear cart?')) setCart([]);
          }
          // F12 - Complete transaction
          if (e.key === 'F12' && cart.length > 0) {
            e.preventDefault();
            completeTransaction();
          }
          // Escape - Close modals
          if (e.key === 'Escape') {
            setShowPaymentModal(false);
            setShowReceiptModal(false);
          }
        };
        
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, [cart]);

      ```


      ### Add Offline Support

      ```typescript

      const [isOffline, setIsOffline] = useState(!navigator.onLine);

      const [pendingTransactions, setPendingTransactions] = useState<any[]>([]);


      useEffect(() => {
        const handleOnline = () => {
          setIsOffline(false);
          // Sync pending transactions
          syncPendingTransactions();
        };
        const handleOffline = () => setIsOffline(true);
        
        window.addEventListener('online', handleOnline);
        window.addEventListener('offline', handleOffline);
        
        return () => {
          window.removeEventListener('online', handleOnline);
          window.removeEventListener('offline', handleOffline);
        };
      }, []);


      // If offline, queue transaction locally

      const queueOfflineTransaction = (transaction: any) => {
        const pending = JSON.parse(localStorage.getItem('pendingPosTransactions') || '[]');
        pending.push({ ...transaction, queuedAt: new Date().toISOString() });
        localStorage.setItem('pendingPosTransactions', JSON.stringify(pending));
        setPendingTransactions(pending);
      };

      ```


      ### Add Barcode Scanner Support

      ```typescript

      const [barcodeBuffer, setBarcodeBuffer] = useState('');

      const lastKeyTime = useRef(0);


      useEffect(() => {
        const handleBarcodeInput = (e: KeyboardEvent) => {
          const currentTime = Date.now();
          
          // Barcode scanners typically input very fast
          if (currentTime - lastKeyTime.current > 100) {
            setBarcodeBuffer('');
          }
          lastKeyTime.current = currentTime;
          
          if (e.key === 'Enter' && barcodeBuffer.length > 5) {
            // Look up product by barcode
            const product = products.find(p => p.barcode === barcodeBuffer);
            if (product) {
              addToCart(product);
            } else {
              toast.error(`Product not found: ${barcodeBuffer}`);
            }
            setBarcodeBuffer('');
          } else if (e.key.length === 1) {
            setBarcodeBuffer(prev => prev + e.key);
          }
        };
        
        window.addEventListener('keydown', handleBarcodeInput);
        return () => window.removeEventListener('keydown', handleBarcodeInput);
      }, [barcodeBuffer, products]);

      ```
    acceptance_criteria:
      - All 10 verification areas pass
      - Loading states on all async operations
      - Error boundary prevents crashes
      - Keyboard shortcuts work
      - Barcode scanning works
      - Offline queue works
      - Mobile responsive layout
      - Accessibility labels on all controls
    completed: true
  - id: verify-enhance-orders-page
    title: Verify and Enhance Orders Management Page
    priority: P1
    estimated_minutes: 40
    description: >
      ## File

      src/pages/admin/Orders.tsx


      ## Verification Checklist


      ### 1. Orders List

      - Orders load with pagination

      - Shows order number, date, customer, status, total

      - Sorted by date descending (newest first)

      - Empty state shows helpful message


      ### 2. Filtering

      - Status filter works (all, pending, processing, shipped, delivered,
      cancelled)

      - Date range filter works

      - Customer filter/search works

      - Filters combine correctly

      - Clear filters button works


      ### 3. Order Details

      - Click order opens details modal

      - Shows all order items with quantities and prices

      - Shows customer information

      - Shows shipping address

      - Shows order notes

      - Shows payment status


      ### 4. Status Updates

      - Status dropdown works

      - Status change saves to database

      - Status change shows in UI immediately (optimistic update)

      - Delivered status sets delivered_at timestamp


      ### 5. Bulk Operations

      - Select multiple orders works

      - Select all on current page works

      - Bulk status change works

      - Bulk status change HAS TENANT ISOLATION (critical security fix)


      ### 6. Search

      - Search by order number works

      - Search by customer name works

      - Search is debounced (not on every keystroke)


      ## Critical Security Fix


      The bulk status update is missing tenant_id filtering. Fix this:


      ```typescript

      // BEFORE (insecure - allows updating any tenant's orders)

      const { error } = await supabase
        .from('orders')
        .update({ status })
        .in('id', selectedOrders);

      // AFTER (secure - only updates current tenant's orders)

      const { error } = await supabase
        .from('orders')
        .update({ 
          status,
          updated_at: new Date().toISOString(),
          ...(status === 'delivered' && { delivered_at: new Date().toISOString() }),
          ...(status === 'shipped' && { shipped_at: new Date().toISOString() }),
        })
        .in('id', selectedOrders)
        .eq('tenant_id', tenant.id); // CRITICAL: Add tenant isolation
      ```


      ## Enhancement: Add Order Timeline


      ```typescript

      interface OrderEvent {
        id: string;
        event_type: 'created' | 'status_changed' | 'note_added' | 'payment_received';
        description: string;
        created_at: string;
        created_by: string;
      }


      const OrderTimeline = ({ orderId }: { orderId: string }) => {
        const { data: events } = useQuery({
          queryKey: ['order-events', orderId],
          queryFn: async () => {
            const { data } = await supabase
              .from('order_events')
              .select('*')
              .eq('order_id', orderId)
              .order('created_at', { ascending: false });
            return data;
          }
        });
        
        return (
          <div className="space-y-4">
            {events?.map(event => (
              <div key={event.id} className="flex gap-3">
                <div className="w-2 h-2 mt-2 rounded-full bg-primary" />
                <div>
                  <p className="text-sm">{event.description}</p>
                  <p className="text-xs text-muted-foreground">
                    {format(new Date(event.created_at), 'PPp')}
                  </p>
                </div>
              </div>
            ))}
          </div>
        );
      };

      ```


      ## Enhancement: Add Quick Actions


      ```typescript

      const QuickActions = ({ order }: { order: Order }) => (
        <DropdownMenu>
          <DropdownMenuTrigger asChild>
            <Button variant="ghost" size="icon">
              <MoreHorizontal className="h-4 w-4" />
            </Button>
          </DropdownMenuTrigger>
          <DropdownMenuContent>
            <DropdownMenuItem onClick={() => viewOrder(order)}>
              <Eye className="mr-2 h-4 w-4" />
              View Details
            </DropdownMenuItem>
            <DropdownMenuItem onClick={() => printOrder(order)}>
              <Printer className="mr-2 h-4 w-4" />
              Print Order
            </DropdownMenuItem>
            <DropdownMenuItem onClick={() => generateInvoice(order)}>
              <FileText className="mr-2 h-4 w-4" />
              Generate Invoice
            </DropdownMenuItem>
            <DropdownMenuSeparator />
            <DropdownMenuItem 
              onClick={() => cancelOrder(order)}
              className="text-destructive"
            >
              <XCircle className="mr-2 h-4 w-4" />
              Cancel Order
            </DropdownMenuItem>
          </DropdownMenuContent>
        </DropdownMenu>
      );

      ```
    acceptance_criteria:
      - All orders load correctly with tenant isolation
      - Filtering and search work correctly
      - Status updates save immediately
      - Bulk operations have tenant isolation (security critical)
      - Order timeline shows history
      - Quick actions menu works
      - Mobile responsive
      - Keyboard accessible
    completed: true
  - id: verify-enhance-invoices-page
    title: Verify and Enhance Invoices Management Page
    priority: P1
    estimated_minutes: 40
    description: >
      ## File

      src/pages/admin/InvoicesPage.tsx


      ## Verification Checklist


      ### 1. Invoice List

      - Invoices load with pagination

      - Shows invoice number, date, customer, amount, status

      - Overdue invoices highlighted

      - Payment status clear (draft, sent, paid, overdue, cancelled)


      ### 2. Create Invoice

      - Create from scratch works

      - Create from order works

      - Select customer works

      - Add line items works

      - Tax calculation works

      - Due date setting works

      - Notes field works


      ### 3. Edit Invoice

      - Only draft invoices can be edited

      - Line items can be added/removed/modified

      - Customer can be changed

      - Totals recalculate


      ### 4. Invoice Actions

      - Mark as sent works

      - Mark as paid works (records payment date)

      - Void invoice works

      - Duplicate invoice works


      ### 5. PDF Generation

      - PDF generates correctly

      - PDF includes tenant branding (logo, colors, address)

      - PDF includes all line items

      - PDF includes terms and conditions

      - PDF includes payment instructions

      - Download PDF works

      - Print PDF works


      ### 6. Email Invoice

      - Send to customer works

      - Custom message works

      - Attachment includes PDF

      - Sent status updates


      ### 7. Invoice Stats

      - Total outstanding accurate

      - Total paid this month accurate

      - Average payment time accurate

      - Overdue count accurate


      ## Enhancement: PDF Generation with Branding


      ```typescript

      import jsPDF from 'jspdf';


      const generateInvoicePDF = async (invoice: Invoice) => {
        const doc = new jsPDF();
        
        // Get tenant branding
        const { data: tenant } = await supabase
          .from('tenants')
          .select('name, logo_url, primary_color, address, phone, email')
          .eq('id', invoice.tenant_id)
          .single();
        
        // Header with logo
        if (tenant?.logo_url) {
          const img = await loadImage(tenant.logo_url);
          doc.addImage(img, 'PNG', 15, 15, 40, 40);
        }
        
        // Company info
        doc.setFontSize(20);
        doc.setTextColor(tenant?.primary_color || '#000000');
        doc.text(tenant?.name || 'Company', 60, 25);
        
        doc.setFontSize(10);
        doc.setTextColor('#666666');
        doc.text(tenant?.address || '', 60, 32);
        doc.text(`Phone: ${tenant?.phone || ''}`, 60, 38);
        doc.text(`Email: ${tenant?.email || ''}`, 60, 44);
        
        // Invoice title
        doc.setFontSize(24);
        doc.setTextColor('#000000');
        doc.text('INVOICE', 150, 25);
        
        // Invoice details
        doc.setFontSize(10);
        doc.text(`Invoice #: ${invoice.invoice_number}`, 150, 35);
        doc.text(`Date: ${format(new Date(invoice.created_at), 'PP')}`, 150, 41);
        doc.text(`Due Date: ${format(new Date(invoice.due_date), 'PP')}`, 150, 47);
        
        // Bill to
        doc.setFontSize(12);
        doc.text('Bill To:', 15, 70);
        doc.setFontSize(10);
        doc.text(invoice.customer_name, 15, 77);
        doc.text(invoice.customer_email || '', 15, 83);
        doc.text(invoice.customer_address || '', 15, 89);
        
        // Line items table
        let y = 110;
        
        // Table header
        doc.setFillColor('#f3f4f6');
        doc.rect(15, y - 5, 180, 10, 'F');
        doc.setFontSize(10);
        doc.setTextColor('#000000');
        doc.text('Description', 17, y);
        doc.text('Qty', 100, y);
        doc.text('Unit Price', 120, y);
        doc.text('Total', 160, y);
        
        y += 10;
        
        // Table rows
        invoice.items.forEach((item: any) => {
          doc.text(item.description, 17, y);
          doc.text(String(item.quantity), 100, y);
          doc.text(`$${item.unit_price.toFixed(2)}`, 120, y);
          doc.text(`$${(item.quantity * item.unit_price).toFixed(2)}`, 160, y);
          y += 8;
        });
        
        // Totals
        y += 10;
        doc.text(`Subtotal: $${invoice.subtotal.toFixed(2)}`, 140, y);
        y += 6;
        if (invoice.tax_amount > 0) {
          doc.text(`Tax: $${invoice.tax_amount.toFixed(2)}`, 140, y);
          y += 6;
        }
        if (invoice.discount_amount > 0) {
          doc.text(`Discount: -$${invoice.discount_amount.toFixed(2)}`, 140, y);
          y += 6;
        }
        doc.setFontSize(12);
        doc.setFont(undefined, 'bold');
        doc.text(`Total: $${invoice.total_amount.toFixed(2)}`, 140, y);
        
        // Payment terms
        y += 20;
        doc.setFont(undefined, 'normal');
        doc.setFontSize(10);
        doc.text('Payment Terms:', 15, y);
        doc.text(invoice.payment_terms || 'Net 30', 50, y);
        
        // Notes
        if (invoice.notes) {
          y += 15;
          doc.text('Notes:', 15, y);
          y += 6;
          doc.text(invoice.notes, 15, y, { maxWidth: 180 });
        }
        
        // Footer
        doc.setFontSize(8);
        doc.setTextColor('#999999');
        doc.text('Thank you for your business!', 105, 280, { align: 'center' });
        
        return doc;
      };

      ```
    acceptance_criteria:
      - Invoice CRUD works correctly
      - PDF generation includes all branding
      - Email delivery works
      - Stats are accurate
      - Overdue tracking works
      - Payment recording works
      - Mobile responsive
    completed: true
  - id: verify-enhance-products-page
    title: Verify and Enhance Products Management Page
    priority: P1
    estimated_minutes: 45
    description: >
      ## File

      src/pages/admin/ProductManagement.tsx


      ## Verification Checklist


      ### 1. Product List

      - Products load with pagination

      - Grid and list view toggle

      - Shows image, name, SKU, price, stock

      - Low stock indicators

      - Out of stock indicators


      ### 2. Create Product

      - All fields save correctly

      - Image upload works

      - Multiple images support

      - Category assignment works

      - SKU auto-generation or manual

      - Barcode field works

      - Price validation (>= 0)

      - Stock validation (integer >= 0)

      - Cannabis-specific fields (THC%, CBD%, strain type)


      ### 3. Edit Product

      - All fields load correctly

      - Changes save correctly

      - Image replacement works

      - Image removal works


      ### 4. Delete Product

      - Soft delete for products with order history

      - Hard delete for products without orders

      - Confirmation dialog

      - Undo option (for soft delete)


      ### 5. Filtering

      - Category filter works

      - Stock status filter (all, in stock, low stock, out of stock)

      - Price range filter

      - Search by name/SKU works


      ### 6. Bulk Operations

      - Select multiple products

      - Bulk price update

      - Bulk category change

      - Bulk stock adjustment

      - Bulk delete


      ### 7. Cannabis Compliance

      - THC/CBD percentage validation (0-100)

      - Potency alerts for high-THC products

      - Batch/lot number tracking

      - Expiration date tracking

      - Lab test results link


      ## Enhancements


      ### Add Comprehensive Validation


      ```typescript

      const productSchema = z.object({
        name: z.string().min(1, 'Name is required').max(200),
        sku: z.string().min(1, 'SKU is required').max(50),
        barcode: z.string().optional(),
        description: z.string().optional(),
        category_id: z.string().uuid().optional(),
        price: z.number().min(0, 'Price must be positive'),
        cost_price: z.number().min(0, 'Cost must be positive').optional(),
        stock_quantity: z.number().int().min(0, 'Stock must be non-negative'),
        low_stock_threshold: z.number().int().min(0).default(10),
        unit: z.enum(['unit', 'gram', 'ounce', 'pound', 'pack']).default('unit'),
        
        // Cannabis-specific
        thc_percentage: z.number().min(0).max(100).optional(),
        cbd_percentage: z.number().min(0).max(100).optional(),
        strain_type: z.enum(['indica', 'sativa', 'hybrid', 'cbd', 'n/a']).optional(),
        batch_number: z.string().optional(),
        lab_test_url: z.string().url().optional(),
        expiration_date: z.string().optional(),
        
        // Status
        status: z.enum(['active', 'inactive', 'discontinued']).default('active'),
        is_taxable: z.boolean().default(true),
        is_featured: z.boolean().default(false),
      });

      ```


      ### Add Stock Adjustment with Reason


      ```typescript

      const StockAdjustmentDialog = ({ product, onClose }: Props) => {
        const [adjustmentType, setAdjustmentType] = useState<'add' | 'subtract' | 'set'>('add');
        const [quantity, setQuantity] = useState(0);
        const [reason, setReason] = useState('');
        
        const handleAdjust = async () => {
          let newStock = product.stock_quantity;
          
          switch (adjustmentType) {
            case 'add':
              newStock += quantity;
              break;
            case 'subtract':
              newStock = Math.max(0, newStock - quantity);
              break;
            case 'set':
              newStock = quantity;
              break;
          }
          
          // Update stock
          await supabase
            .from('products')
            .update({ 
              stock_quantity: newStock,
              updated_at: new Date().toISOString()
            })
            .eq('id', product.id)
            .eq('tenant_id', tenant.id);
          
          // Log the adjustment
          await supabase
            .from('inventory_movements')
            .insert({
              tenant_id: tenant.id,
              product_id: product.id,
              movement_type: 'adjustment',
              quantity: newStock - product.stock_quantity,
              notes: reason,
              created_by: user.id
            });
          
          toast.success('Stock adjusted');
          onClose();
        };
        
        return (
          <Dialog open onOpenChange={onClose}>
            <DialogContent>
              <DialogHeader>
                <DialogTitle>Adjust Stock: {product.name}</DialogTitle>
              </DialogHeader>
              
              <div className="space-y-4">
                <div>
                  <Label>Current Stock</Label>
                  <p className="text-2xl font-bold">{product.stock_quantity}</p>
                </div>
                
                <div>
                  <Label>Adjustment Type</Label>
                  <Select value={adjustmentType} onValueChange={setAdjustmentType}>
                    <SelectTrigger>
                      <SelectValue />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="add">Add Stock</SelectItem>
                      <SelectItem value="subtract">Remove Stock</SelectItem>
                      <SelectItem value="set">Set Stock To</SelectItem>
                    </SelectContent>
                  </Select>
                </div>
                
                <div>
                  <Label>Quantity</Label>
                  <Input 
                    type="number" 
                    min={0}
                    value={quantity} 
                    onChange={e => setQuantity(parseInt(e.target.value) || 0)}
                  />
                </div>
                
                <div>
                  <Label>Reason (required)</Label>
                  <Textarea 
                    value={reason}
                    onChange={e => setReason(e.target.value)}
                    placeholder="e.g., Received shipment, Damaged goods, Inventory count correction"
                  />
                </div>
                
                <div className="flex justify-end gap-2">
                  <Button variant="outline" onClick={onClose}>Cancel</Button>
                  <Button onClick={handleAdjust} disabled={!reason}>
                    Apply Adjustment
                  </Button>
                </div>
              </div>
            </DialogContent>
          </Dialog>
        );
      };

      ```
    acceptance_criteria:
      - Product CRUD works correctly
      - Image upload/management works
      - Validation prevents bad data
      - Cannabis compliance fields work
      - Stock adjustments logged with reasons
      - Bulk operations work with tenant isolation
      - Soft delete preserves order history
  - id: verify-enhance-inventory-page
    title: Verify and Enhance Inventory Management Page
    priority: P1
    estimated_minutes: 40
    description: >
      ## File

      src/pages/admin/InventoryManagement.tsx


      ## Critical Fix


      Remove hardcoded inventory value calculation (lines 89-91):


      ```typescript

      // BEFORE (hardcoded - WRONG)

      const totalValue = 3000 * totalWeight;


      // AFTER (calculate from actual product costs)

      const totalValue = products.reduce((sum, product) => {
        const cost = product.cost_price || product.wholesale_price || product.price || 0;
        const quantity = Number(product.stock_quantity || 0);
        return sum + (quantity * cost);
      }, 0);

      ```


      ## Verification Checklist


      ### 1. Dashboard Overview

      - Total products count accurate

      - Total stock quantity accurate

      - Total inventory value accurate (using actual costs)

      - Low stock alert count accurate

      - Out of stock count accurate


      ### 2. Stock Levels Display

      - All products shown with current stock

      - Color coding for stock status (green, yellow, red)

      - Sortable by stock level

      - Filterable by category


      ### 3. Low Stock Alerts

      - Products below threshold shown

      - Threshold is configurable per product

      - Alert can generate purchase order suggestion


      ### 4. Stock Adjustments

      - Adjust stock with reason

      - Multiple adjustment types (receive, damage, count, transfer)

      - All adjustments logged

      - Adjustment history viewable


      ### 5. Inventory Movements

      - Shows all stock changes

      - Filterable by type (sale, purchase, adjustment, transfer)

      - Filterable by date range

      - Filterable by product

      - Shows who made the change


      ### 6. Location Management (if multi-location)

      - Shows stock per location

      - Transfer between locations

      - Location-specific low stock alerts


      ## Enhancement: Inventory Analytics


      ```typescript

      const InventoryAnalytics = () => {
        const { data: analytics } = useQuery({
          queryKey: ['inventory-analytics', tenant.id],
          queryFn: async () => {
            // Get product performance data
            const { data: products } = await supabase
              .from('products')
              .select(`
                id, name, sku, stock_quantity, cost_price, price,
                pos_transaction_items:pos_transactions(items)
              `)
              .eq('tenant_id', tenant.id);
            
            // Calculate metrics
            const metrics = products?.map(product => {
              const soldLast30Days = calculateSoldQuantity(product, 30);
              const avgDailySales = soldLast30Days / 30;
              const daysOfStock = avgDailySales > 0 
                ? Math.floor(product.stock_quantity / avgDailySales)
                : Infinity;
              const turnoverRate = avgDailySales * 30 / (product.stock_quantity || 1);
              
              return {
                ...product,
                soldLast30Days,
                avgDailySales,
                daysOfStock,
                turnoverRate,
                reorderSuggested: daysOfStock < 14
              };
            });
            
            return {
              products: metrics,
              totalValue: metrics?.reduce((sum, p) => 
                sum + (p.stock_quantity * (p.cost_price || 0)), 0),
              slowMoving: metrics?.filter(p => p.turnoverRate < 0.5),
              fastMoving: metrics?.filter(p => p.turnoverRate > 2),
              needsReorder: metrics?.filter(p => p.reorderSuggested)
            };
          }
        });
        
        return (
          <div className="grid grid-cols-4 gap-4">
            <Card>
              <CardHeader>
                <CardTitle>Inventory Value</CardTitle>
              </CardHeader>
              <CardContent>
                <p className="text-3xl font-bold">
                  ${analytics?.totalValue?.toLocaleString() || 0}
                </p>
              </CardContent>
            </Card>
            
            <Card>
              <CardHeader>
                <CardTitle>Needs Reorder</CardTitle>
              </CardHeader>
              <CardContent>
                <p className="text-3xl font-bold text-orange-500">
                  {analytics?.needsReorder?.length || 0}
                </p>
              </CardContent>
            </Card>
            
            <Card>
              <CardHeader>
                <CardTitle>Fast Moving</CardTitle>
              </CardHeader>
              <CardContent>
                <p className="text-3xl font-bold text-green-500">
                  {analytics?.fastMoving?.length || 0}
                </p>
              </CardContent>
            </Card>
            
            <Card>
              <CardHeader>
                <CardTitle>Slow Moving</CardTitle>
              </CardHeader>
              <CardContent>
                <p className="text-3xl font-bold text-red-500">
                  {analytics?.slowMoving?.length || 0}
                </p>
              </CardContent>
            </Card>
          </div>
        );
      };

      ```
    acceptance_criteria:
      - Inventory value calculated correctly (not hardcoded)
      - Low stock alerts working
      - Stock adjustments logged properly
      - Movement history accurate
      - Analytics provide useful insights
      - Mobile responsive
  - id: verify-enhance-customer-page
    title: Verify and Enhance Customer Management Page
    priority: P1
    estimated_minutes: 35
    description: >
      ## File

      src/pages/admin/CustomerManagement.tsx


      ## Verification Checklist


      ### 1. Customer List

      - Customers load with pagination

      - Shows name, email, phone, type, status, total orders

      - Searchable by name, email, phone

      - Filterable by type (retail, wholesale)

      - Filterable by status (active, inactive)


      ### 2. Create Customer

      - All fields save correctly

      - Email validation

      - Phone formatting

      - Required fields enforced

      - Duplicate email check


      ### 3. Edit Customer

      - All fields load correctly

      - Changes save correctly

      - Audit trail of changes


      ### 4. Delete Customer

      - Soft delete for customers with orders

      - Confirmation dialog

      - Shows order count before delete


      ### 5. Customer Details

      - Order history tab

      - Invoice history tab

      - Notes/activity tab

      - Credit limit (for wholesale)

      - Loyalty points (if applicable)


      ### 6. Data Encryption

      - Sensitive fields encrypted at rest

      - Decryption works correctly

      - Graceful fallback for encryption key mismatch


      ## Enhancement: Customer 360 View


      ```typescript

      const Customer360View = ({ customerId }: { customerId: string }) => {
        const { data: customer } = useQuery({
          queryKey: ['customer-360', customerId],
          queryFn: async () => {
            const { data } = await supabase
              .from('customers')
              .select(`
                *,
                orders:orders(id, order_number, total_amount, status, created_at),
                invoices:invoices(id, invoice_number, total_amount, status, created_at)
              `)
              .eq('id', customerId)
              .single();
            
            // Calculate metrics
            const totalOrders = data?.orders?.length || 0;
            const totalSpent = data?.orders?.reduce((sum, o) => sum + o.total_amount, 0) || 0;
            const avgOrderValue = totalOrders > 0 ? totalSpent / totalOrders : 0;
            const lastOrderDate = data?.orders?.[0]?.created_at;
            
            return {
              ...data,
              metrics: {
                totalOrders,
                totalSpent,
                avgOrderValue,
                lastOrderDate,
                customerSince: data?.created_at,
                daysSinceLastOrder: lastOrderDate 
                  ? Math.floor((Date.now() - new Date(lastOrderDate).getTime()) / (1000 * 60 * 60 * 24))
                  : null
              }
            };
          }
        });
        
        return (
          <div className="space-y-6">
            {/* Customer Header */}
            <div className="flex items-center gap-4">
              <Avatar className="h-16 w-16">
                <AvatarFallback>{customer?.name?.[0]}</AvatarFallback>
              </Avatar>
              <div>
                <h2 className="text-2xl font-bold">{customer?.name}</h2>
                <p className="text-muted-foreground">{customer?.email}</p>
                <Badge variant={customer?.status === 'active' ? 'default' : 'secondary'}>
                  {customer?.status}
                </Badge>
              </div>
            </div>
            
            {/* Metrics Grid */}
            <div className="grid grid-cols-4 gap-4">
              <Card>
                <CardContent className="pt-4">
                  <p className="text-sm text-muted-foreground">Total Orders</p>
                  <p className="text-2xl font-bold">{customer?.metrics.totalOrders}</p>
                </CardContent>
              </Card>
              <Card>
                <CardContent className="pt-4">
                  <p className="text-sm text-muted-foreground">Total Spent</p>
                  <p className="text-2xl font-bold">${customer?.metrics.totalSpent?.toFixed(2)}</p>
                </CardContent>
              </Card>
              <Card>
                <CardContent className="pt-4">
                  <p className="text-sm text-muted-foreground">Avg Order</p>
                  <p className="text-2xl font-bold">${customer?.metrics.avgOrderValue?.toFixed(2)}</p>
                </CardContent>
              </Card>
              <Card>
                <CardContent className="pt-4">
                  <p className="text-sm text-muted-foreground">Last Order</p>
                  <p className="text-2xl font-bold">
                    {customer?.metrics.daysSinceLastOrder !== null 
                      ? `${customer.metrics.daysSinceLastOrder} days ago`
                      : 'Never'}
                  </p>
                </CardContent>
              </Card>
            </div>
            
            {/* Tabs */}
            <Tabs defaultValue="orders">
              <TabsList>
                <TabsTrigger value="orders">Orders</TabsTrigger>
                <TabsTrigger value="invoices">Invoices</TabsTrigger>
                <TabsTrigger value="notes">Notes</TabsTrigger>
              </TabsList>
              
              <TabsContent value="orders">
                <OrdersTable orders={customer?.orders || []} />
              </TabsContent>
              
              <TabsContent value="invoices">
                <InvoicesTable invoices={customer?.invoices || []} />
              </TabsContent>
              
              <TabsContent value="notes">
                <CustomerNotes customerId={customerId} />
              </TabsContent>
            </Tabs>
          </div>
        );
      };

      ```
    acceptance_criteria:
      - Customer CRUD works correctly
      - Data encryption/decryption works
      - Soft delete preserves order history
      - 360 view shows all customer data
      - Order and invoice history displayed
      - Metrics calculated correctly
  - id: verify-wholesale-operations
    title: Verify and Enhance Wholesale Operations
    priority: P1
    estimated_minutes: 40
    description: >
      ## Files

      - src/pages/admin/WholesaleClients.tsx

      - src/pages/admin/WholesaleOrdersPage.tsx

      - src/pages/admin/NewWholesaleOrder.tsx


      ## Verification Checklist


      ### Wholesale Clients

      - Client list loads with details

      - Create client with credit limit

      - Edit client details

      - View client order history

      - Credit limit tracking

      - Payment terms per client

      - Price tier assignment


      ### Wholesale Orders

      - Order pipeline view (kanban or list)

      - Drag-and-drop status change

      - Create order for client

      - Apply wholesale pricing

      - Credit limit enforcement

      - Minimum order quantities

      - Generate invoice from order


      ### Wholesale Pricing

      - Price tiers defined

      - Volume discounts applied

      - Client-specific pricing

      - Category-level pricing


      ## Enhancement: Credit Management


      ```typescript

      const CreditManagement = ({ client }: { client: WholesaleClient }) => {
        const { data: creditData } = useQuery({
          queryKey: ['client-credit', client.id],
          queryFn: async () => {
            const { data: orders } = await supabase
              .from('wholesale_orders')
              .select('total_amount, payment_status')
              .eq('client_id', client.id)
              .eq('tenant_id', tenant.id)
              .in('payment_status', ['pending', 'partial']);
            
            const outstandingBalance = orders?.reduce((sum, o) => sum + o.total_amount, 0) || 0;
            const availableCredit = (client.credit_limit || 0) - outstandingBalance;
            const creditUtilization = client.credit_limit 
              ? (outstandingBalance / client.credit_limit) * 100 
              : 0;
            
            return {
              creditLimit: client.credit_limit || 0,
              outstandingBalance,
              availableCredit,
              creditUtilization,
              isOverLimit: availableCredit < 0
            };
          }
        });
        
        return (
          <Card>
            <CardHeader>
              <CardTitle>Credit Status</CardTitle>
            </CardHeader>
            <CardContent>
              <div className="space-y-4">
                <div className="flex justify-between">
                  <span>Credit Limit</span>
                  <span className="font-bold">${creditData?.creditLimit.toLocaleString()}</span>
                </div>
                <div className="flex justify-between">
                  <span>Outstanding</span>
                  <span className="font-bold text-orange-500">
                    ${creditData?.outstandingBalance.toLocaleString()}
                  </span>
                </div>
                <div className="flex justify-between">
                  <span>Available</span>
                  <span className={cn(
                    "font-bold",
                    creditData?.isOverLimit ? "text-red-500" : "text-green-500"
                  )}>
                    ${creditData?.availableCredit.toLocaleString()}
                  </span>
                </div>
                
                <Progress 
                  value={creditData?.creditUtilization} 
                  className={cn(
                    creditData?.creditUtilization > 80 && "bg-orange-200",
                    creditData?.creditUtilization > 100 && "bg-red-200"
                  )}
                />
                
                {creditData?.isOverLimit && (
                  <Alert variant="destructive">
                    <AlertTriangle className="h-4 w-4" />
                    <AlertDescription>
                      This client is over their credit limit. New orders require payment first.
                    </AlertDescription>
                  </Alert>
                )}
              </div>
            </CardContent>
          </Card>
        );
      };

      ```
    acceptance_criteria:
      - Wholesale client CRUD works
      - Order pipeline works with drag-drop
      - Credit limits enforced
      - Wholesale pricing applied correctly
      - Invoice generation works
      - Payment tracking works
  - id: deploy-verify-edge-functions
    title: Deploy and Verify All Edge Functions
    priority: P2
    estimated_minutes: 45
    description: >
      ## Overview

      Deploy all 159 edge functions to the production Supabase project and
      verify

      critical functions work correctly.


      ## Deployment Steps


      ### 1. Link to Production Project

      ```bash

      supabase link --project-ref mtvwmyerntkhrcdnhahp

      ```


      ### 2. Verify All Secrets Are Set

      ```bash

      supabase secrets list --project-ref mtvwmyerntkhrcdnhahp

      ```


      Required secrets:

      - SUPABASE_URL

      - SUPABASE_SERVICE_ROLE_KEY

      - JWT_SECRET

      - STRIPE_SECRET_KEY

      - STRIPE_WEBHOOK_SECRET

      - RESEND_API_KEY

      - MAPBOX_ACCESS_TOKEN

      - CLERK_SECRET_KEY

      - CLERK_WEBHOOK_SECRET

      - REDIS_HOST

      - REDIS_PASSWORD

      - REDIS_PORT

      - ENCRYPTION_KEY


      ### 3. Deploy All Functions

      ```bash

      supabase functions deploy --project-ref mtvwmyerntkhrcdnhahp

      ```


      ### 4. Verify Critical Functions


      #### validate-tenant

      ```bash

      curl -X POST
      https://mtvwmyerntkhrcdnhahp.supabase.co/functions/v1/validate-tenant \
        -H "Content-Type: application/json" \
        -H "Authorization: Bearer ${ANON_KEY}" \
        -d '{"slug":"willysbo"}'
      ```

      Expected: `{"valid": true, "tenant": {...}}`


      #### tenant-admin-auth (login)

      Test through the UI login flow

      Expected: Successful login with tokens set


      #### tenant-admin-auth (refresh)

      Test by waiting for token expiry or manually triggering refresh

      Expected: New tokens returned


      #### check-stripe-config

      ```bash

      curl
      https://mtvwmyerntkhrcdnhahp.supabase.co/functions/v1/check-stripe-config
      \
        -H "Authorization: Bearer ${ACCESS_TOKEN}"
      ```

      Expected: Stripe connection status


      #### send-notification

      ```bash

      curl -X POST
      https://mtvwmyerntkhrcdnhahp.supabase.co/functions/v1/send-notification \
        -H "Content-Type: application/json" \
        -H "Authorization: Bearer ${ACCESS_TOKEN}" \
        -d '{
          "type": "email",
          "to": "test@example.com",
          "subject": "Test",
          "body": "Test notification"
        }'
      ```

      Expected: Notification sent confirmation


      ### 5. Check Function Logs

      ```bash

      supabase functions logs --project-ref mtvwmyerntkhrcdnhahp

      ```


      Look for any errors or warnings during startup.
    acceptance_criteria:
      - All 159 functions deployed successfully
      - No deployment errors
      - All required secrets configured
      - validate-tenant returns correct data
      - Auth flow works end-to-end
      - Stripe integration verified
      - Email notifications work
      - Function logs show no errors
  - id: add-database-indexes
    title: Add Critical Database Indexes for Performance
    priority: P2
    estimated_minutes: 25
    description: >
      ## File to Create

      supabase/migrations/[timestamp]_add_performance_indexes.sql


      ## Migration SQL


      ```sql

      -- Performance indexes for FloraIQ

      -- These indexes improve query performance for common operations


      -- Products indexes

      CREATE INDEX IF NOT EXISTS idx_products_tenant_status 
        ON products(tenant_id, status);
      CREATE INDEX IF NOT EXISTS idx_products_tenant_category 
        ON products(tenant_id, category_id);
      CREATE INDEX IF NOT EXISTS idx_products_tenant_sku 
        ON products(tenant_id, sku);
      CREATE INDEX IF NOT EXISTS idx_products_tenant_barcode 
        ON products(tenant_id, barcode) WHERE barcode IS NOT NULL;
      CREATE INDEX IF NOT EXISTS idx_products_low_stock 
        ON products(tenant_id, stock_quantity, low_stock_threshold)
        WHERE stock_quantity <= low_stock_threshold;
      CREATE INDEX IF NOT EXISTS idx_products_search 
        ON products USING gin(to_tsvector('english', name || ' ' || COALESCE(description, '')));

      -- Orders indexes

      CREATE INDEX IF NOT EXISTS idx_orders_tenant_status 
        ON orders(tenant_id, status);
      CREATE INDEX IF NOT EXISTS idx_orders_tenant_created 
        ON orders(tenant_id, created_at DESC);
      CREATE INDEX IF NOT EXISTS idx_orders_customer 
        ON orders(customer_id);
      CREATE INDEX IF NOT EXISTS idx_orders_tenant_customer 
        ON orders(tenant_id, customer_id);

      -- Customers indexes

      CREATE INDEX IF NOT EXISTS idx_customers_tenant_status 
        ON customers(tenant_id, status);
      CREATE INDEX IF NOT EXISTS idx_customers_tenant_email 
        ON customers(tenant_id, email);
      CREATE INDEX IF NOT EXISTS idx_customers_search 
        ON customers USING gin(to_tsvector('english', name || ' ' || COALESCE(email, '')));

      -- Invoices indexes

      CREATE INDEX IF NOT EXISTS idx_invoices_tenant_status 
        ON invoices(tenant_id, status);
      CREATE INDEX IF NOT EXISTS idx_invoices_tenant_due_date 
        ON invoices(tenant_id, due_date)
        WHERE status NOT IN ('paid', 'cancelled');
      CREATE INDEX IF NOT EXISTS idx_invoices_customer 
        ON invoices(customer_id);

      -- POS transactions indexes

      CREATE INDEX IF NOT EXISTS idx_pos_transactions_tenant_created 
        ON pos_transactions(tenant_id, created_at DESC);
      CREATE INDEX IF NOT EXISTS idx_pos_transactions_shift 
        ON pos_transactions(shift_id);
      CREATE INDEX IF NOT EXISTS idx_pos_transactions_tenant_date 
        ON pos_transactions(tenant_id, (created_at::date));

      -- Inventory movements indexes

      CREATE INDEX IF NOT EXISTS idx_inventory_movements_tenant_product 
        ON inventory_movements(tenant_id, product_id);
      CREATE INDEX IF NOT EXISTS idx_inventory_movements_created 
        ON inventory_movements(created_at DESC);

      -- Vendors indexes

      CREATE INDEX IF NOT EXISTS idx_vendors_tenant_status 
        ON vendors(tenant_id, status);

      -- Wholesale indexes

      CREATE INDEX IF NOT EXISTS idx_wholesale_clients_tenant 
        ON wholesale_clients(tenant_id);
      CREATE INDEX IF NOT EXISTS idx_wholesale_orders_tenant_status 
        ON wholesale_orders(tenant_id, status);
      CREATE INDEX IF NOT EXISTS idx_wholesale_orders_client 
        ON wholesale_orders(client_id);

      -- Tenant users index for RLS performance

      CREATE INDEX IF NOT EXISTS idx_tenant_users_user_id 
        ON tenant_users(user_id);
      CREATE INDEX IF NOT EXISTS idx_tenant_users_tenant_id 
        ON tenant_users(tenant_id);

      -- Analyze tables to update statistics

      ANALYZE products;

      ANALYZE orders;

      ANALYZE customers;

      ANALYZE invoices;

      ANALYZE pos_transactions;

      ANALYZE vendors;

      ANALYZE inventory_movements;

      ANALYZE wholesale_clients;

      ANALYZE wholesale_orders;

      ANALYZE tenant_users;

      ```
    acceptance_criteria:
      - All indexes created successfully
      - No errors during migration
      - Query performance improved for common operations
      - RLS policy checks faster due to tenant_users index
  - id: add-error-boundaries
    title: Add Error Boundaries Throughout the Application
    priority: P2
    estimated_minutes: 30
    description: >
      ## Overview

      Add React error boundaries to prevent full page crashes and provide

      graceful degradation when errors occur.


      ## File to Create

      src/components/common/ErrorBoundary.tsx


      ```typescript

      import React, { Component, ErrorInfo, ReactNode } from 'react';

      import { AlertTriangle, RefreshCw } from 'lucide-react';

      import { Button } from '@/components/ui/button';

      import { Card, CardContent, CardHeader, CardTitle } from
      '@/components/ui/card';

      import { logger } from '@/lib/logger';


      interface Props {
        children: ReactNode;
        fallback?: ReactNode;
        onError?: (error: Error, errorInfo: ErrorInfo) => void;
        showDetails?: boolean;
      }


      interface State {
        hasError: boolean;
        error: Error | null;
        errorInfo: ErrorInfo | null;
      }


      export class ErrorBoundary extends Component<Props, State> {
        constructor(props: Props) {
          super(props);
          this.state = { hasError: false, error: null, errorInfo: null };
        }

        static getDerivedStateFromError(error: Error): State {
          return { hasError: true, error, errorInfo: null };
        }

        componentDidCatch(error: Error, errorInfo: ErrorInfo) {
          this.setState({ errorInfo });
          
          // Log error
          logger.error('React Error Boundary caught error', {
            error: error.message,
            stack: error.stack,
            componentStack: errorInfo.componentStack
          });
          
          // Call custom error handler if provided
          this.props.onError?.(error, errorInfo);
        }

        handleRetry = () => {
          this.setState({ hasError: false, error: null, errorInfo: null });
        };

        handleReload = () => {
          window.location.reload();
        };

        render() {
          if (this.state.hasError) {
            // Use custom fallback if provided
            if (this.props.fallback) {
              return this.props.fallback;
            }

            // Default error UI
            return (
              <Card className="m-4">
                <CardHeader>
                  <CardTitle className="flex items-center gap-2 text-destructive">
                    <AlertTriangle className="h-5 w-5" />
                    Something went wrong
                  </CardTitle>
                </CardHeader>
                <CardContent className="space-y-4">
                  <p className="text-muted-foreground">
                    An error occurred while rendering this component. 
                    You can try refreshing or contact support if the problem persists.
                  </p>
                  
                  {this.props.showDetails && this.state.error && (
                    <details className="text-sm">
                      <summary className="cursor-pointer text-muted-foreground">
                        Error details
                      </summary>
                      <pre className="mt-2 p-4 bg-muted rounded overflow-auto text-xs">
                        {this.state.error.message}
                        {'\n\n'}
                        {this.state.error.stack}
                      </pre>
                    </details>
                  )}
                  
                  <div className="flex gap-2">
                    <Button onClick={this.handleRetry} variant="outline">
                      <RefreshCw className="mr-2 h-4 w-4" />
                      Try Again
                    </Button>
                    <Button onClick={this.handleReload}>
                      Reload Page
                    </Button>
                  </div>
                </CardContent>
              </Card>
            );
          }

          return this.props.children;
        }
      }


      // HOC for easy wrapping

      export function withErrorBoundary<P extends object>(
        WrappedComponent: React.ComponentType<P>,
        fallback?: ReactNode
      ) {
        return function WithErrorBoundary(props: P) {
          return (
            <ErrorBoundary fallback={fallback}>
              <WrappedComponent {...props} />
            </ErrorBoundary>
          );
        };
      }

      ```


      ## Usage in Key Pages


      Wrap the following pages with ErrorBoundary:


      ### src/pages/admin/CashRegister.tsx

      ```typescript

      export default function CashRegisterPage() {
        return (
          <ErrorBoundary
            fallback={
              <div className="p-8 text-center">
                <AlertTriangle className="h-12 w-12 mx-auto text-destructive" />
                <h2 className="mt-4 text-xl font-bold">POS System Error</h2>
                <p className="mt-2 text-muted-foreground">
                  The cash register encountered an error. Your cart data may be preserved.
                </p>
                <Button onClick={() => window.location.reload()} className="mt-4">
                  Reload POS
                </Button>
              </div>
            }
          >
            <CashRegister />
          </ErrorBoundary>
        );
      }

      ```


      ### Add to other critical pages:

      - Dashboard

      - Orders

      - Invoices

      - Products

      - Inventory

      - Customers
    acceptance_criteria:
      - ErrorBoundary component created
      - All critical pages wrapped with error boundaries
      - Errors logged to logger service
      - Users see helpful error message instead of blank screen
      - Retry and reload options work
  - id: add-loading-states-skeletons
    title: Add Consistent Loading States and Skeleton Components
    priority: P2
    estimated_minutes: 30
    description: >
      ## Overview

      Create reusable loading skeleton components for consistent UX across the
      app.


      ## File to Create

      src/components/common/Skeletons.tsx


      ```typescript

      import { Skeleton } from '@/components/ui/skeleton';

      import { Card, CardContent, CardHeader } from '@/components/ui/card';


      // Table skeleton

      export const TableSkeleton = ({ rows = 5, columns = 4 }: { rows?: number;
      columns?: number }) => (
        <div className="space-y-2">
          {/* Header */}
          <div className="flex gap-4 p-4 border-b">
            {Array(columns).fill(0).map((_, i) => (
              <Skeleton key={i} className="h-4 flex-1" />
            ))}
          </div>
          
          {/* Rows */}
          {Array(rows).fill(0).map((_, rowIndex) => (
            <div key={rowIndex} className="flex gap-4 p-4 border-b">
              {Array(columns).fill(0).map((_, colIndex) => (
                <Skeleton key={colIndex} className="h-4 flex-1" />
              ))}
            </div>
          ))}
        </div>
      );


      // Card skeleton

      export const CardSkeleton = () => (
        <Card>
          <CardHeader>
            <Skeleton className="h-6 w-1/3" />
          </CardHeader>
          <CardContent>
            <Skeleton className="h-8 w-1/2 mb-2" />
            <Skeleton className="h-4 w-2/3" />
          </CardContent>
        </Card>
      );


      // Stats grid skeleton

      export const StatsGridSkeleton = ({ count = 4 }: { count?: number }) => (
        <div className="grid gap-4" style={{ gridTemplateColumns: `repeat(${count}, 1fr)` }}>
          {Array(count).fill(0).map((_, i) => (
            <CardSkeleton key={i} />
          ))}
        </div>
      );


      // Product grid skeleton

      export const ProductGridSkeleton = ({ count = 8 }: { count?: number }) =>
      (
        <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
          {Array(count).fill(0).map((_, i) => (
            <Card key={i}>
              <Skeleton className="h-40 w-full" />
              <CardContent className="p-4">
                <Skeleton className="h-5 w-3/4 mb-2" />
                <Skeleton className="h-4 w-1/2 mb-2" />
                <Skeleton className="h-6 w-1/3" />
              </CardContent>
            </Card>
          ))}
        </div>
      );


      // Form skeleton

      export const FormSkeleton = ({ fields = 5 }: { fields?: number }) => (
        <div className="space-y-4">
          {Array(fields).fill(0).map((_, i) => (
            <div key={i} className="space-y-2">
              <Skeleton className="h-4 w-24" />
              <Skeleton className="h-10 w-full" />
            </div>
          ))}
          <Skeleton className="h-10 w-32 mt-4" />
        </div>
      );


      // Dashboard skeleton

      export const DashboardSkeleton = () => (
        <div className="space-y-6">
          <StatsGridSkeleton count={4} />
          <div className="grid grid-cols-2 gap-6">
            <Card>
              <CardHeader>
                <Skeleton className="h-6 w-32" />
              </CardHeader>
              <CardContent>
                <Skeleton className="h-64 w-full" />
              </CardContent>
            </Card>
            <Card>
              <CardHeader>
                <Skeleton className="h-6 w-32" />
              </CardHeader>
              <CardContent>
                <Skeleton className="h-64 w-full" />
              </CardContent>
            </Card>
          </div>
        </div>
      );


      // List skeleton

      export const ListSkeleton = ({ items = 5 }: { items?: number }) => (
        <div className="space-y-4">
          {Array(items).fill(0).map((_, i) => (
            <div key={i} className="flex items-center gap-4 p-4 border rounded">
              <Skeleton className="h-12 w-12 rounded-full" />
              <div className="flex-1 space-y-2">
                <Skeleton className="h-4 w-1/3" />
                <Skeleton className="h-3 w-1/2" />
              </div>
              <Skeleton className="h-8 w-20" />
            </div>
          ))}
        </div>
      );

      ```


      ## Update Pages to Use Skeletons


      Example for Orders page:

      ```typescript

      const OrdersPage = () => {
        const { data: orders, isLoading, error } = useQuery({...});
        
        if (isLoading) {
          return (
            <div className="p-6 space-y-6">
              <div className="flex justify-between">
                <Skeleton className="h-10 w-48" />
                <Skeleton className="h-10 w-32" />
              </div>
              <TableSkeleton rows={10} columns={6} />
            </div>
          );
        }
        
        if (error) {
          return <ErrorState error={error} onRetry={() => refetch()} />;
        }
        
        return <OrdersTable orders={orders} />;
      };

      ```
    acceptance_criteria:
      - Skeleton components created for all common patterns
      - All data-fetching pages show skeletons while loading
      - Skeletons match the layout of actual content
      - No layout shift when data loads
      - Error states handled gracefully
  - id: mobile-responsiveness-audit
    title: Mobile Responsiveness Audit and Fixes
    priority: P2
    estimated_minutes: 45
    description: >
      ## Overview

      Audit all admin pages for mobile responsiveness and fix any issues.

      Cannabis dispensaries often use tablets and phones for POS and inventory.


      ## Pages to Audit and Fix


      ### 1. Cash Register (Critical - often used on tablets)


      Current issues to check:

      - Product grid too wide on mobile

      - Cart doesn't collapse properly

      - Payment modal too large

      - Keyboard shortcuts conflict with mobile


      Fixes:

      ```typescript

      // Mobile-first grid for products

      <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4
      lg:grid-cols-5 gap-2 sm:gap-4">
        {products.map(product => <ProductCard key={product.id} product={product} />)}
      </div>


      // Collapsible cart on mobile

      const [cartExpanded, setCartExpanded] = useState(false);


      <div className="lg:hidden">
        <Button onClick={() => setCartExpanded(!cartExpanded)}>
          Cart ({cart.length}) - ${total}
        </Button>
      </div>


      <div className={cn(
        "lg:block",
        cartExpanded ? "block" : "hidden"
      )}>
        <CartSidebar />
      </div>

      ```


      ### 2. Dashboard

      - Stats cards should stack on mobile (1 column)

      - Charts need responsive width

      - Tables need horizontal scroll


      ```typescript

      <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4">
        {stats.map(stat => <StatCard key={stat.id} {...stat} />)}
      </div>


      // Responsive chart container

      <div className="w-full overflow-x-auto">
        <div className="min-w-[400px]">
          <Chart data={data} />
        </div>
      </div>

      ```


      ### 3. Tables (Orders, Products, Customers, etc.)


      Pattern for responsive tables:

      ```typescript

      // Option 1: Horizontal scroll

      <div className="overflow-x-auto">
        <Table className="min-w-[800px]">
          ...
        </Table>
      </div>


      // Option 2: Card view on mobile

      <div className="hidden md:block">
        <Table>...</Table>
      </div>


      <div className="md:hidden space-y-4">
        {items.map(item => (
          <Card key={item.id}>
            <CardContent className="p-4">
              <div className="flex justify-between">
                <span className="font-medium">{item.name}</span>
                <Badge>{item.status}</Badge>
              </div>
              <div className="text-sm text-muted-foreground mt-2">
                {item.email}
              </div>
              <div className="flex justify-between items-center mt-4">
                <span className="font-bold">${item.total}</span>
                <Button size="sm">View</Button>
              </div>
            </CardContent>
          </Card>
        ))}
      </div>

      ```


      ### 4. Forms

      - Full width inputs on mobile

      - Stack labels on top

      - Adequate touch targets (min 44px)


      ```typescript

      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        <div className="space-y-2">
          <Label>First Name</Label>
          <Input className="h-12 md:h-10" />
        </div>
        <div className="space-y-2">
          <Label>Last Name</Label>
          <Input className="h-12 md:h-10" />
        </div>
      </div>

      ```


      ### 5. Navigation

      - Hamburger menu on mobile

      - Bottom navigation for key actions

      - Collapsible sidebar


      ### 6. Modals and Dialogs

      - Full screen on mobile

      - Proper scroll behavior

      - Touch-friendly close button


      ```typescript

      <Dialog>
        <DialogContent className="max-h-[90vh] overflow-y-auto sm:max-w-lg">
          ...
        </DialogContent>
      </Dialog>

      ```
    acceptance_criteria:
      - All pages usable on 320px width
      - All pages usable on tablet (768px)
      - Touch targets minimum 44px
      - No horizontal scroll except for tables
      - Forms submit correctly on mobile
      - Modals don't overflow screen
  - id: add-comprehensive-logging
    title: Add Comprehensive Logging System
    priority: P2
    estimated_minutes: 25
    description: >
      ## Overview

      Replace console.log statements with a proper logging system that:

      - Works in development and production

      - Can be configured by log level

      - Sends errors to monitoring service

      - Includes context (user, tenant, etc.)


      ## File to Create

      src/lib/logger.ts


      ```typescript

      type LogLevel = 'debug' | 'info' | 'warn' | 'error';


      interface LogContext {
        userId?: string;
        tenantId?: string;
        component?: string;
        action?: string;
        [key: string]: any;
      }


      const LOG_LEVELS: Record<LogLevel, number> = {
        debug: 0,
        info: 1,
        warn: 2,
        error: 3,
      };


      const CURRENT_LEVEL = import.meta.env.PROD ? 'info' : 'debug';


      const shouldLog = (level: LogLevel): boolean => {
        return LOG_LEVELS[level] >= LOG_LEVELS[CURRENT_LEVEL];
      };


      const formatMessage = (level: LogLevel, message: string, context?:
      LogContext): string => {
        const timestamp = new Date().toISOString();
        const contextStr = context ? ` ${JSON.stringify(context)}` : '';
        return `[${timestamp}] [${level.toUpperCase()}] ${message}${contextStr}`;
      };


      const sendToMonitoring = async (level: LogLevel, message: string,
      context?: LogContext) => {
        // In production, send to monitoring service (e.g., Sentry, LogRocket)
        if (import.meta.env.PROD && level === 'error') {
          try {
            // Example: Send to your logging endpoint
            await fetch('/api/logs', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ level, message, context, timestamp: new Date().toISOString() }),
            });
          } catch (e) {
            // Silently fail - don't break the app because of logging
          }
        }
      };


      export const logger = {
        debug: (message: string, context?: LogContext) => {
          if (shouldLog('debug')) {
            console.debug(formatMessage('debug', message, context));
          }
        },
        
        info: (message: string, context?: LogContext) => {
          if (shouldLog('info')) {
            console.info(formatMessage('info', message, context));
          }
        },
        
        warn: (message: string, context?: LogContext) => {
          if (shouldLog('warn')) {
            console.warn(formatMessage('warn', message, context));
          }
          sendToMonitoring('warn', message, context);
        },
        
        error: (message: string, context?: LogContext) => {
          if (shouldLog('error')) {
            console.error(formatMessage('error', message, context));
          }
          sendToMonitoring('error', message, context);
        },
        
        // Log with automatic context from hooks
        withContext: (baseContext: LogContext) => ({
          debug: (message: string, context?: LogContext) => 
            logger.debug(message, { ...baseContext, ...context }),
          info: (message: string, context?: LogContext) => 
            logger.info(message, { ...baseContext, ...context }),
          warn: (message: string, context?: LogContext) => 
            logger.warn(message, { ...baseContext, ...context }),
          error: (message: string, context?: LogContext) => 
            logger.error(message, { ...baseContext, ...context }),
        }),
      };


      // React hook for component-scoped logging

      export const useLogger = (component: string) => {
        const { user } = useAuth();
        const { tenant } = useTenant();
        
        return useMemo(() => logger.withContext({
          component,
          userId: user?.id,
          tenantId: tenant?.id,
        }), [component, user?.id, tenant?.id]);
      };

      ```


      ## Usage Examples


      ```typescript

      // In a component

      const log = useLogger('CashRegister');


      const handleCheckout = async () => {
        log.info('Starting checkout', { cartItems: cart.length, total });
        
        try {
          const result = await processTransaction();
          log.info('Checkout complete', { transactionId: result.id });
        } catch (error) {
          log.error('Checkout failed', { error: error.message, cart });
        }
      };


      // Direct usage

      import { logger } from '@/lib/logger';


      logger.debug('Component mounted');

      logger.info('User action', { action: 'click', target: 'button' });

      logger.warn('Deprecated function called');

      logger.error('API call failed', { endpoint: '/api/users', status: 500 });

      ```


      ## Replace Existing console.log


      Search for and replace all console.log, console.error, console.warn:


      ```bash

      grep -r "console\." src/ --include="*.tsx" --include="*.ts"

      ```


      Replace with appropriate logger calls.
    acceptance_criteria:
      - Logger module created
      - All console.log replaced with logger
      - Errors sent to monitoring in production
      - Debug logs hidden in production
      - Context (user, tenant) included automatically
  - id: e2e-testing-documentation
    title: End-to-End Testing and Documentation
    priority: P3
    estimated_minutes: 45
    description: |
      ## End-to-End Testing Flow

      Perform complete E2E testing of all critical paths:

      ### 1. Authentication Flow
      - [ ] Clear all browser storage
      - [ ] Navigate to login page
      - [ ] Login with alex@gmail.com
      - [ ] Verify dashboard loads
      - [ ] Verify tenant context is correct
      - [ ] Wait 15 minutes and verify token refresh
      - [ ] Logout and verify redirect to login

      ### 2. Product Management Flow
      - [ ] Navigate to Products
      - [ ] Create new product with all fields
      - [ ] Upload product image
      - [ ] Save and verify in list
      - [ ] Edit product
      - [ ] Verify changes saved
      - [ ] Test soft delete

      ### 3. POS Transaction Flow
      - [ ] Open shift with starting cash
      - [ ] Navigate to Cash Register
      - [ ] Search for products
      - [ ] Add products to cart
      - [ ] Apply discount
      - [ ] Complete cash transaction
      - [ ] Verify receipt prints
      - [ ] Verify inventory decreased
      - [ ] Close shift
      - [ ] Verify shift report accurate

      ### 4. Order Management Flow
      - [ ] Create new order
      - [ ] Update order status
      - [ ] Generate invoice from order
      - [ ] Mark invoice as paid
      - [ ] Verify financials update

      ### 5. Customer Management Flow
      - [ ] Create new customer
      - [ ] Verify data encrypted
      - [ ] Place order for customer
      - [ ] View customer 360
      - [ ] Verify order history

      ### 6. Wholesale Flow
      - [ ] Create wholesale client
      - [ ] Set credit limit
      - [ ] Create wholesale order
      - [ ] Verify credit limit enforced
      - [ ] Generate invoice
      - [ ] Record payment

      ## Create Documentation

      Create docs/VERIFICATION_RESULTS.md:

      ```markdown
      # FloraIQ Verification Results

      ## Date: [DATE]

      ## Summary
      - Total tasks executed: XX
      - Completed successfully: XX
      - Issues found: XX
      - Issues fixed: XX

      ## Security Fixes Applied
      - [x] VendorManagement TypeScript error fixed
      - [x] Auth token refresh 401 error fixed
      - [x] Atomic POS transaction RPC created
      - [x] RLS policies fixed for all tables
      - [x] SECURITY DEFINER functions secured

      ## Features Verified

      ### Authentication
      - [x] Login works
      - [x] Token refresh works
      - [x] Logout works
      - [x] Session persistence works

      ### Cash Register / POS
      - [x] Product search
      - [x] Add to cart
      - [x] Quantity adjustment
      - [x] Payment processing
      - [x] Receipt generation
      - [x] Shift management

      ### Orders
      - [x] List view
      - [x] Status updates
      - [x] Bulk operations
      - [x] Order details

      ### Invoices
      - [x] Create invoice
      - [x] PDF generation
      - [x] Email delivery
      - [x] Payment tracking

      ### Products
      - [x] CRUD operations
      - [x] Image upload
      - [x] Stock management
      - [x] Cannabis compliance fields

      ### Inventory
      - [x] Stock levels accurate
      - [x] Value calculation fixed
      - [x] Movement tracking
      - [x] Low stock alerts

      ### Customers
      - [x] CRUD operations
      - [x] Data encryption
      - [x] Order history
      - [x] 360 view

      ### Wholesale
      - [x] Client management
      - [x] Credit limits
      - [x] Order pipeline
      - [x] Invoicing

      ## Performance Notes
      - Page load times: < 2s average
      - Database queries optimized with indexes
      - Bundle size: XX KB gzipped

      ## Remaining Issues
      1. [Issue description if any]

      ## Recommendations
      1. Consider adding automated E2E tests
      2. Set up error monitoring (Sentry)
      3. Add performance monitoring
      4. Regular security audits
      ```
    acceptance_criteria:
      - All E2E test flows pass
      - No console errors
      - Performance acceptable
      - Documentation complete
      - All issues logged
metadata:
  project: FloraIQ
  type: comprehensive-verification-enhancement
  target_environment: production
  supabase_project_ref: mtvwmyerntkhrcdnhahp
  total_tasks: 25
  estimated_duration_hours: 8
  priority_breakdown:
    P0_critical:
      count: 4
      estimated_minutes: 155
      description: Build errors, auth fixes, security
    P1_high:
      count: 7
      estimated_minutes: 285
      description: Core feature verification and enhancement
    P2_medium:
      count: 8
      estimated_minutes: 275
      description: Performance, UX, edge functions
    P3_low:
      count: 1
      estimated_minutes: 45
      description: Testing and documentation
  files_to_create:
    - supabase/migrations/[timestamp]_create_pos_transaction_atomic.sql
    - supabase/migrations/[timestamp]_fix_all_rls_policies.sql
    - supabase/migrations/[timestamp]_add_performance_indexes.sql
    - src/components/common/ErrorBoundary.tsx
    - src/components/common/Skeletons.tsx
    - src/lib/logger.ts
    - docs/VERIFICATION_RESULTS.md
  files_to_modify:
    - src/pages/admin/VendorManagement.tsx
    - src/pages/saas/LoginPage.tsx
    - src/contexts/TenantAdminAuthContext.tsx
    - supabase/functions/tenant-admin-auth/index.ts
    - src/pages/admin/CashRegister.tsx
    - src/pages/admin/Orders.tsx
    - src/pages/admin/InvoicesPage.tsx
    - src/pages/admin/ProductManagement.tsx
    - src/pages/admin/InventoryManagement.tsx
    - src/pages/admin/CustomerManagement.tsx
    - src/pages/admin/WholesaleClients.tsx
    - src/pages/admin/WholesaleOrdersPage.tsx
    - src/pages/admin/NewWholesaleOrder.tsx
