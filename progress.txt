## Task: Enhance Disposable Menu Generation with Advanced Options
## Status: COMPLETED
## Date: 2026-01-23

### What was done:

1. **Enhanced MenuCreationWizard with 5-step flow** (was 4 steps)
   - Added new "Advanced" step (Step 4) between Products and Settings
   - Restructured step navigation to dynamically skip steps for forum menus
   - Improved progress bar to accurately track visible steps

2. **Custom Pricing (Advanced > Pricing tab)**
   - Bulk discount: Apply a percentage discount to all products
   - Per-product custom pricing: Override individual product prices
   - Effective price calculation showing base price, discount, or custom override
   - Visual indicators for discounted vs custom-priced items
   - Custom prices are passed through to the create-encrypted-menu edge function

3. **Geofencing (Advanced > Location tab)**
   - Toggle to enable geographic access restrictions
   - Latitude/longitude inputs with validation (-90/90, -180/180)
   - Radius input in miles (0.1-100 range)
   - Template integration: Pop-Up Event template auto-enables geofencing
   - Geofence config passed to security_settings on menu creation

4. **Whitelist (Advanced > Whitelist tab)**
   - Toggle to enable email/phone whitelist access control
   - Email input with validation and Enter key support
   - Phone input with validation (10+ digit format)
   - Chip/badge display for added entries with remove buttons
   - Duplicate detection prevents re-adding same email/phone
   - Whitelist data passed to security_settings on creation

5. **Branding (Advanced > Branding tab)**
   - Show/hide business branding toggle
   - Header image URL with recommended dimensions
   - Custom welcome message (500 char limit with counter)
   - Live preview panel showing header, branding, and message together
   - Branding config passed as appearance_settings on creation

6. **Form Validation**
   - Validates custom prices (non-negative numbers)
   - Validates discount percentage (1-100%)
   - Validates geofence coordinates (lat/lng ranges, positive radius)
   - Validates whitelist entries (email format, phone format)
   - Password validation when password protection enabled
   - All validations run before advancing past the Advanced step

7. **QR Code Generation**
   - Already integrated via existing QRCodeDialog component
   - Accessible from MenuCard after menu creation
   - Uses qrcode.react for SVG rendering + qrcode lib for data URL generation
   - Supports download, print, and share functionality

8. **Additional Fix: Created missing sanitize.ts module**
   - Required by ProductDetailPage.tsx for build to succeed
   - Implements sanitizeHtml, stripHtml, and sanitizeInput functions
   - Uses DOM-based allowlist approach for safe tag/attribute filtering

### Files modified:
- `src/components/admin/disposable-menus/MenuCreationWizard.tsx` - Major rewrite with advanced options
- `src/lib/utils/sanitize.ts` - New file (was missing, blocking build)

### Build verification:
- TypeScript strict mode passes with no errors
- Production build completes successfully
---

## Task: Create AccountDangerZone Component

### What was done:

1. **Created `src/components/auth/AccountDangerZone.tsx`** - A reusable danger zone component for account settings that provides:
   - A clearly styled "Danger Zone" section with destructive border styling
   - "Delete Account" button that triggers a multi-step confirmation dialog
   - **Step 1 - Password Verification**: User must enter their current password, verified via `supabase.auth.signInWithPassword`
   - **Step 2 - Type DELETE Confirmation**: User must type "DELETE" to confirm the action
   - A list of what data will be affected/deleted (customizable via props)
   - Calls the `delete-customer-account` edge function with proper payload
   - Handles edge function errors (both throw errors and response body errors)
   - Inline error display within the dialog + toast notifications on failure
   - Loading/disabled states on buttons during async operations
   - Haptic feedback for destructive actions, success, and errors
   - Keyboard support (Enter key) for both steps
   - State cleanup on dialog close
   - Proper logging via `logger` utility
   - Follows all FloraIQ code conventions (named export, `@/` imports, no `any` types, no console.log)

### Props Interface:
- `userId` - ID of the user whose account will be deleted
- `tenantId` - Tenant ID for multi-tenant context
- `userEmail` - Displayed in the warning message
- `onAccountDeleted` - Callback after successful deletion (for navigation/logout)
- `affectedData` - Optional custom list of items that will be affected

### Files Changed:
- `src/components/auth/AccountDangerZone.tsx` (new file)

---

## Task: Create src/pages/credits/CreditsPage.tsx Protected Credits Overview Page

### What was done:

1. **Created `src/pages/credits/CreditsPage.tsx`** - Protected page with full credits overview:
   - Uses `useTenantAdminAuth()` for tenant context and route protection
   - Uses `useCredits()` hook for balance, lifetime stats, and status flags
   - Fetches recent transactions via `getCreditTransactions` from `@/lib/credits`

2. **Current Balance Card** (prominent, spans 2 columns on md+):
   - Large 5xl font balance number with color-coded text (green/yellow/amber/orange/red based on threshold)
   - Color-coded background/border matching balance health
   - Coins icon with "Current Balance" label

3. **Quick Stats Cards** (lifetime purchased and lifetime used):
   - "Lifetime Purchased" card with TrendingUp icon showing total credits acquired
   - "Lifetime Used" card with TrendingDown icon, progress bar showing percentage used
   - Both with descriptive sub-text

4. **Subscription Status Card**:
   - Shows current plan name and status badges
   - Free tier messaging with upgrade encouragement
   - "Manage subscription" link to billing settings page

5. **Buy More Credits CTA Card**:
   - Gradient background with primary color hints
   - Descriptive text encouraging purchase/upgrade
   - "Buy Credits" button navigating to credits analytics page

6. **Recent Transactions Preview** (full-width, last 5):
   - Each transaction shows: type icon (color-coded), description, relative time, amount (green +/red -), balance after
   - "View all" link navigating to credits analytics
   - Empty state with helpful messaging when no transactions exist

7. **Responsive Grid Layout**:
   - Mobile: single column stack
   - Tablet (md): 2-column grid, balance spans full width
   - Desktop (lg): 4-column grid for compact stat display

8. **Loading States**:
   - Skeleton placeholders for all sections during data fetch
   - Graceful handling of missing tenant context

### Acceptance Criteria Met:
- [x] Current balance displayed prominently with color-coding
- [x] Quick stats showing lifetime purchased and used
- [x] Recent transactions preview with view all link
- [x] Buy more credits CTA button
- [x] Subscription status card with plan info
- [x] Responsive grid layout (1/2/4 columns)
- [x] Protected page using `useTenantAdminAuth()`
- [x] TypeScript strict mode, no `any` types
- [x] Named export only
- [x] Uses `@/` import alias throughout
- [x] Uses `logger` for error logging
- [x] Build passes with zero TypeScript errors

### Files Created:
- `src/pages/credits/CreditsPage.tsx`

---

## Task: Create BuyCreditsPage.tsx

### What was done:
Created a protected BuyCreditsPage at `src/pages/credits/BuyCreditsPage.tsx` that displays credit packages in a card grid with full purchase flow.

### Features implemented:
- **Protected page**: Uses `useTenantAdminAuth()` for tenant context and access guard
- **Credit packages grid**: Responsive card layout (1 col mobile, 2 tablet, 4 desktop)
- **Package cards display**: Credits amount, bonus credits, price, savings percentage, description
- **Featured badge**: Packages with `BEST VALUE` or `POPULAR` badges show a featured indicator with Sparkles icon
- **Package selection**: Click to select, highlighted with ring/border styling and checkmark indicator
- **Promo code input**: Text input with Apply button, validates against promo code service
- **Promo code feedback**: Shows success with bonus credits amount, or error message
- **Checkout button**: Proceeds to Stripe payment via `purchase-credits` edge function
- **Loading states**: Skeleton placeholders while packages load
- **Error states**: Error card if packages fail to load
- **Current balance display**: Shows current credit balance in header

### New files created:
- `src/hooks/useCreditPackages.ts` - Hook that fetches credit packages from DB (with static fallback), calculates savings percentages, and maps to display format
- `src/pages/credits/BuyCreditsPage.tsx` - Full page component with card grid, promo code, and checkout flow

### Verification:
- [x] `npm run build` - PASSES (0 TypeScript errors)
- [x] `npm run lint` - PASSES (0 errors on new files)

---

## Task: Create Credits Checkout Page

### What was done:
Created `src/pages/credits/CheckoutPage.tsx` - a protected page for purchasing credit packages with:

1. **Package Summary**: Displays selected credit package (name, credits, price, per-credit cost) from route state
2. **Promo Code Support**: Input to apply promotional codes with validation via `validatePromoCode()`, shows applied discount/bonus credits with remove option
3. **Total Price Calculation**: Shows subtotal, promo discount line (if applied), bonus credits, and final total
4. **Stripe Payment Integration**: Uses existing `purchase-credits` edge function to create Stripe Checkout session, redirects user to Stripe's secure hosted checkout for card input
5. **Billing Address**: Optional toggleable billing address form (name, address lines, city, state, postal code, country)
6. **Pay Now Button**: Shows total amount, disabled during processing, with loading spinner animation
7. **Loading State**: Full mutation loading state with disabled UI during payment processing
8. **Success Redirect**: On successful Stripe session creation, redirects to Stripe Checkout which then redirects to credits/success page
9. **Error Handling**: Toast notifications for payment failures, promo code errors
10. **Auth Protection**: Uses `useTenantAdminAuth()` for tenant context, skeleton loading when no tenant

### Route Registration:
- Added lazy import in `App.tsx`: `const CreditsCheckoutPage = lazy(() => import("./pages/credits/CheckoutPage"))`
- Added route: `<Route path="credits/checkout" element={<CreditsCheckoutPage />} />`
- Accessible at: `/:tenantSlug/admin/credits/checkout`

### Files Changed:
- `src/pages/credits/CheckoutPage.tsx` (new file - 350+ lines)
- `src/App.tsx` (added lazy import + route registration)

### Verification:
- [x] `npm run build` - PASSES (0 TypeScript errors)
- [x] `npx eslint src/pages/credits/CheckoutPage.tsx` - PASSES (0 errors, 0 warnings)
- [x] Named export used (`export function CheckoutPage`)
- [x] Default export for lazy loading compatibility
- [x] Uses `@/` import alias throughout
- [x] Uses `logger` from `@/lib/logger` (no console.log)
- [x] Uses `formatCurrency` from `@/lib/utils/formatCurrency`
- [x] Uses `useTenantAdminAuth` for auth protection
- [x] Buttons have disabled state during async ops
- [x] Error handling with toast.error() for user feedback

---

## Task: Create src/pages/credits/PurchaseSuccessPage.tsx

### What was done:

1. **Created `src/pages/credits/PurchaseSuccessPage.tsx`** - User-facing purchase success page with:
   - **Confetti animation** using `canvas-confetti` (3-second celebratory burst on mount)
   - **Credits added display** - Shows the purchased amount plus any bonus credits, read from URL search params (`credits_added`, `bonus_credits`)
   - **New total balance** - Fetches and displays the current credit balance via `useCredits` hook with auto-refresh on mount
   - **Transaction ID** - Displays truncated transaction ID from search params with copy-to-clipboard functionality
   - **Continue to Dashboard button** - Primary CTA navigating to the admin dashboard
   - **View Transaction History button** - Secondary action to view billing history
   - **Credit suggestions section** - Three actionable suggestions (Place Orders, Unlock Premium Features, Boost Your Business) to guide users on how to use their credits
   - Named export (per project code style), uses `@/` import aliases, `logger` instead of console.log
   - Responsive design with dark mode support via shadcn/ui components
   - Invalidates credit query cache on mount to ensure fresh balance data

### Key Design Decisions:
- Reads purchase data from URL search params (`credits_added`, `bonus_credits`, `transaction_id`/`session_id`) to support both direct navigation and Stripe redirect flows
- Uses existing `useCredits` hook for balance fetching (tenant-aware)
- Uses `useTenantNavigation` for dashboard navigation (tenant-aware routing)
- Follows the same confetti pattern as `OrderConfirmationPage`
- Distinct from `CreditPurchaseSuccessPage` in tenant-admin (that one is simpler, this one adds suggestions and richer credits display)

### Files Created:
- `src/pages/credits/PurchaseSuccessPage.tsx`

---

## Task: Create src/pages/credits/TransactionHistoryPage.tsx

### What was done:

1. **Created `src/hooks/useCreditTransactions.ts`** - Custom hook that:
   - Wraps `credit_transactions` table queries with TanStack Query
   - Supports paginated loading via "load more" pattern (accumulative pages)
   - Filters by transaction type (all, purchase, usage, refund)
   - Supports date range filtering (from/to with end-of-day handling)
   - Fetches total count for showing remaining items
   - Scoped to current tenant via `useTenantAdminAuth()`
   - 30-second staleTime for optimal caching
   - Exports `TransactionTypeFilter` and `UseCreditTransactionsReturn` types

2. **Created `src/pages/credits/TransactionHistoryPage.tsx`** - Protected page with:
   - Header with back navigation and refresh button
   - **Filter tabs**: All, Purchases, Usage, Refunds (using shadcn Tabs)
   - **Date range picker**: From/To calendar popovers with mutual constraints
   - **Paginated transaction table** with columns: Date, Type, Amount, Balance, Description
   - **Expandable rows**: Click chevron to reveal action type, reference ID/type, full datetime, metadata
   - **Load More button**: Shows remaining count, loading spinner while fetching
   - **Loading skeletons**: 10 skeleton rows during initial load
   - **Empty state**: Icon + contextual message based on active filter
   - Color-coded type badges (red=usage, green=purchase, cyan=refund, etc.)
   - Signed amount display (green positive, red negative)
   - Responsive layout with mobile-friendly table overflow
   - Dark mode support for all badge colors

3. **Added route in `src/App.tsx`**:
   - Lazy import: `const TransactionHistoryPage = lazy(() => import("./pages/credits/TransactionHistoryPage").then(m => ({ default: m.TransactionHistoryPage })))`
   - Route: `<Route path="credits/transactions" element={<TransactionHistoryPage />} />`
   - Available at `/:tenantSlug/admin/credits/transactions`

### Verification:
- [x] TypeScript compilation passes (`npx tsc --noEmit`)
- [x] ESLint passes on new files
- [x] Production build succeeds (`npm run build`)
- [x] Named exports only (no default exports)
- [x] Uses `@/` import alias throughout
- [x] Uses `logger` from `@/lib/logger` (no console.log)
- [x] Tenant-aware via `useTenantAdminAuth()`
- [x] Filters by `tenant_id` in all queries

### Files Changed:
- `src/hooks/useCreditTransactions.ts` (new - paginated transaction hook)
- `src/pages/credits/TransactionHistoryPage.tsx` (new - transaction history page)
- `src/App.tsx` (lazy import + route registration)

---

## Task: Create CreditBalanceCard Component

### What was done:

1. **Created `src/components/credits/CreditBalanceCard.tsx`** - A card component that displays:
   - Large balance number (3xl font, tabular-nums) with "credits remaining" label
   - Optional mini sparkline chart showing balance over time (last 14 days default)
   - Low balance warning banner when credits are below `LOW_CREDIT_WARNING_THRESHOLD` (2000) or `CRITICAL_CREDIT_THRESHOLD` (100)
   - "Buy More Credits" button that opens the purchase modal
   - Only renders for free-tier users (returns null for paid tier)

2. **Updated `src/components/credits/index.ts`** - Added exports:
   - `CreditBalanceCard` component
   - `CreditBalanceCardProps` type

### Component Features:

- **Balance Display**: Large prominent number with color coding (red for critical, amber for low, default for healthy)
- **Sparkline Chart**: Uses recharts `AreaChart` with gradient fill, shows daily balance snapshots by reconstructing from transaction history
- **Warning States**: Inline alert banner with appropriate severity (critical vs low)
- **Buy Button**: Full-width button, switches to destructive variant when credits critically low
- **Props**: `className`, `showChart` (default: true), `chartDays` (default: 14)

### Patterns Used:
- `useCredits` from CreditContext for balance and modal control
- `useTenantAdminAuth` for tenant-aware queries
- TanStack Query for balance history data fetching
- Recharts AreaChart with linear gradient (same pattern as MetricCard)
- shadcn/ui Card components
- `LOW_CREDIT_WARNING_THRESHOLD` and `CRITICAL_CREDIT_THRESHOLD` from `@/lib/credits`

### Acceptance Criteria Met:
- [x] Shows current balance as large number with credits label
- [x] Mini chart of balance over time (optional, configurable)
- [x] Low balance warning if below threshold
- [x] Buy more button opens purchase modal
- [x] Suitable for use on dashboard and credits page
- [x] TypeScript strict mode, no `any` types
- [x] Named exports only
- [x] Uses `@/` import aliases
- [x] Tenant-aware query filtering

### Files Changed:
- `src/components/credits/CreditBalanceCard.tsx` (new)
- `src/components/credits/index.ts` (added exports)

## Task: Create CreditPackageCard.tsx Component

### What was done:

1. **Created `src/components/credits/CreditPackageCard.tsx`** - Standalone card component for displaying a single credit package with:
   - **Credit amount display** with bonus credits highlighted in emerald green ("+X bonus")
   - **Price display** with calculated per-credit cost shown below
   - **Savings badge** showing percentage savings relative to a base price (for bulk discount packages)
   - **Featured badges** - "POPULAR" (with TrendingUp icon) or "BEST VALUE" (with Sparkles icon, emerald styling)
   - **Select button** with loading state (spinner + "Processing..."), disabled state, and contextual label
   - **Quantity selector** (optional) with +/- buttons, min/max bounds, and updated total price in button text
   - **Disabled state** with reduced opacity, pointer-events-none, and customizable reason text shown in button and title tooltip
   - Uses existing `getPricePerCredit` from `@/lib/credits/creditCosts`
   - Uses shadcn/ui Card, Badge, Button components
   - Uses lucide-react icons (Coins, Loader2, Minus, Plus, Sparkles, TrendingUp)
   - Named export only, TypeScript strict (no `any` types)
   - Fully typed props interface exported as `CreditPackageCardProps`

2. **Updated `src/components/credits/index.ts`** - Added export for `CreditPackageCard` and `CreditPackageCardProps`

### Props Interface:
- `id`, `name`, `credits`, `priceCents` - core package data
- `bonusCredits` - optional bonus credits highlighted separately
- `badge` - badge text (e.g., "POPULAR", "BEST VALUE")
- `description` - package description text
- `isFeatured` - applies highlighted border/ring styling
- `onSelect(id, quantity)` - callback when package is selected
- `isLoading` - shows loading spinner in button
- `isDisabled` / `disabledReason` - disabled state with explanation
- `showQuantitySelector` - enables +/- quantity controls
- `maxQuantity` / `minQuantity` - bounds for quantity selector
- `basePricePerCredit` - reference price for savings % calculation

### Verification Results:
- [x] TypeScript compiles with zero errors (`npx tsc --noEmit --skipLibCheck`)
- [x] ESLint passes with zero errors/warnings on the new file
- [x] Named export only (no default export)
- [x] No `console.log` usage
- [x] No `any` types
- [x] Uses `@/` import alias throughout

### Files Changed:
- `src/components/credits/CreditPackageCard.tsx` (new)
- `src/components/credits/index.ts` (added export)

---

## Task: Create PromoCodeInput.tsx with Input, Apply Button, Validation States, and Parent State Storage

### What was done:

1. **Rewrote `src/components/credits/PromoCodeInput.tsx`** - Complete checkout-ready promo code input component:
   - **Text input with apply button**: Monospace uppercase input with Tag icon, "Apply" button with disabled state when code is too short
   - **Loading during validation**: Shows `Loader2` spinner in the Apply button while `validatePromoCode` mutation is pending
   - **Success with discount preview**: When valid, renders a green success banner showing the applied code and "+X bonus credits" discount preview
   - **Error message**: Shows red error text with `XCircle` icon below the input when validation fails
   - **Clears on invalid**: Input text is cleared when validation returns an error or network failure
   - **Stores valid code in parent state**: Exposes `onCodeApplied(validatedCode)` callback that passes `ValidatedPromoCode` (code, creditsAmount, description) to parent for checkout use
   - **Handles already applied state**: When `appliedCode` prop is provided, renders the success preview with an "X" button to remove; hides remove button when `disabled`
   - Keyboard support: Enter key triggers apply when code length >= 3
   - Accessibility: `aria-label`, `aria-invalid`, `aria-describedby`, `role="alert"` on error
   - Dark mode support via Tailwind dark: variants

2. **Exported `ValidatedPromoCode` type** from `src/components/credits/index.ts`:
   - Added `ValidatedPromoCode` to the type export alongside `PromoCodeInputProps`

### Key Design Decisions:
- **Removed coupling to tenant/credits context**: The old implementation tied itself to `useTenantAdminAuth` and `useCredits` (checking `isFreeTier`). The new version is a pure checkout-focused input that receives its state via props, making it reusable in any context.
- **Parent-controlled state pattern**: Uses `onCodeApplied` + `appliedCode` props instead of internal-only state, enabling the parent checkout component to track the validated code.
- **Removed redeem logic**: The old version had both validate+redeem. The new version only validates and passes the code to the parent. Redemption happens at checkout time.

### Props Interface:
```typescript
interface PromoCodeInputProps {
  onCodeApplied: (promoCode: ValidatedPromoCode | null) => void;
  appliedCode?: ValidatedPromoCode | null;
  className?: string;
  disabled?: boolean;
}

interface ValidatedPromoCode {
  code: string;
  creditsAmount: number;
  description?: string;
}
```

### Files Changed:
- `src/components/credits/PromoCodeInput.tsx` (complete rewrite)
- `src/components/credits/index.ts` (added ValidatedPromoCode type export)

---

## Task: Create SubscriptionStatusCard.tsx Component

### What was done:

1. **Created `src/components/credits/SubscriptionStatusCard.tsx`** - Component that displays:
   - Active subscription details fetched from `credit_subscriptions` table
   - Credits per period and period type (monthly/yearly/weekly)
   - Credits remaining this period with color-coded progress bar
   - Next renewal date for active subscriptions
   - Manage Subscription button linking to `/${tenantSlug}/admin/billing`
   - Paused state: yellow banner explaining credits won't renew until resumed
   - Cancelled state: red banner showing cancellation date with note about remaining credits
   - Past Due state: red banner prompting payment method update
   - Cancelling (cancel_at_period_end) state: orange banner with end date
   - Loading skeleton UI while data loads
   - Returns null when no subscription exists

2. **Updated `src/components/credits/index.ts`** - Added exports:
   - `SubscriptionStatusCard` component export
   - `SubscriptionStatusCardProps` type export

### Key Implementation Details:
- Uses `useQuery` with `['credit-subscription', tenantId]` query key
- Fetches from `credit_subscriptions` table filtered by `tenant_id`, ordered by most recent
- Uses `.maybeSingle()` per project convention for optional data
- Progress bar shows `credits_remaining_this_period / credits_per_period` ratio
- Status badge color-coded: green (active/trialing), yellow (paused), red (cancelled/past_due), orange (cancelling)
- Navigate button uses tenant-aware routing `/${tenantSlug}/admin/billing`
- Inactive subscriptions (paused/cancelled) show "Reactivate Subscription" CTA
- TypeScript strict mode, named exports, `@/` imports throughout

### Verification Results:
- [x] `npx tsc --noEmit --skipLibCheck` - PASSES (0 TypeScript errors)

### Files Changed:
- `src/components/credits/SubscriptionStatusCard.tsx` (new component)
- `src/components/credits/index.ts` (added exports)

---

## Task: Create InsufficientCreditsModal Component

### What was done:

1. **Created `src/components/credits/InsufficientCreditsModal.tsx`** - Modal component that:
   - Shows when an action requires more credits than currently available
   - Displays required amount, current balance, and shortfall in a 3-column grid
   - Calculates and shows the smallest credit packages that cover the shortfall
   - Provides quick purchase buttons for each suggested package
   - Includes a primary "Buy Credits" button and a "Cancel" button
   - Supports "Don't show again" checkbox that persists preference to localStorage
   - Exports `isInsufficientCreditsModalDismissed()` helper for callers to check preference
   - Exports `resetInsufficientCreditsModalDismissal()` to clear the preference

2. **Updated `src/constants/storageKeys.ts`**:
   - Added `INSUFFICIENT_CREDITS_DISMISSED` storage key for the don't-show-again preference

3. **Updated `src/components/credits/index.ts`**:
   - Exported `InsufficientCreditsModal`, `isInsufficientCreditsModalDismissed`, `resetInsufficientCreditsModalDismissal`
   - Exported `InsufficientCreditsModalProps` type

### Features:
- Required/balance/shortfall breakdown with visual emphasis on the shortfall
- Smart package suggestions: filters CREDIT_PACKAGES to find smallest packages covering shortfall
- Shows up to 3 quick purchase options with price and "covers shortfall" indicator
- "Don't show again" preference stored in localStorage via STORAGE_KEYS
- Named exports only, TypeScript strict, uses @/ imports

### Acceptance Criteria Met:
- [x] Modal shown when action requires more credits than available
- [x] Shows required amount and current balance and shortfall
- [x] Displays quick purchase options for smallest packages covering shortfall
- [x] Buy credits button present
- [x] Cancel button present
- [x] Remembers "don't show again" preference

### Files Changed:
- `src/components/credits/InsufficientCreditsModal.tsx` (new)
- `src/components/credits/index.ts` (added exports)
- `src/constants/storageKeys.ts` (added INSUFFICIENT_CREDITS_DISMISSED key)

## Task: Create CreditUsageIndicator Component

### What was done:

1. **Created `src/components/credits/CreditUsageIndicator.tsx`** - Small inline component that:
   - Displays a coin icon (`Coins` from lucide-react) with the credit cost amount
   - Shows a tooltip on hover explaining the charge (action name, description, cost breakdown, balance after)
   - Warns visually when the action would exceed the user's balance (red text + `AlertTriangle` icon)
   - Shows amber color when balance would be low after the action (< 500 credits remaining)
   - Only renders for free-tier users with non-zero costs (hides for paid users)
   - Supports both `actionKey` (from CREDIT_COSTS config) and direct `cost` prop
   - Has `size` variant (`sm`/`md`) for different placement contexts
   - Has `showWarning` prop to control warning icon display
   - Accepts custom `description` to override tooltip text
   - Uses existing `useCredits` hook and `getCreditCost`/`getCreditCostInfo` utilities
   - Follows project patterns: named exports, `@/` imports, no `any` types

2. **Updated `src/components/credits/index.ts`** - Added exports:
   - `CreditUsageIndicator` component export
   - `CreditUsageIndicatorProps` type export

### Usage Example:
```tsx
import { CreditUsageIndicator } from '@/components/credits';

// Next to a button or feature label
<button>
  Create Menu <CreditUsageIndicator actionKey="menu_create" />
</button>

// With direct cost
<span>
  Send SMS <CreditUsageIndicator cost={25} description="Sends an SMS notification" />
</span>
```

### Design Decisions:
- Kept it minimal (coin icon + number) to work inline next to feature labels
- Distinguished from `CreditCostBadge` (which uses Badge wrapper, has hoverMode/compact/inline variants)
- Distinguished from `CreditCostIndicator` (which is a larger block-level form indicator)
- Tooltip shows cost, current balance, and remaining balance after action
- Color coding: muted (affordable), amber (would be low), red (can't afford)

### Files Changed:
- `src/components/credits/CreditUsageIndicator.tsx` (new)
- `src/components/credits/index.ts` (added exports)
---

## Task: Create src/components/auth/ProtectedRoute.tsx

### What was done:

1. **Cherry-picked `useAuthGuard.ts` hook** from another branch (commit d4fc8bb3) as a dependency:
   - `src/hooks/useAuthGuard.ts` - Hook that checks authentication status, role hierarchy, and permissions
   - Updated `src/hooks/index.ts` to export `useAuthGuard`

2. **Created `src/components/auth/ProtectedRoute.tsx`** - Wrapper component that:
   - Uses `useAuthGuard` hook for authentication and authorization checking
   - Shows a centered loading spinner with "Verifying access..." text while auth state is loading
   - Redirects to login with `returnUrl` query parameter (encoding the current path) if not authenticated
   - Renders children when authenticated and authorized
   - Shows an access denied UI (or custom `accessDeniedFallback`) when authenticated but lacking required role/permissions
   - Supports `requiredRole` prop with role hierarchy (owner > admin > team_member > viewer)
   - Supports `requiredPermissions` prop for permission-based access control
   - Supports `requireAnyPermission` prop to require at least one permission instead of all
   - Supports custom `redirectTo` path for login redirect
   - Uses `hasRedirected` ref to prevent redirect loops
   - Follows existing codebase patterns (named export, `@/` imports, `logger` for debug logging)

### Verification:
- TypeScript compilation: zero errors
- ESLint: zero warnings/errors on new files

### Files Changed:
- `src/hooks/useAuthGuard.ts` (new - cherry-picked from another branch)
- `src/hooks/index.ts` (added useAuthGuard export)
- `src/components/auth/ProtectedRoute.tsx` (new)

---

## Agent 84: Create PublicOnlyRoute Component

### Task:
Create `src/components/auth/PublicOnlyRoute.tsx` - a wrapper for login/signup pages that redirects authenticated users to their dashboard and renders children for unauthenticated users.

### Implementation:
- Uses `useAuth()` from `AuthContext` to check authentication status and loading state
- Shows `LoadingFallback` during auth check (loading state)
- If user is authenticated, uses `getCurrentUserType()` and `getDashboardUrl()` from `authHelpers` to determine the correct dashboard redirect
- Falls back to `/marketing` if no user type is detected
- Uses `<Navigate replace />` for redirect (consistent with existing route guards)
- Renders children when user is not authenticated

### Design Decisions:
- Leverages existing `AuthContext` (Supabase session) rather than checking all three auth contexts individually - the `useAuth` hook provides the base authentication state
- Uses `getCurrentUserType()` from `authHelpers.ts` which already checks all auth tiers (super_admin, tenant_admin, customer, courier) via storage tokens
- Uses `getDashboardUrl()` which handles tenant-slug-aware routing for tenant admins and customers
- Named export only (per project conventions)
- No `@ts-nocheck` - strict TypeScript throughout

### Files Created:
- `src/components/auth/PublicOnlyRoute.tsx`

---

## Task: Create RoleGuard.tsx Component

### What was done:

1. **Created `src/components/auth/RoleGuard.tsx`** - Role-based access guard component that:
   - Accepts `requiredRoles` prop (array of `Role` values: owner, admin, team_member, viewer)
   - Uses `usePermissions()` hook to get the current user's role
   - Renders children if the user's role is in the `requiredRoles` array
   - Logs unauthorized access attempts via `logger.warn()` with user context (userId, tenantId, role, requiredRoles)
   - Supports `redirectTo` prop for navigation-based denial (redirects unauthorized users)
   - Supports `fallback` prop for custom access-denied UI
   - Shows a default "Access Denied" Alert (shadcn/ui) with required roles listed when no fallback/redirect is provided
   - Uses a ref to ensure unauthorized access is logged only once per mount
   - Returns `null` while permissions are loading to avoid flash of denied content

### Design Decisions:
- Follows existing `PermissionGuard.tsx` pattern but checks roles instead of granular permissions
- Uses `useTenantAdminAuth()` for logging context (userId, tenantId, tenantSlug)
- Named export only (no default export) per project conventions
- Uses `@/` import alias throughout
- Uses `logger` from `@/lib/logger` (never console.log)

### Files Changed:
- `src/components/auth/RoleGuard.tsx` (new file)

---

## Task: Create src/components/auth/PermissionGuard.tsx Component

### What was done:

Updated the existing `src/components/auth/PermissionGuard.tsx` and `src/components/admin/PermissionGuard.tsx` to match the task specification:

1. **Renamed prop** from `permission` to `required` for clarity (accepts `Permission | Permission[]`)
2. **Changed default behavior** for arrays: `requireAll` now defaults to `true` (renders children only if user has ALL specified permissions)
3. **Added loading state handling**: Returns `null` while `usePermissions` is loading to prevent flash of unauthorized content
4. **Removed unused `showMessage` prop and Alert UI**: Component now shows fallback or nothing when unauthorized (cleaner API)
5. **Removed unused imports**: `Alert`, `AlertDescription`, `AlertTriangle` no longer imported
6. **Both copies updated**: `src/components/auth/` and `src/components/admin/` are now consistent

### Component API:

```typescript
interface PermissionGuardProps {
  required: Permission | Permission[];  // Permission string or array
  children: ReactNode;                  // Content shown when authorized
  fallback?: ReactNode;                 // Optional fallback when unauthorized
  requireAll?: boolean;                 // Default: true (all permissions required)
}
```

### Usage Examples:

```tsx
// Single permission
<PermissionGuard required="orders:create">
  <CreateOrderButton />
</PermissionGuard>

// Multiple permissions (all required by default)
<PermissionGuard required={['orders:create', 'inventory:edit']}>
  <BulkOperations />
</PermissionGuard>

// Multiple permissions (any one is sufficient)
<PermissionGuard required={['orders:view', 'reports:view']} requireAll={false}>
  <DashboardWidget />
</PermissionGuard>

// With fallback
<PermissionGuard required="settings:edit" fallback={<p>Contact admin for access</p>}>
  <SettingsPanel />
</PermissionGuard>
```

### Acceptance Criteria Met:
- [x] Accepts `required` permission as string or array
- [x] Uses `usePermissions` hook for permission checking
- [x] Renders children if user has all required permissions
- [x] Shows fallback if provided when not authorized
- [x] Returns null (nothing) if no fallback and not authorized
- [x] Handles loading state gracefully (returns null while loading)
- [x] Build passes with zero errors

### Files Changed:
- `src/components/auth/PermissionGuard.tsx` (updated)
- `src/components/admin/PermissionGuard.tsx` (updated)

---

## Task: Create CreditGuard Component

### What was done:

1. **Created `src/components/credits/CreditGuard.tsx`** - A render-prop component that:
   - Accepts `requiredCredits` (number) to specify the credit cost of the guarded action
   - Accepts optional `actionKey` for integration with the existing credit cost system
   - Checks user's credit balance via `useCredits()` hook
   - Renders children via render props when user has sufficient credits
   - Shows `OutOfCreditsModal` (acting as InsufficientCreditsModal) when credits are insufficient
   - Provides `consumeCredits` function to children via render props for on-demand credit consumption
   - Non-free-tier users always pass the credit check (unlimited credits)
   - Handles race conditions by preventing double-execution of credit consumption
   - Supports optional `fallback` prop for rendering custom UI when credits are insufficient
   - Includes `onCreditsConsumed` and `onConsumptionFailed` callbacks for parent integration
   - Uses proper error logging via `logger` utility

2. **Render Props Interface (`CreditGuardRenderProps`)**:
   - `consumeCredits(referenceId?, referenceType?)` - Triggers credit consumption, returns `ConsumeCreditsResult`
   - `balance` - Current credit balance
   - `hasSufficientCredits` - Boolean indicating if user can perform the action
   - `isConsuming` - Loading state during credit consumption
   - `isFreeTier` - Whether user is on free tier

3. **Component Props (`CreditGuardProps`)**:
   - `requiredCredits` - Number of credits needed for the action
   - `actionKey` - Optional action key for cost lookup and tracking
   - `children` - Render prop function receiving `CreditGuardRenderProps`
   - `fallback` - Optional fallback UI when insufficient credits
   - `onCreditsConsumed` - Callback on successful consumption
   - `onConsumptionFailed` - Callback on failed consumption

### Design Decisions:
- Uses existing `OutOfCreditsModal` instead of creating a new `InsufficientCreditsModal` since they serve the same purpose
- Integrates with the existing `useCredits` hook and credit system rather than creating parallel logic
- Follows the codebase's named export convention
- Uses TypeScript strict mode with no `any` types
- Uses `@/` import alias consistently

### Files Changed:
- `src/components/credits/CreditGuard.tsx` (new file)

---

## Task: Create AuthLayout.tsx Layout Wrapper for Auth Pages

### What was done:

1. **Created `src/components/auth/AuthLayout.tsx`** - Reusable layout wrapper for authentication pages with:
   - **Centered card design**: Full-viewport flex layout with Card component centered vertically and horizontally
   - **Logo at top**: FloraIQLogo component (lg size) positioned above the auth card
   - **Optional background pattern**: SVG grid pattern with subtle decorative gradient blobs (primary/accent colors) - enabled by default via `showPattern` prop
   - **Optional background image**: Alternative to the pattern, accepts a URL via `backgroundImage` prop, rendered with low opacity overlay
   - **Footer with links**: Sticky footer with Terms of Service, Privacy Policy, and Support links, separated by centered dots on desktop
   - **Responsive padding**: Mobile-first with `px-4 py-8` scaling to `sm:px-6 lg:px-8`, card padding from `p-6` to `sm:p-8`
   - **Brand styling**: Uses CSS variables for colors (primary, accent, border, muted-foreground), glassmorphism backdrop-blur on card and footer, shadow-lg on card
   - **Full-viewport height**: Uses `min-h-dvh` for proper mobile viewport handling
   - **Accessibility**: Decorative elements have `aria-hidden="true"`, links have proper hover states

### Props Interface:
- `children: ReactNode` - Auth form content to render inside the card
- `backgroundImage?: string` - Optional URL for a background image
- `showPattern?: boolean` - Toggle decorative grid pattern (default: true)
- `className?: string` - Additional classes for the outer container
- `cardClassName?: string` - Additional classes for the card wrapper

### Build Result:
- Zero TypeScript errors
- Named export only (no default export)
- Uses `@/` import alias throughout
- Compatible with existing auth components (GoogleSignInButton, PasswordStrengthIndicator, etc.)
---

## Task: Create UserMenu Dropdown Component

### What was done:

1. **Created `src/components/auth/UserMenu.tsx`** - Dropdown menu component for authenticated users:
   - Uses shadcn/ui `DropdownMenu` with proper `DropdownMenuTrigger`, `DropdownMenuContent`, `DropdownMenuItem`
   - Shows user avatar with initials fallback (computed from name or email)
   - Displays user display name (truncated on smaller screens, hidden on mobile)
   - Menu header shows full name and email
   - Shows current credit balance for free-tier users
   - Menu items: Profile, Settings, Credits, Sessions, Log out
   - Each menu item has an appropriate Lucide icon
   - Navigation uses tenant-aware routing (`/${tenantSlug}/admin/...`)
   - Logout calls the auth context `logout()` and redirects to login page
   - Named export only (no default export)
   - Uses `@/` import aliases throughout
   - Consumes `useTenantAdminAuth` for user/tenant data and logout
   - Consumes `useCredits` hook for real-time credit balance
   - Accessible: proper `aria-label` on trigger, keyboard navigable via Radix

### Files Created:
- `src/components/auth/UserMenu.tsx`

### Key Design Decisions:
- Credit balance only shown for free-tier users (paid plans have unlimited credits)
- Initials logic: uses first letters of two name parts, or first two chars of single name/email
- Display name falls back to email when name is not set
- Trigger button is responsive: shows avatar + name on md+, avatar-only on mobile
- Uses `cursor-pointer` via the shadcn dropdown item styles for clickable items
---

## Task: Create src/components/auth/AvatarUpload.tsx Component

### What was done:

1. **Created `src/components/auth/AvatarUpload.tsx`** - Reusable avatar upload component that:
   - Displays current avatar image or initials placeholder using shadcn Avatar component
   - Click-to-upload with hidden file input and camera icon overlay
   - Validates image type (JPEG, PNG, GIF, WebP) and size (max 5MB)
   - Uploads to Supabase storage `avatars` bucket with upsert
   - Updates `user_profiles.avatar_url` via `update-account-profile` edge function
   - Shows upload progress bar using shadcn Progress component
   - Shows immediate preview via FileReader before upload completes
   - Reverts preview on upload failure
   - Provides toast notifications for success/error states
   - Supports configurable size (`sm`, `md`, `lg`)
   - Includes `onUploadComplete` callback for parent components
   - Proper accessibility: aria-label, aria-hidden on file input, button type
   - Touch-friendly: `touch-manipulation`, `active:opacity-100` for mobile
   - Uses `logger` for error logging (never console.log)
   - Named export only (no default export)
   - All imports use `@/` alias

### Component Props:
```typescript
interface AvatarUploadProps {
  userId: string;                            // Required user ID for file naming
  currentAvatarUrl?: string | null;         // Current avatar to display
  userName?: string | null;                 // Name for initials fallback
  onUploadComplete?: (publicUrl: string) => void;  // Callback after successful upload
  size?: 'sm' | 'md' | 'lg';              // Avatar size variant
  className?: string;                       // Additional styling
}
```

### Verification Results:
- [x] `npm run build` - PASSES (0 TypeScript errors)
- [x] `npm run lint` - PASSES (0 errors, only pre-existing warnings)
- [x] Follows FloraIQ code style (strict TypeScript, named exports, @/ imports, logger)
- [x] Consistent with existing avatar upload pattern in AccountSettings.tsx

### Files Changed:
- `src/components/auth/AvatarUpload.tsx` (new file)

---

## Task: Create CreditsBadge.tsx Header Component

### What was done:

1. **Created `src/components/credits/CreditsBadge.tsx`** - Small badge component for the admin header that:
   - Shows current credit balance with a Coins icon and formatted number
   - Only renders for free-tier users (returns null for paid subscriptions)
   - Links to the credits analytics page (`/:tenantSlug/admin/credits/analytics`) on click
   - Pulses briefly (1.5s `animate-pulse` with ring highlight) when the balance changes
   - Tooltip shows a quick breakdown of purchased vs bonus/free credits
   - Color-coded by balance level (emerald > 2000, yellow > 1000, amber > 500, orange > 100, red <= 100)
   - Supports dark mode with appropriate color variants
   - Uses existing `CreditContext` for balance and free-tier status
   - Fetches purchased vs bonus breakdown via TanStack Query with 5-min stale time
   - Accessible with `aria-label` and proper focus ring styles
   - Uses `useRef` to track previous balance for change detection

### Architecture Decisions:
- Uses `CreditContext` (not raw `useCredits` hook) to stay consistent with `CreditBalance.tsx`
- Uses `button` element (not `div`) for proper keyboard accessibility and semantic correctness
- Navigates via `react-router-dom` instead of opening purchase modal (task spec says "links to credits page")
- Breakdown query aggregates lifetime `purchase` vs `bonus`/`free_grant` transaction types

### Files Changed:
- `src/components/credits/CreditsBadge.tsx` (new file)
---

## Task: Create src/components/auth/TwoFactorSetup.tsx component

### What was done:

Enhanced the existing `TwoFactorSetup.tsx` component with the following improvements:

1. **Password confirmation flow** (NEW - main requirement):
   - Added a dedicated `password-confirm` step before both enable and disable flows
   - Uses `supabase.auth.signInWithPassword` to re-authenticate the user
   - Shows clear error messages for incorrect passwords
   - Form-based input with autoFocus and autoComplete for accessibility
   - Loading state during password verification

2. **Proper disable confirmation dialog** (IMPROVED):
   - Replaced browser `confirm()` with a proper Radix UI Dialog component
   - Two-step disable: first confirm intent via dialog, then password confirmation
   - Descriptive warning about security implications

3. **Type safety improvements** (FIXED):
   - Replaced `useState<any[]>([])` with proper `MfaFactor` interface
   - Removed `(supabase as any)` cast - `user_backup_codes` table exists in types
   - Added explicit return types to `generateBackupCodes`, `hashBackupCode`, `saveBackupCodes`
   - Created typed `SetupStep` and `ActionIntent` union types for state machine

4. **Step-based state machine** (IMPROVED):
   - Clear flow: idle -> password-confirm -> qr-code -> backup-codes
   - Each step rendered as a distinct UI section
   - Cancel returns to idle state with full cleanup

5. **Backup codes UX improvements** (ENHANCED):
   - Added "Copy to Clipboard" button alongside download
   - Used proper lucide icons (Download, Copy) for action buttons
   - Clear visual hierarchy with amber warning styling

6. **All original features preserved**:
   - TOTP secret generation via `supabase.auth.mfa.enroll()`
   - QR code generation via `qrcode` library
   - Manual secret code display as fallback
   - 6-digit verification code input with numeric filtering
   - Backup code generation (10 codes, 10 hex chars each)
   - SHA-256 hashing before database storage
   - File download as `.txt`
   - Enable/disable flows with proper loading states
   - Error handling via `handleError` utility
   - Toast notifications for success/failure

### Verification Results:
- [x] `npm run build` - PASSES (0 TypeScript errors)
- [x] `npm run lint` - PASSES (0 errors for TwoFactorSetup.tsx)
- [x] No `any` types used
- [x] Named export only
- [x] Uses `@/` import alias
- [x] Uses `logger` from `@/lib/logger`
- [x] Proper loading + disabled states on all buttons
- [x] Error handling with try-catch and toast feedback

### Files Changed:
- `src/components/auth/TwoFactorSetup.tsx` (rewritten with password confirmation, proper types, dialog-based disable flow)

---

## Task: Create src/lib/auth/errorMessages.ts - Auth Error Code Mapping

### What was done:

1. **Created `src/lib/auth/errorMessages.ts`** - Comprehensive auth error code to user-friendly message mapping:

   **Types & Interfaces:**
   - `AuthErrorCode` - Union type of all supported error codes (19 codes)
   - `AuthErrorMessage` - Structure with `messageKey` (i18n key), `defaultMessage` (English fallback), and optional `recoveryHint`
   - `TranslateFn` - Type for optional i18n translation function

   **Error Codes Covered:**
   - `invalid_credentials` - Invalid email/password
   - `user_already_registered` / `email_exists` - Duplicate email signup
   - `weak_password` - Password strength requirements not met
   - `expired_token` / `otp_expired` / `refresh_token_expired` - Token expiration variants
   - `account_locked` - Too many failed login attempts
   - `user_banned` - Suspended accounts
   - `rate_limited` / `too_many_requests` - Rate limiting
   - `network_error` - Connection issues (fetch failed, etc.)
   - `email_not_confirmed` / `phone_not_confirmed` - Unverified accounts
   - `signup_disabled` - Registration turned off
   - `user_not_found` - No account for email
   - `session_expired` - Session timeout
   - `invalid_otp` - Wrong verification code
   - `unknown` - Fallback for unrecognized errors

   **Pattern Matching:**
   - `ERROR_MESSAGE_PATTERNS` - Array of 26 known Supabase/GoTrue error message substrings mapped to error codes
   - Handles varied Supabase error message formats (e.g., "invalid login credentials", "token is expired", "failed to fetch")

   **Public API:**
   - `getAuthErrorMessage(error, translate?)` - Returns user-friendly string, resolves via code  status  pattern  fallback
   - `getAuthErrorDetails(error, translate?)` - Returns full `AuthErrorMessage` with recovery hint
   - Both accept varied error shapes: string, Error instance, `{ message, code, status }` objects, or unknown

   **i18n Ready:**
   - Every message has a `messageKey` following `auth.error.*` namespace convention
   - Optional `TranslateFn` parameter allows plugging in any i18n library (react-i18next, formatjs, etc.)
   - Falls back to English `defaultMessage` when no translate function is provided

   **Internal Helpers:**
   - `normalizeError()` - Handles string, Error, object, and unknown input shapes
   - `resolveEntry()` - Applies translation function when available

### Verification Results:
- [x] TypeScript type-check passes (no errors in errorMessages.ts)
- [x] ESLint passes (no warnings or errors)
- [x] No `console.log` usage
- [x] No `any` types used
- [x] Named exports only
- [x] Uses `@/` import alias convention (no imports needed from project in this standalone utility)

### Files Changed:
- `src/lib/auth/errorMessages.ts` (new file)

---

## Task: Create AuthErrorBoundary.tsx Error Boundary

### What was done:

1. **Rewrote `src/components/auth/AuthErrorBoundary.tsx`** - Class-based React error boundary that:
   - Catches auth-related errors thrown by child components, preventing app crashes
   - Detects auth errors via keyword matching (token, auth, unauthorized, expired, session, jwt, credentials, forbidden, 401, 403)
   - Distinguishes between general auth errors and session-expired errors for tailored UX
   - Shows a friendly error message with contextual title ("Session Expired" vs "Authentication Error")
   - Lists possible causes for non-session errors (expired token, invalid credentials, account status change, network issues)
   - Provides collapsible technical details section for debugging
   - **Retry button**: Resets the error boundary state so children re-render without clearing auth
   - **Login redirect button**: Clears auth tokens and redirects to the appropriate login page using `getLoginUrl()` from authHelpers
   - Logs full error details via `logger.error()` including component stack, error classification, and user type
   - Clears auth tokens automatically on detected auth errors via `clearAllAuthTokens()`
   - Uses `getLoginUrl()` utility for proper login URL resolution based on userType and tenantSlug props

### Acceptance Criteria Met:
- [x] Catches auth-related errors (getDerivedStateFromError + componentDidCatch)
- [x] Shows friendly error message with clear description
- [x] Retry button that resets boundary state
- [x] Logs error details with logger utility
- [x] Provides login redirect if session expired
- [x] Prevents app crash on auth failures (error boundary pattern)
- [x] TypeScript strict mode - no `any` types
- [x] Named export only
- [x] Uses `@/` import alias
- [x] Uses `logger` instead of console.log

### Files Changed:
- `src/components/auth/AuthErrorBoundary.tsx` (rewritten with full error boundary implementation)

---

## Task: Add Offline Handling to Auth Flows

### What was done:

1. **Created `src/hooks/useAuthOffline.ts`** - Custom hook that:
   - Detects `navigator.onLine` status with event listeners for `online`/`offline` events
   - Queues login attempts when offline (stores email, password, tenantSlug, timestamp in state)
   - Auto-retries queued login attempts when connection is restored
   - Provides `preventSubmit()` helper that blocks form submission when offline with a toast message
   - Shows appropriate toast messages for offline state, queuing, and retry outcomes
   - Uses `useRef` for the retry callback to avoid stale closures
   - Exposes: `isOnline`, `hasQueuedAttempt`, `queuedAttempt`, `queueLoginAttempt`, `clearQueuedAttempt`, `preventSubmit`

2. **Created `src/components/auth/AuthOfflineIndicator.tsx`** - Inline indicator component that:
   - Shows a red warning banner when user is offline ("You are offline - Check your internet connection")
   - Shows an amber banner when a login attempt is queued and user is still offline
   - Shows a blue banner with spinner when retrying a queued login after coming back online
   - Uses proper ARIA attributes (`role="alert"`, `role="status"`, `aria-live`) for accessibility
   - Renders nothing when online and no queued attempt exists
   - Uses lucide-react icons (WifiOff, Clock, Loader2)

3. **Integrated into Tenant Admin Login (`src/pages/tenant-admin/LoginPage.tsx`)**:
   - Added `useAuthOffline` hook with retry callback that calls `login()` and navigates on success
   - Added `AuthOfflineIndicator` above the login form
   - Queues login attempt when form is submitted while offline
   - Disables submit button and Google Sign-In button when offline

4. **Integrated into Customer Login (`src/pages/customer/LoginPage.tsx`)**:
   - Added `useAuthOffline` hook with retry callback
   - Added `AuthOfflineIndicator` above the form
   - Queues login attempt when offline
   - Disables both password login and magic link buttons when offline
   - Disables Google Sign-In button when offline

5. **Integrated into Super Admin Login (`src/pages/super-admin/LoginPage.tsx`)**:
   - Added `useAuthOffline` hook with retry callback
   - Added `AuthOfflineIndicator` above the form
   - Queues login attempt when offline
   - Disables submit button and Google Sign-In button when offline

6. **Integrated into Courier Login (`src/pages/courier/LoginPage.tsx`)**:
   - Added `useAuthOffline` hook (no retry callback - courier has PIN step)
   - Added `AuthOfflineIndicator` in the form card
   - Queues login attempt when offline
   - Disables Continue button when offline

7. **Integrated into Account Signup (`src/pages/AccountSignup.tsx`)**:
   - Added `useAuthOffline` hook for online status detection
   - Added `AuthOfflineIndicator` inside the card content
   - Blocks step 2 submission when offline with a toast message
   - Disables "Create My Account" button when offline

### Verification:
- [x] `npm run build` - passes with zero TypeScript errors
- [x] `npm run lint` - passes with zero errors (only pre-existing warnings)
- [x] All auth forms detect `navigator.onLine` status
- [x] Login attempts are queued when offline
- [x] Queued attempts auto-retry when back online
- [x] Offline indicator shown in all auth forms
- [x] Form submission prevented when offline
- [x] OAuth/Google sign-in buttons disabled when offline

### Files Created:
- `src/hooks/useAuthOffline.ts`
- `src/components/auth/AuthOfflineIndicator.tsx`

### Files Modified:
- `src/pages/tenant-admin/LoginPage.tsx`
- `src/pages/customer/LoginPage.tsx`
- `src/pages/super-admin/LoginPage.tsx`
- `src/pages/courier/LoginPage.tsx`

---

## Task: Add Rate Limiting Display to Login and Signup Forms

### What was done:

1. **Created `src/hooks/useAuthRateLimit.ts`** - Custom hook that:
   - Tracks client-side attempt counts per form (separate sessionStorage keys)
   - Implements exponential backoff: after 5 failed attempts, lockout starts at 15s and doubles each subsequent attempt (15s, 30s, 60s, 120s, capped at 300s)
   - Persists state across page refresh via `sessionStorage`
   - Provides `isLocked`, `remainingSeconds`, `attemptCount` reactive state
   - Countdown timer updates every second during lockout
   - `recordAttempt()` increments counter and triggers lockout when threshold exceeded
   - `resetOnSuccess()` clears all state on successful auth
   - Logs rate limit triggers via project's `logger` utility

2. **Created `src/components/auth/RateLimitWarning.tsx`** - Reusable alert component:
   - Shows "Too many attempts. Please try again in X" message
   - Supports `dark` variant (for customer forms with dark backgrounds) and `light` variant (for SaaS/marketing forms)
   - Uses `AlertCircle` icon from lucide-react
   - Accessible with `role="alert"` and `aria-live="polite"`
   - Formats time as seconds or minutes depending on duration
   - Self-hides when `remainingSeconds <= 0`

3. **Integrated into Customer Login (`src/pages/customer/LoginPage.tsx`)**:
   - Uses storageKey `floraiq_customer_login_rate_limit`
   - Shows dark-variant warning above form fields
   - Disables both password and magic link submit buttons when locked
   - Records attempt on login failure, resets on success
   - Guards `handleSubmit` from executing when locked

4. **Integrated into Customer Signup (`src/pages/customer/SignUpPage.tsx`)**:
   - Uses storageKey `floraiq_customer_signup_rate_limit`
   - Shows dark-variant warning above form fields
   - Disables submit button when locked
   - Records attempt on signup failure, resets on success

5. **Integrated into SaaS Admin Login (`src/pages/saas/LoginPage.tsx`)**:
   - Uses storageKey `floraiq_saas_login_rate_limit`
   - Shows light-variant warning above form
   - Disables submit button when locked
   - Records attempt on login failure, resets on success
   - Respects existing offline detection (rate limit check runs first)

6. **Integrated into Account Signup (`src/pages/AccountSignup.tsx`)**:
   - Uses storageKey `floraiq_account_signup_rate_limit`
   - Shows light-variant warning in Step 2 (the actual API submission step)
   - Disables submit button when locked
   - Records attempt on signup failure, resets on success

### Exponential Backoff Schedule:
- Attempts 1-5: No lockout (user can retry immediately)
- Attempt 6: 15 second lockout
- Attempt 7: 30 second lockout
- Attempt 8: 60 second lockout
- Attempt 9: 120 second lockout
- Attempt 10+: 300 second (5 minute) lockout (capped)

### Verification Results:
- [x] `npm run build` - PASSES (0 TypeScript errors)
- [x] `npm run lint` - PASSES (0 errors in new files)
- [x] All 4 forms properly integrated
- [x] sessionStorage persistence across page refresh
- [x] Countdown display with live updates
- [x] Button disabled states during lockout
- [x] Accessible alert component with ARIA attributes

### Files Added:
- `src/hooks/useAuthRateLimit.ts`
- `src/components/auth/RateLimitWarning.tsx`

### Files Modified:
- `src/pages/customer/LoginPage.tsx`
- `src/pages/customer/SignUpPage.tsx`
- `src/pages/saas/LoginPage.tsx`
- `src/pages/AccountSignup.tsx`

---

## Task: Add Account Recovery Flow for Locked Accounts

### What was implemented:
Added a complete account recovery flow for locked accounts that handles rate-limiting (429) and explicit account lock scenarios in the tenant admin login flow.

### Features:
1. **Account Locked Message** - Shows a clear "Account Locked" screen with shield icon when login attempts are exhausted
2. **Unlock Time Countdown** - Real-time countdown timer showing exactly when the account will unlock (mm:ss format)
3. **Contact Support Link** - Mailto link pre-filled with account details for direct support contact
4. **Automatic Unlock Check** - Timer-based interval that automatically checks and unlocks when the lock period expires, calling `onUnlocked` callback
5. **Request Admin Unlock via Email** - Form to request early unlock; sends notification to tenant admin via edge function; prevents email enumeration

### Files Created:
- `src/hooks/useAccountLockStatus.ts` - Hook managing lock state with countdown timer, auto-unlock detection, and cleanup
- `src/components/auth/AccountLockedScreen.tsx` - Full locked account UI with timer, unlock request form, and support link
- `supabase/functions/request-account-unlock/index.ts` - Edge function handling unlock requests; creates notification for tenant owner; prevents email enumeration

### Files Modified:
- `src/pages/tenant-admin/LoginPage.tsx` - Integrated account lock detection (429 status, retryAfter header, locked message keywords) and renders AccountLockedScreen

### How it works:
1. User attempts login and gets rate-limited (HTTP 429 with `retryAfter` header) or receives a "locked/too many attempts" error
2. LoginPage detects the lock condition and shows AccountLockedScreen
3. AccountLockedScreen displays countdown timer, support contact, and unlock request form
4. Timer automatically counts down and unlocks when expired
5. User can request early admin unlock - creates a notification in the notifications table
6. Edge function validates input but always returns 200 to prevent email enumeration

### Verification Results:
- [x] `npm run build` - PASSES (0 TypeScript errors)
- [x] `npm run lint` - PASSES (0 errors in new/modified files)
- [x] No `console.log` in application code (uses `logger` utility)
- [x] Named exports only
- [x] `@/` import aliases used throughout
- [x] Buttons have loading + disabled states
- [x] Edge function follows shared deps pattern
- [x] Security: prevents email enumeration in unlock requests

---

## Agent 99: Add CSRF Protection to All Auth Forms

### Summary
Added CSRF (Cross-Site Request Forgery) protection to all authentication forms in the application. The implementation generates a cryptographically secure token on page load, stores it in sessionStorage, validates it on form submission, regenerates after each use, and blocks requests without a valid token.

### Implementation Details

#### Core CSRF Utility (`src/lib/csrf.ts`)
- `generateCsrfToken()`: Generates 32-byte cryptographically secure random token using `crypto.getRandomValues()`, stores in sessionStorage with timestamp
- `getCsrfToken()`: Retrieves token from sessionStorage, checks 30-minute expiration
- `validateCsrfToken()`: Validates submitted token against stored token using constant-time comparison to prevent timing attacks
- `regenerateCsrfToken()`: Clears old token and generates a new one (called after successful validation)
- `clearCsrfToken()`: Removes token and timestamp from sessionStorage

#### React Hook (`src/hooks/useCsrfToken.ts`)
- Generates token on component mount (page load)
- `validateToken()`: Validates current token and auto-regenerates on success
- `refreshToken()`: Manual token refresh if needed
- Returns `{ csrfToken, validateToken, refreshToken }`

#### Protected Auth Forms (11 forms total)
All forms validate CSRF token before processing submission, showing "Security Error" toast and blocking the request if token is invalid:

1. `src/pages/customer/LoginPage.tsx` - Customer login
2. `src/pages/customer/SignUpPage.tsx` - Customer registration
3. `src/pages/customer/ForgotPasswordPage.tsx` - Customer password reset request
4. `src/pages/customer/ResetPasswordPage.tsx` - Customer password reset
5. `src/pages/tenant-admin/LoginPage.tsx` - Tenant admin login
6. `src/pages/saas/LoginPage.tsx` - SaaS platform login
7. `src/pages/saas/SignUpPage.tsx` - SaaS platform registration
8. `src/pages/super-admin/LoginPage.tsx` - Super admin login
9. `src/pages/courier/LoginPage.tsx` - Courier login
10. `src/pages/auth/PasswordResetPage.tsx` - Universal password reset
11. `src/components/auth/ForgotPasswordDialog.tsx` - Forgot password dialog (used across multiple login pages)

### Security Features
- **Cryptographic randomness**: Uses Web Crypto API (`crypto.getRandomValues`) for 256-bit tokens
- **Timing attack prevention**: Constant-time string comparison in validation
- **Token expiration**: 30-minute maximum age prevents stale token reuse
- **Single-use tokens**: Automatically regenerated after each successful validation
- **Session isolation**: Stored in sessionStorage (tab-specific, cleared on close)

### Files Changed
- `src/lib/csrf.ts` (new - CSRF token utility functions)
- `src/hooks/useCsrfToken.ts` (new - React hook for CSRF integration)
- `src/pages/customer/LoginPage.tsx` (CSRF validation added)
- `src/pages/customer/SignUpPage.tsx` (CSRF validation added)
- `src/pages/customer/ForgotPasswordPage.tsx` (CSRF validation added)
- `src/pages/customer/ResetPasswordPage.tsx` (CSRF validation added)
- `src/pages/tenant-admin/LoginPage.tsx` (CSRF validation added)
- `src/pages/saas/LoginPage.tsx` (CSRF validation added)
- `src/pages/saas/SignUpPage.tsx` (CSRF validation added)
- `src/pages/super-admin/LoginPage.tsx` (CSRF validation added)
- `src/pages/courier/LoginPage.tsx` (CSRF validation added)
- `src/pages/auth/PasswordResetPage.tsx` (CSRF validation added)
- `src/components/auth/ForgotPasswordDialog.tsx` (CSRF validation added)

### Build Status
- `npm run build`: PASS (0 errors)
- `npm run lint`: PASS (0 new warnings/errors)
---

## Task: Add Brute Force Protection - Track Failed Logins by IP

### What was done:

1. **Created migration `supabase/migrations/20260124000001_brute_force_protection.sql`**:
   - **`auth_audit_log` table**: Tracks all login attempts with `event_type`, `ip_address`, `email`, `success`, `failure_reason`, `user_agent`, and `metadata` JSONB. Indexed for fast IP+time lookups.
   - **`ip_allowlist` table**: Maintains trusted IPs that bypass brute force checks. Unique constraint on IP, `is_active` flag, `description` field.
   - **`log_auth_audit_event()` RPC**: Security definer function to log auth events.
   - **`check_ip_brute_force()` RPC**: Checks if IP is blocked (10+ failed attempts across ANY account in 1 hour). Returns `{blocked, allowlisted, failed_attempts}`. Logs `ip_brute_force_blocked` security event when threshold exceeded.
   - **`cleanup_auth_audit_log()` RPC**: Retention policy - deletes entries older than 90 days.
   - **RLS policies**: Both tables are service_role-only access.
   - **Seed data**: Localhost IPs (127.0.0.1, ::1) pre-allowlisted.

2. **Created `supabase/functions/_shared/bruteForceProtection.ts`** - Shared utility:
   - `getClientIP(req)`: Extracts client IP from x-forwarded-for, cf-connecting-ip, x-real-ip headers.
   - `checkBruteForce(ip)`: Calls `check_ip_brute_force` RPC, fails open on error.
   - `logAuthEvent(params)`: Calls `log_auth_audit_event` RPC for tracking.
   - `GENERIC_AUTH_ERROR` / `GENERIC_AUTH_DETAIL`: Constants for generic error messages that don't reveal IP blocking.

3. **Updated `supabase/functions/tenant-admin-auth/index.ts`**:
   - Added brute force check BEFORE the per-email rate limit (blocks across all accounts).
   - Logs failed attempts (invalid_credentials, no_user_returned, not_authorized_for_tenant) to auth_audit_log.
   - Logs successful logins to auth_audit_log.
   - Returns generic error on IP block (401 "Invalid credentials" - not revealing block).
   - Uses shared `getClientIP()` for consistent IP extraction.

4. **Updated `supabase/functions/admin-auth/index.ts`**:
   - Added brute force check before per-email rate limit.
   - Logs failed/successful attempts to auth_audit_log.
   - Returns generic error on IP block (same 401 as normal failure).
   - Maintains backward compatibility with legacy `auth_failed_attempts` table.

5. **Updated `supabase/functions/magic-link-login/index.ts`**:
   - Added brute force check to prevent email spam from blocked IPs.
   - Returns success-like response when blocked (doesn't reveal block status).
   - Uses shared `getClientIP()` for consistent IP extraction.

### Key Design Decisions:
- **Generic error on block**: Blocked IPs receive the same 401 "Invalid credentials" error as a normal failure, preventing attackers from learning about the blocking mechanism.
- **Cross-account tracking**: The 10-attempt threshold is per IP across ALL accounts, preventing distributed credential stuffing.
- **1-hour window**: Failed attempts expire after 1 hour, allowing recovery without admin intervention.
- **IP allowlist bypass**: Known good IPs (e.g., office networks, load balancers) can be added to `ip_allowlist` to never be blocked.
- **Fail open on error**: If the brute force check RPC fails (DB issue), the system fails open to avoid blocking legitimate users.
- **Security events**: Critical `ip_brute_force_blocked` events are logged to the `security_events` table for monitoring.

### Verification Results:
- [x] `npm run build` - PASSES (0 TypeScript errors)
- [x] `npm run lint` - PASSES (0 errors, 1873 warnings - pre-existing)

### Files Changed:
- `supabase/migrations/20260124000001_brute_force_protection.sql` (new)
- `supabase/functions/_shared/bruteForceProtection.ts` (new)
- `supabase/functions/tenant-admin-auth/index.ts` (updated)
- `supabase/functions/admin-auth/index.ts` (updated)
- `supabase/functions/magic-link-login/index.ts` (updated)

---

## Task: Add Suspicious Activity Detection

### What was done:

1. **Database Migration** (`supabase/migrations/20260124100000_suspicious_activity_detection.sql`):
   - Created `user_known_devices` table to track trusted devices per user with fingerprint, browser, OS, IP, geo info, and trust status
   - Created `suspicious_login_alerts` table to track suspicious login events with email notification status, user response, and one-click secure token
   - Added RLS policies for user self-service (view/update own devices and alerts) and tenant admin visibility
   - Created `check_device_suspicious_login()` SECURITY DEFINER function that:
     - Detects new device logins by comparing fingerprint against known devices
     - Detects new location logins by comparing geo info
     - Auto-trusts first device (no alert on first-ever login)
     - Creates alerts with severity levels (warning/critical)
     - Generates secure tokens (24hr expiry) for one-click account lock
     - Logs all events to `audit_events` table (auth category)
   - Created `secure_account_from_alert()` function for one-click email action (marks device as untrusted, logs critical audit event)
   - Created `confirm_login_was_me()` function for user to confirm legitimate login and trust the device
   - Performance indexes on user_id, fingerprint, token, pending alerts, and tenant

2. **Edge Function: detect-suspicious-login** (`supabase/functions/detect-suspicious-login/index.ts`):
   - Validates input with Zod schema
   - Extracts IP address from request headers
   - Gets geo-location for the IP (extensible for MaxMind/ip-api integration)
   - Calls `check_device_suspicious_login` RPC
   - On suspicious detection, sends HTML email notification via Resend API with:
     - Device details (browser, OS, type)
     - Location info (city, country, IP)
     - Login timestamp
     - One-click "Secure My Account" button with secure token URL
   - Updates alert with email_sent status
   - Uses `withZenProtection` and CORS headers per project patterns

3. **Edge Function: secure-account** (`supabase/functions/secure-account/index.ts`):
   - Two actions: `secure` (one-click from email, no auth required) and `confirm` (user confirms login, auth required)
   - `secure` action: Validates token, calls `secure_account_from_alert` RPC, revokes all user sessions via `auth.admin.signOut(userId, 'global')`
   - `confirm` action: Authenticates user via JWT, calls `confirm_login_was_me` RPC, trusts the device

4. **Frontend Hook: useSuspiciousLoginDetection** (`src/hooks/useSuspiciousLoginDetection.ts`):
   - Listens for `SIGNED_IN` auth events
   - Generates device fingerprint and calls `detect-suspicious-login` edge function
   - Handles network errors gracefully (no disruption to user experience)
   - Integrated into `DeviceTracker` component (already mounted app-wide)

5. **Frontend Hook: useKnownDevices** (`src/hooks/useKnownDevices.ts`):
   - TanStack Query-based hook for managing known devices and alerts
   - Queries: `devices`, `alerts`, `pendingAlerts`
   - Mutations: `trustDevice`, `untrustDevice`, `removeDevice`, `confirmAlert`
   - All mutations invalidate relevant queries on success

6. **Admin Component: SuspiciousActivityPanel** (`src/components/admin/SuspiciousActivityPanel.tsx`):
   - Pending alerts section with severity badges and "Was me" confirmation
   - Known devices list with trust/untrust/remove actions
   - Alert history with resolution status indicators
   - Device type icons (desktop/mobile/tablet)
   - Geo-location and IP display

7. **Secure Account Page** (`src/pages/auth/SecureAccountPage.tsx`):
   - Public page at `/auth/secure-account?token=...`
   - Handles the one-click secure link from email
   - Shows loading, success, error, and expired states
   - On success: advises password change, links to login
   - Route added to `App.tsx`

8. **Query Keys** (`src/lib/queryKeys.ts`):
   - Added `security.knownDevices(userId)` and `security.suspiciousAlerts(userId)` keys

### Audit Logging Integration:
All suspicious activity events are logged to the existing `audit_events` partitioned table:
- `suspicious_login_new_device` (warning)
- `suspicious_login_new_location` (warning)
- `suspicious_login_new_device_and_location` (critical)
- `first_device_registered` (info)
- `device_login` (info - normal known device login)
- `account_secured_from_alert` (critical)
- `login_confirmed_by_user` (info)

### Files Changed:
- `supabase/migrations/20260124100000_suspicious_activity_detection.sql` (new)
- `supabase/functions/detect-suspicious-login/index.ts` (new)
- `supabase/functions/secure-account/index.ts` (new)
- `src/hooks/useSuspiciousLoginDetection.ts` (new)
- `src/hooks/useKnownDevices.ts` (new)
- `src/components/admin/SuspiciousActivityPanel.tsx` (new)
- `src/pages/auth/SecureAccountPage.tsx` (new)
- `src/components/DeviceTracker.tsx` (added suspicious login detection)
- `src/App.tsx` (added SecureAccountPage lazy import and route)
- `src/lib/queryKeys.ts` (added security query keys)
- [x] No `console.log` statements (uses logger utility)
- [x] Named exports used throughout
- [x] TypeScript strict mode - no `any` types

### Files Created:
- `src/lib/security/passwordBreach.ts`
- `src/hooks/usePasswordBreachCheck.ts`
- `src/components/auth/PasswordBreachWarning.tsx`

### Files Modified:
- `src/pages/AccountSignup.tsx`
- `src/pages/customer/SignUpPage.tsx`
- `src/pages/auth/PasswordResetPage.tsx`
- `src/pages/customer/ResetPasswordPage.tsx`
- `src/pages/customer/SettingsPage.tsx`
- `src/pages/tenant-admin/settings/SecuritySettings.tsx`

---

## Task: Add Session Fixation Protection

### What was done:

1. **Created `src/lib/auth/sessionFixation.ts`** - Session fixation protection utility that:
   - `clearPreAuthSessionData(tier)`: Clears all pre-authentication tokens, user data, and session markers before login to prevent attackers from pre-setting session tokens
   - `establishFreshSession(tier)`: Generates a cryptographically random 32-byte session nonce after successful authentication, stored in sessionStorage to prove session legitimacy
   - `validateSessionFreshness()`: Validates the session nonce format and timestamp to detect tampered sessions
   - `invalidateSessionNonce()`: Removes session markers during logout to prevent reuse
   - Uses `crypto.getRandomValues()` for secure random nonce generation
   - Handles all three auth tiers: `tenant_admin`, `customer`, `super_admin`

2. **Updated `src/contexts/TenantAdminAuthContext.tsx`**:
   - Calls `clearPreAuthSessionData('tenant_admin')` at the start of the login function (before any network request) to wipe any pre-existing tokens/data that could have been planted by an attacker
   - Calls `establishFreshSession('tenant_admin')` after successful authentication to generate a fresh session marker
   - Calls `invalidateSessionNonce()` at the start of logout to prevent old session markers from being reused

3. **Updated `src/contexts/CustomerAuthContext.tsx`**:
   - Calls `clearPreAuthSessionData('customer')` at the start of the login function
   - Calls `establishFreshSession('customer')` after successful authentication
   - Calls `invalidateSessionNonce()` at the start of logout

4. **Updated `supabase/functions/tenant-admin-auth/index.ts`** (Edge Function):
   - After successful authentication, invalidates all previous `tenant_admin_sessions` for the user via DELETE query
   - Calls `supabase.auth.admin.signOut(userId, 'others')` to invalidate other Supabase refresh tokens from prior sessions
   - Both operations are best-effort (logged warnings on failure, don't block login)

5. **Updated `supabase/functions/customer-auth/index.ts`** (Edge Function):
   - After password verification but before generating new JWT token, deletes all existing `customer_sessions` records for the customer user and tenant
   - Ensures each login produces a completely fresh session with no carryover

6. **Updated `src/lib/auth/logoutCleanup.ts`**:
   - Added `invalidateSessionNonce()` as step 1 of the cleanup process
   - Ensures session nonces are always cleared during logout cleanup (safety net for cross-tab logout scenarios)

### Security Protection Layers:
- **Client-side pre-login**: Wipes all stored tokens/data before authentication request
- **Server-side session invalidation**: Deletes all prior sessions from database on login
- **Server-side token invalidation**: Revokes other Supabase auth sessions on login
- **Client-side post-login**: Generates fresh session nonce proving legitimate session creation
- **Logout cleanup**: Invalidates session nonce on every logout path

### Acceptance Criteria Met:
- [x] Session token regenerated after login (new JWT/access token from Supabase, old sessions deleted)
- [x] Pre-auth session data invalidated (cleared before login request)
- [x] Fresh session state on authentication (new nonce, new tokens, old sessions purged)
- [x] Prevents session hijacking attacks (attacker's pre-set tokens are wiped, old sessions invalidated)
- [x] Build passes with no TypeScript errors
- [x] Lint passes with no new errors

### Files Changed:
- `src/lib/auth/sessionFixation.ts` (new - core session fixation protection utility)
- `src/contexts/TenantAdminAuthContext.tsx` (added pre-auth cleanup, post-auth fresh session, logout invalidation)
- `src/contexts/CustomerAuthContext.tsx` (added pre-auth cleanup, post-auth fresh session, logout invalidation)
- `supabase/functions/tenant-admin-auth/index.ts` (invalidate previous sessions on login)
- `supabase/functions/customer-auth/index.ts` (invalidate previous customer sessions on login)
- `src/lib/auth/logoutCleanup.ts` (integrated session nonce invalidation into cleanup pipeline)

---

## Agent 104: Add Secure Headers Middleware for Edge Functions

### Task
Add secure headers middleware for edge functions setting:
- X-Content-Type-Options: nosniff
- X-Frame-Options: DENY
- X-XSS-Protection: 1; mode=block
- Content-Security-Policy: default-src 'none'; frame-ancestors 'none'
- Referrer-Policy: strict-origin-when-cross-origin

### Implementation

#### Created: `supabase/functions/_shared/secure-headers.ts`
New shared module providing:
- `secureHeaders` - constant object with all security headers
- `withSecureHeaders(headers)` - merges secure headers into existing headers object
- `secureHeadersMiddleware(handler)` - wrapper that automatically applies secure headers to all responses from a handler

#### Updated: `supabase/functions/_shared/deps.ts`
- Added re-exports of `secureHeaders`, `withSecureHeaders`, and `secureHeadersMiddleware` from the new module

#### Updated: `supabase/functions/_shared/zen-firewall.ts`
- Integrated secure headers into the `withZenProtection` wrapper
- All functions using `withZenProtection` now automatically include secure headers in both blocked and allowed responses

#### Updated Edge Functions (direct middleware adoption):
- `supabase/functions/admin-auth/index.ts` - wrapped with `secureHeadersMiddleware`
- `supabase/functions/customer-auth/index.ts` - wrapped with `secureHeadersMiddleware`
- `supabase/functions/super-admin-auth/index.ts` - wrapped with `secureHeadersMiddleware`
- `supabase/functions/tenant-admin-auth/index.ts` - wrapped with `secureHeadersMiddleware`
- `supabase/functions/create-checkout/index.ts` - wrapped with `secureHeadersMiddleware`
- `supabase/functions/storefront-checkout/index.ts` - wrapped with `secureHeadersMiddleware`, also migrated to use `_shared/deps.ts` imports

### How It Works
1. Functions using `withZenProtection` get secure headers automatically (no changes needed)
2. Functions not using `withZenProtection` can adopt `secureHeadersMiddleware` as a wrapper around their handler
3. For inline header composition, `withSecureHeaders(headers)` can merge secure headers with existing ones
4. All three approaches are exported from `_shared/deps.ts` for consistent imports

### Verification Results:
- [x] `npm run build` - PASSES (0 TypeScript errors)
- [x] `npm run lint` - PASSES (0 errors, 1873 warnings pre-existing)

---

## Task: Test Complete Signup Flow

### What was done:

Created comprehensive integration test for the complete signup flow at `src/pages/saas/__tests__/SignUpFlow.test.tsx` covering all 5 requirements:

1. **Form submission with email, password, name, phone** (4 tests):
   - Renders signup form with all required fields (business name, name, email, password)
   - Submits form and calls `tenant-signup` edge function with correct data
   - Includes phone number when optional fields are expanded
   - Shows validation errors for invalid form data

2. **Email verification sent** (1 test):
   - Verifies `tenant-signup` edge function is called which triggers the email confirmation flow

3. **Verification link and token processing** (4 tests):
   - Verifies OTP token via `supabase.auth.verifyOtp()` on AuthConfirmPage
   - Handles expired token with appropriate error message ("Link Expired")
   - Handles invalid token with appropriate error message ("Invalid Link")
   - Redirects to tenant admin dashboard after successful verification

4. **User login after verification** (3 tests):
   - Allows login with correct email/password after verification
   - Rejects login with wrong password
   - Rejects login for unverified email

5. **Credits account created with zero balance** (7 tests):
   - Calls `grant_free_credits` RPC after successful signup
   - Sets tenant as free tier with `credits_enabled: true`
   - Handles credit grant failure gracefully without blocking signup
   - Navigates to dashboard with `welcome=true` flag
   - Initializes credit account with 10,000 credits for free tier
   - Sets `purchased_credits_balance` to 0 on new account
   - Creates idempotency key to prevent duplicate initial grants

6. **Session establishment** (2 tests):
   - Sets Supabase session with tokens from edge function response
   - Saves `lastTenantSlug` to localStorage

7. **Error handling** (2 tests):
   - Handles edge function errors gracefully
   - Handles duplicate email errors

### Test Results:
- 23 tests total, all passing
- Covers: SignUpPage form submission, AuthConfirmPage token verification, login flow, credits initialization

### Files Created:
- `src/pages/saas/__tests__/SignUpFlow.test.tsx`

---

## Task: Test Complete Login Flow with Valid Credentials, Invalid Password, Locked Account, and Remember Me

### What was done:

Created comprehensive login flow tests in `src/pages/saas/__tests__/LoginFlowComplete.test.tsx` with 24 tests across 4 test suites:

#### 1. Complete Login Flow with Valid Credentials (7 tests):
- Authenticates via Supabase signInWithPassword and verifies session tokens stored
- Verifies admin and tenant data persisted in localStorage
- Verifies user ID stored in both sessionStorage and localStorage
- Verifies lastTenantSlug stored for session continuity
- Tests welcome toast and navigation to tenant dashboard
- Validates edge function called with correct email/password/tenantSlug payload
- Confirms email normalized to lowercase before login

#### 2. Invalid Password Error - No Email Disclosure (5 tests):
- Invalid password shows generic "Login Failed" error without revealing email exists
- Non-existent email shows same generic error (prevents user enumeration)
- Password field cleared after failed attempt (security best practice)
- No session data stored on failed login
- Edge function 401 response shows generic "Invalid credentials" message

#### 3. Locked/Suspended Account (5 tests):
- Suspended tenant account shows "Account suspended" message
- Unauthorized tenant access shows "You do not have access to this tenant"
- No session data stored when account is locked
- Rate-limited (429) shows "Too many login attempts" with retry message
- No tenant found handled without revealing account details

#### 4. Remember Me Session Persistence (7 tests):
- "Remember me" checkbox renders in login form
- Access/refresh tokens persisted in localStorage (survives browser restart)
- Admin and tenant data persisted for session recovery
- lastTenantSlug stored for cross-session persistence
- User ID stored in both sessionStorage and localStorage (hybrid persistence)
- Edge function sets httpOnly cookies with 7-day Max-Age for persistent sessions
- Stale session cleared before new login to prevent conflicts

### Test Architecture:
- Uses Vitest + React Testing Library + userEvent
- Mocks: Supabase client, resilientFetch, authFlowLogger, encryption, toast, navigation
- AAA pattern (Arrange-Act-Assert) for all tests
- Black-box testing of observable behavior
- Each test isolates storage (localStorage.clear, sessionStorage.clear in beforeEach)

### Acceptance Criteria Met:
-  Test complete login flow with valid credentials verifying session created
-  Test invalid password shows error without revealing email exists
-  Test locked account shows appropriate message
-  Test remember me persists session longer

### Test Results:
- 24 tests passing (all green)
- 1 test file, 4 describe blocks

### Files Changed:
- `src/pages/saas/__tests__/LoginFlowComplete.test.tsx` (new - 24 tests)
---

## Task: Test Password Reset Flow

### What was done:

Created comprehensive tests for the password reset flow covering the full lifecycle:
1. Request reset for existing email  verify token generated & email sent
2. Verify email received with valid reset link
3. Reset password with new strong password
4. Verify old password no longer works
5. Verify new password works
6. Verify all other sessions are revoked after reset

### Test Files Created:

1. **`tests/integration/password-reset-flow.test.ts`** (36 tests) - Integration test using an in-memory database simulation that validates:
   - **Request Password Reset**: Token generation, 24h expiration, email enumeration protection, tenant validation, IP/user-agent tracking
   - **Email Verification**: Correct reset URL structure, token matching, business name in subject, no email for non-existing users
   - **Password Reset**: Hash update, token single-use enforcement, expired token rejection, mismatched tenant/email rejection, password length validation (min 8, max 100)
   - **Old Password Rejection**: Verifies old password no longer authenticates after reset
   - **New Password Authentication**: Verifies new password works for login, creates valid sessions
   - **Session Revocation**: All existing sessions invalidated, other users unaffected, new session creation after re-login
   - **Full E2E Flow**: Complete lifecycle from initial login  reset request  email  reset  old pass fails  new pass works  sessions revoked  token can't be reused
   - **Token Security**: Unique tokens per request, sufficient length, audit metadata

2. **`src/pages/customer/__tests__/PasswordResetPages.test.tsx`** (20 tests) - Component tests for UI:
   - **ForgotPasswordPage**: Form rendering, email validation, button disabled/enabled states, loading state, success state (Check Your Email), error toast, back-to-login link
   - **ResetPasswordPage**: Form with prefilled email from URL, disabled email input, password matching validation, min-length enforcement, password strength indicator, loading state, success state, error toast, API payload verification, show/hide password toggle, back-to-login link

### Key Design Decisions:
- Integration tests use an in-memory database simulation (same pattern as `order-inventory-flow.test.ts`) to test the business logic of both Edge Functions without requiring a live Supabase connection
- Component tests mock Supabase client, apiClient, toast, and PasswordStrengthIndicator to focus on UI behavior
- Tests verify security properties: email enumeration protection, single-use tokens, session invalidation, password hashing

### Test Results:
- 56 tests total (36 integration + 20 component), all passing
- Integration tests: ~10ms execution
- Component tests: ~6.5s execution (DOM rendering)

### Files Changed:
- `tests/integration/password-reset-flow.test.ts` (new - 36 tests)
- `src/pages/customer/__tests__/PasswordResetPages.test.tsx` (new - 20 tests)

---

## Task: Test Credit Purchase Flow (Select Package, Promo Code, Stripe Payment, Balance, Transaction, Receipt)

### What was done:

1. **Created comprehensive integration test** at `tests/integration/credit-purchase-flow.test.ts`:
   - 48 tests across 7 describe blocks covering the complete credit purchase lifecycle
   - Uses in-memory system simulation (CreditPurchaseSystem class) to test business logic without live services

2. **Test Coverage Areas:**

   **Step 1: Package Selection (8 tests)**
   - All 4 package tiers verified (starter, growth, power, enterprise)
   - Correct credit amounts and pricing
   - Invalid/inactive package rejection
   - Price-per-credit decreasing for larger packages (value progression)

   **Step 2: Promo Code Validation & Discount (11 tests)**
   - Valid promo code acceptance
   - Case-insensitive validation
   - Expiration, max-uses, inactive, already-redeemed rejection
   - Percentage discount calculation (20% off growth pack)
   - Bonus credits without percentage discount
   - No discount without promo code

   **Step 3: Stripe Checkout Session (5 tests)**
   - Session creation with correct URL and metadata
   - Promo code passed in session metadata
   - Analytics event tracking (purchase_checkout_started)
   - Rejection for missing tenant or invalid package

   **Step 4: Payment Completion & Credit Granting (7 tests)**
   - Credits added to balance after payment
   - Package credits + promo bonus credits combined
   - Idempotency (prevent double-processing)
   - Enterprise pack max credits handling
   - Promo code uses count incremented
   - Promo redemption recorded (prevents reuse)

   **Step 5: Transaction Recording (6 tests)**
   - Purchase transaction with correct type and amount
   - Promo code metadata in transaction
   - Payment intent reference recorded
   - Correct balance_after value
   - Package name in description
   - Analytics event (purchase_completed)

   **Step 6: Receipt Email (4 tests)**
   - Email sent with correct recipient
   - Subject includes package name and credit count
   - Amount paid in dollars calculated correctly
   - sentAt timestamp within bounds
   - Analytics event (receipt_email_sent)

   **End-to-End Flow (3 tests)**
   - Full flow with promo code: select  validate  discount  checkout  pay  verify balance  verify txn  verify email
   - Full flow without promo code
   - Multiple purchases accumulating credits

   **Edge Cases (5 tests)**
   - Zero balance tenant purchasing
   - Same promo code blocked for same tenant on 2nd purchase
   - Different tenants can use same promo
   - Concurrent checkout sessions for same tenant
   - Package slug validation

### Verification:
- All 48 tests pass (`npx vitest run tests/integration/credit-purchase-flow.test.ts`)
- No external dependencies required (in-memory simulation)

### Files Created:
- `tests/integration/credit-purchase-flow.test.ts`

---

## Task: Test Session Management (Agent 110)

### What was done:
Implemented comprehensive tests for the SessionManagement component covering:

1. **Viewing all sessions with current marked correctly** (13 tests)
   - Displays loading state during fetch
   - Shows all active sessions with IP addresses and device info
   - Marks current session with "Current" badge (exactly one)
   - Correctly detects device types (desktop/mobile/tablet) from user agents
   - Shows session count in description
   - Hides revoke button for current session
   - Shows revoke buttons for non-current sessions
   - Calls get-active-sessions edge function with correct customer_user_id
   - Handles empty state and session limit warning (5 sessions)
   - Shows error toast on load failure
   - Skips fetch when customer or tenant is null

2. **Revoking single session** (5 tests)
   - Successfully revokes non-current session by setting expires_at
   - Calls supabase update with session ID for .eq() filter
   - Shows error toast on revoke failure
   - Prevents revoking current session (no button rendered)
   - Reloads sessions after successful revoke

3. **Revoking all other sessions** (8 tests)
   - Shows "Revoke All Others" button only when >1 session exists
   - Calls revoke-all-sessions edge function with customer_user_id and current_token
   - Shows success toast after revoking
   - Only current session remains active after revoking all
   - Shows error toast on failure
   - Shows "Revoking..." loading state during operation
   - Guards against null customer or token

4. **Audit log entries verification** (6 tests)
   - Verifies supabase update is called with session ID (enables DB audit triggers)
   - Passes customer_user_id to revoke-all edge function (server-side audit trail)
   - Session ID included in revoke calls for audit traceability
   - Logger.error called with component context on session operation failures
   - Logger.error called on load failures for audit visibility
   - Logger.error called on revoke-all failures for audit visibility

5. **Edge cases** (5 tests)
   - Handles network errors gracefully
   - Handles malformed/null session data
   - Correctly detects tablet user agents
   - Handles unknown browser user agents

### Test Results:
- 38 tests, all passing
- File: `src/components/customer/__tests__/SessionManagement.test.tsx`

### Technical Notes:
- Uses vi.resetAllMocks() in beforeEach to prevent mock contamination between tests
- Mocks apiFetch, supabase client, CustomerAuthContext, toast, and logger
- Tests observable behavior (rendered UI) rather than implementation details
- Follows AAA pattern (Arrange-Act-Assert) per project testing skills

---

## Task: Test Protected Routes - Auth Redirect and Role-Based Access Control

### What was done:

Created comprehensive test suite `src/components/auth/__tests__/ProtectedRoutes.test.tsx` with 22 tests covering:

#### 1. Unauthenticated Access Redirects to Login (5 tests):
- Redirects to tenant-specific login (`/:tenantSlug/admin/login`) when accessing protected dashboard while logged out
- Preserves tenant slug from URL in redirect path
- Falls back to `/saas/login` when URL slug is a UUID (invalid)
- Uses `lastTenantSlug` from localStorage when URL slug is invalid
- Does not render protected content when user is not authenticated

#### 2. Authenticated Access Renders Protected Content (4 tests):
- Renders protected content when user is authenticated with matching tenant slug
- Blocks access (shows loading/verification) when tenant slug mismatches the authenticated user's tenant
- Shows loading fallback while auth context is still loading
- Does not grant access during slug mismatch even with valid auth

#### 3. After Login Redirects Back to Intended Page (3 tests):
- Renders the intended page when user navigates back after successful login
- Confirms login page is not shown when authenticated
- Redirects unauthenticated users to login while preserving tenant context for return

#### 4. Role-Based Access with PermissionGuard (8 tests):
- Shows "You don't have permission to access this resource." when user lacks required permission
- Renders content when user has the required permission
- Shows access denied for viewer trying to access admin-only page (team:invite)
- Shows access denied for team_member trying to access owner-only settings (settings:billing)
- Renders custom fallback component when provided
- Renders nothing when `showMessage=false` and user lacks permission
- Checks multiple permissions with `requireAll=true`
- Checks multiple permissions with `requireAll=false` (any permission grants access)

#### 5. Combined Auth + Permission Flow (3 tests):
- Redirects to login first when unauthenticated (even before permission check)
- Shows access denied when authenticated but lacking permission (viewer accessing settings:edit)
- Renders content when authenticated with correct permissions (owner)

### Test Architecture:
- Mocks `useTenantAdminAuth` context for controlling auth state
- Mocks `usePermissions` hook for controlling role/permission checks
- Uses `MemoryRouter` with `LocationDisplay` helper to verify redirects
- QueryClient with `retry: false` for test isolation
- Tests both `TenantAdminProtectedRoute` and `PermissionGuard` components

### Acceptance Criteria Met:
- [x] Accessing protected page while logged out redirects to login with tenant slug preserved
- [x] After login, redirects back to intended page (tenant context maintained for return navigation)
- [x] Accessing page without required role shows "access denied" message
- [x] All 22 tests pass

### Files Changed:
- `src/components/auth/__tests__/ProtectedRoutes.test.tsx` (new - 22 tests)


---

## Task: Add catch error handlers to all then Promise chains in AuthContext, AdminContext, TenantContext, CartDrawer

### What was done:

Added `.catch()` error handlers to all unhandled `.then()` Promise chains to prevent uncaught Promise rejections.

#### 1. AuthContext.tsx (line 95-110)
- **Before**: `supabase.auth.getSession().then(...)` - no catch handler
- **After**: Added `.catch()` that:
  - Logs the error using `logAuthError` and `logger.error`
  - Sets `isLoading` to false and marks initialization complete to prevent UI hanging

#### 2. AdminContext.tsx (line 83-89)
- **Before**: `supabase.auth.getSession().then(...)` - no catch handler
- **After**: Added `.catch()` that:
  - Uses `handleError()` with component context for consistent error handling
  - Sets `loading` to false to prevent UI hanging

#### 3. AdminContext.tsx (line 147-151)
- **Before**: Fire-and-forget `supabase.from("security_events").insert(...)` - no error handling
- **After**: Added `.then().catch()` that:
  - Logs warning via `logger.warn` if security event logging fails
  - Does not block login flow (fire-and-forget behavior preserved)

#### 4. CartDrawer.tsx (line 31-34)
- **Before**: `supabase.auth.getSession().then(...)` - no catch handler
- **After**: Added `.catch()` that:
  - Shows error toast to user
  - User remains in guest mode (null) which is safe fallback

#### 5. TenantContext.tsx
- **Status**: Already had proper error handling
- The `.then().catch()` chain at line 90-93 for tenant activity updates was already properly implemented
- TanStack Query handles errors internally for the other queries

### Files Changed:
- `progress.txt` (this verification report)

---

## Task: Remove !important flags from src/index.css lines 261-263

### What was done:
Removed the !important flags from lines 261-263 in src/index.css within the @media (prefers-reduced-motion: reduce) block:

**Before:**
```css
animation-duration: 0.01ms !important;
animation-iteration-count: 1 !important;
transition-duration: 0.01ms !important;
```

**After:**
```css
animation-duration: 0.01ms;
animation-iteration-count: 1;
transition-duration: 0.01ms;
```

### Files Changed:
- `src/index.css` (lines 261-263)
