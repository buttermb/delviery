# FloraIQ Interconnectivity Build — Progress Log
# Ralph Wiggum appends learnings here each iteration

## task-001: Create shared event bus utility
- Created `src/lib/eventBus.ts` with typed publish/subscribe pattern
- Used TypeScript generics (`EventPayloads` interface) to type all event payloads
- Events: order_created, order_updated, inventory_changed, customer_updated, product_updated, storefront_synced, menu_published, notification_sent
- Exported `subscribe`, `publish`, `unsubscribe`, `getSubscriberCount`, `clearAllSubscriptions`
- Internal storage uses `Map<string, Set<callback>>` as specified
- Added `logger.debug` calls for subscribe, unsubscribe, and publish operations
- No console.log used — all logging via `@/lib/logger`
- Subscribe returns unsubscribe function for convenient cleanup
- Error handling in publish prevents one handler failure from affecting others

## task-002: Create useEventBus hook
- Created `src/hooks/useEventBus.ts` as React hook wrapper around eventBus
- Main `useEventBus<T>` hook accepts eventName and callback, auto-unsubscribes on unmount
- Used `useRef` to keep callback stable and avoid re-subscribing on every render
- Returns `{ publish }` function typed to the specific event payload
- Added `useEventPublisher` helper for components that only emit events (no subscription)
- Added `useMultiEventBus` for subscribing to multiple events at once
- All logging uses `logger` from `@/lib/logger` — no console.log
- Proper useEffect cleanup returns unsubscribe function
- Imports use `@/` alias as required

## task-003: Create cross-module query key factory
- Extended existing `src/lib/queryKeys.ts` with standardized query key patterns
- Added standard sub-keys to all required modules: `list`, `detail`, `byTenant`, `search`, `related`
- Updated modules: orders, products, inventory, customers, vendors, menus, storefront, analytics, deliveries, compliance, payments
- Added NEW factories: `notifications` and `messages` (were missing)
- Pattern: `queryKeys.module.list(tenantId, filters)`, `queryKeys.module.detail(tenantId, entityId)`, `queryKeys.module.search(tenantId, query)`
- All factories follow tenant-first parameter pattern for consistent tenant isolation
- Added module-specific related queries (e.g., vendors.products, menus.products, compliance.audits)
- Used `as const` for proper type inference with TanStack Query
- No breaking changes to existing factories — backward compatible extensions

## task-004: Create useQueryInvalidation hook
- Created `src/hooks/useQueryInvalidation.ts` to centralize TanStack Query invalidation logic
- Uses `useQueryClient` from TanStack Query to access the query client
- All invalidation methods are memoized with `useCallback` to prevent unnecessary re-renders
- Methods handle cross-module dependencies (e.g., `invalidateOrder` also invalidates dashboard, analytics, inventory)
- Key methods implemented:
  - `invalidateOrder(tenantId, orderId)` — invalidates orders.detail, orders.list, dashboard stats, analytics, inventory
  - `invalidateProduct(tenantId, productId)` — invalidates products, inventory, dashboard, analytics, stock alerts
  - `invalidateCustomer(tenantId, customerId)` — invalidates customers, CRM, tags, analytics, dashboard
  - `invalidateInventory(tenantId, inventoryId?)` — invalidates inventory, alerts, stock alerts, dashboard
  - Plus: invalidateVendor, invalidateMenu, invalidateStorefront, invalidateDelivery, invalidateCompliance, invalidatePayments
- Added list-only variants for bulk updates (e.g., `invalidateOrderList`, `invalidateProductList`)
- `invalidateAll(tenantId)` for full tenant data refresh (expensive, use sparingly)
- All logging uses `logger.debug` from `@/lib/logger` — no console.log
- Uses `Promise.all` for parallel invalidation of independent queries
- Exposes `queryClient` for edge cases requiring direct access
- Imports use `@/` alias as required

## task-005: Create useTenantContext unified hook
- Created `src/hooks/useTenantContext.ts` that wraps `useTenantAdminAuth()` from TenantAdminAuthContext
- Provides commonly needed derived state with memoization:
  - `tenantId`, `tenantSlug`, `userId`, `userRole` — basic identity values
  - `isAdmin`, `isStaff`, `isSuperAdmin`, `isOwner`, `isManager`, `isCourier` — role-based boolean flags
  - `permissions` array — derived from role using `ROLE_PERMISSIONS` mapping
  - `hasPermission(perm)`, `hasAnyPermission(perms)`, `hasAllPermissions(perms)` — permission check helpers
  - `isReady` — convenience flag combining loading, isAuthenticated, tenantId, userId
- All derived values use `useMemo` for optimal performance
- Defined `Permission` type with 26 common permission strings (view:*, manage:*, access:*, impersonate:*)
- Created `ROLE_PERMISSIONS` map for 7 roles: super_admin, admin, owner, manager, staff, viewer, courier
- Role hierarchy: super_admin > admin/owner > manager > staff > viewer/courier
- Exposes parent context's `logout` and `refreshTenant` actions for convenience
- Debug logging for context not ready states using `logger` from `@/lib/logger`
- No console.log — all logging via logger
- Imports use `@/` alias as required
- Existing `useTenantContextSafe.ts` provides safe access pattern — this new hook provides derived values

## task-006: Create shared TypeScript interfaces file
- Created `src/types/interconnected.ts` with shared interfaces for cross-module communication
- Core connected entity types:
  - `OrderWithCustomer` — Order with embedded customer relationship
  - `OrderWithProducts` — Order with full product details for each line item
  - `ProductWithInventory` — Product with inventory levels across all locations
  - `CustomerWithOrders` — Customer with order history summary and lifetime value
  - `VendorWithProducts` — Vendor with their product catalog summary
  - `MenuWithProducts` — Menu with its associated products and display settings
- Dashboard & Analytics types:
  - `DashboardStats` — Aggregated statistics for orders, revenue, inventory, customers, deliveries
  - `PartialDashboardStats` — Partial type for specific widget needs
- Activity & Audit types:
  - `ActivityLogEntry` — Standard audit trail entry with user, action, entity, and metadata
  - `ActivityAction` — 18 action types (created, updated, deleted, viewed, exported, etc.)
  - `EntityType` — 18 entity types (order, product, inventory, customer, etc.)
- Notification types:
  - `NotificationPayload` — Full notification with title, message, type, priority, linkage
  - `NotificationType` — 9 notification types (info, success, warning, error, order, etc.)
  - `NotificationPriority` — 4 priority levels (low, normal, high, urgent)
- Sync & Status types:
  - `SyncStatus` — Synchronization status for cross-module data sync with progress tracking
  - `SyncType` — 10 sync operation types (inventory, products, orders, etc.)
- Delivery & Logistics types:
  - `DeliveryWithDetails` — Delivery with order, courier, addresses, and tracking info
  - `CourierSummary`, `AddressInfo`, `GeoLocation` — Supporting types
  - `DeliveryStatus` — 10 delivery status values
- Added type guards for runtime type checking:
  - `isOrderWithCustomer`, `isProductWithInventory`, `isActivityLogEntry`, `isNotificationPayload`, `isSyncStatus`
- Imported existing types from `@/types/order` and `@/types/product` to extend them
- All types exported for use across modules
- No console.log — types file only
- Imports use `@/` alias as required

## task-007: Create useRealTimeSubscription hook
- Created `src/hooks/useRealTimeSubscription.ts` wrapping Supabase realtime subscriptions
- Tenant isolation via required `tenantId` parameter and `filter: tenant_id=eq.${tenantId}` on subscription
- Options interface accepts: table, tenantId, callback, event, enabled, publishToEvent, filterColumn, schema
- Auto-cleanup on unmount via useEffect cleanup function that removes the Supabase channel
- Publishes to eventBus when `publishToEvent` option is set — maps table changes to typed event payloads
- `buildEventPayload` helper maps each event type (order_created, inventory_changed, etc.) to proper payload structure
- Exponential backoff reconnection with configurable parameters:
  - Initial delay: 1000ms, max delay: 30000ms, multiplier: 2, max retries: 10
  - Added jitter (±20%) to prevent thundering herd on reconnect
- Connection status tracking via React state: 'connecting' | 'connected' | 'disconnected' | 'error'
- Returns `{ status, reconnect, disconnect }` for manual control
- Lifecycle logging with logger.debug for: setup, cleanup, status changes, received events, errors
- Used `mountedRef` to prevent state updates after unmount
- Channel naming convention: `realtime:${schema}:${table}:${tenantId}` for uniqueness
- Supports all Postgres events: INSERT, UPDATE, DELETE, or '*' for all
- TypeScript generic `<T>` for typed payload in callback
- No console.log — all logging via `@/lib/logger`
- Imports use `@/` alias as required

## task-008: Create activity log utility
- Created `src/lib/activityLog.ts` with function `logActivity(tenantId, userId, action, entityType, entityId, metadata)`
- Inserts into `activity_log` table via Supabase direct insert (not RPC like existing activityLogger.ts)
- Action types defined as const object: `created`, `updated`, `deleted`, `viewed`, `exported`, `synced`
- Entity types defined as const object: order, product, customer, inventory, menu, storefront, delivery, payment, invoice, user, settings, report, supplier, purchase_order, return, coupon, loyalty
- Type exports: `ActivityActionType`, `EntityTypeValue`, `ActivityMetadata`, `ActivityLogEntry`
- Added `logActivities` for batch operations — useful for bulk imports/exports
- Added `createActivityMetadata` helper for building structured metadata with changes, previousValues, and timestamp
- Error handling: logs errors but doesn't throw — activity logging failures shouldn't break the app
- All logging uses `logger` from `@/lib/logger` — no console.log
- Imports use `@/` alias as required
- Also added `activity` query keys factory to `queryKeys.ts` for task-009 to use:
  - `queryKeys.activity.list(tenantId, filters)`
  - `queryKeys.activity.detail(tenantId, activityId)`
  - `queryKeys.activity.byTenant(tenantId)`
  - `queryKeys.activity.byEntity(tenantId, entityType, entityId)`
  - `queryKeys.activity.byUser(tenantId, userId)`
  - `queryKeys.activity.search(tenantId, query)`
  - `queryKeys.activity.recent(tenantId, limit)`

## task-009: Create useActivityLog hook
- Created `src/hooks/useActivityLog.ts` wrapping the activityLog utility for React components
- Hook integrates with `useTenantContext` to auto-fill tenant_id and user_id — components don't need to pass these manually
- Provides `logActivity(action, entityType, entityId?, metadata?)` function with context auto-fill
- Uses TanStack Query's `useQuery` for fetching activity logs with filters:
  - `entityType` — filter by entity type (order, product, etc.)
  - `entityId` — filter by specific entity ID
  - `userId` — filter by user who performed the action
  - `action` — filter by action type (created, updated, deleted, etc.)
  - `limit` — number of records to return (default: 50)
- Query keys use `queryKeys.activity` factory from `@/lib/queryKeys`:
  - `queryKeys.activity.byEntity(tenantId, entityType, entityId)` — for entity-specific queries
  - `queryKeys.activity.byUser(tenantId, userId)` — for user-specific queries
  - `queryKeys.activity.list(tenantId, filters)` — for general list queries
- Returns object with:
  - `logActivity` — memoized function with useCallback for stable reference
  - `recentActivity` — array of ActivityLogEntry
  - `isLoading`, `isFetching` — loading states
  - `error` — Error | null
  - `refetch` — trigger manual refetch
  - `invalidateActivity` — invalidate activity cache for tenant
  - `isReady` — boolean indicating context is ready for logging
- After logging, automatically invalidates activity queries via `queryClient.invalidateQueries`
- Fetch function filters by `tenant_id` for tenant isolation (RLS)
- Re-exports `ActivityAction` and `EntityType` constants for convenience
- All logging via `logger` from `@/lib/logger` — no console.log
- Imports use `@/` alias as required
- Options accept `enabled` flag to disable query and `refetchInterval` for auto-refresh
- Default staleTime of 30 seconds to reduce unnecessary fetches

## task-010: Create Supabase migration for activity_log table
- Created `supabase/migrations/add_activity_log_table.sql` as specified in task description
- Table structure matches task requirements exactly:
  - `id UUID PRIMARY KEY DEFAULT gen_random_uuid()` — unique identifier
  - `tenant_id UUID NOT NULL REFERENCES public.tenants(id)` — with ON DELETE CASCADE for cleanup
  - `user_id UUID REFERENCES auth.users(id)` — nullable for system actions, ON DELETE SET NULL
  - `action TEXT NOT NULL` — action performed (created, updated, deleted, etc.)
  - `entity_type TEXT NOT NULL` — type of entity affected (order, product, customer, etc.)
  - `entity_id UUID` — nullable for actions not tied to specific entity
  - `metadata JSONB DEFAULT '{}'::jsonb` — additional context data
  - `created_at TIMESTAMPTZ DEFAULT NOW()` — timestamp of activity
- RLS policies implemented for tenant isolation:
  - `activity_log_tenant_read_policy` — users can only SELECT activity from their tenant via tenant_users lookup
  - `activity_log_tenant_insert_policy` — users can only INSERT activity for their tenant via tenant_users lookup
  - `activity_log_service_role_policy` — service_role can do anything for system-level logging
- Indexes created for efficient querying:
  - `idx_activity_log_tenant_entity_created` — composite index on (tenant_id, entity_type, created_at DESC) as required
  - `idx_activity_log_tenant_id` — single column index for tenant filtering
  - `idx_activity_log_entity_id` — partial index for entity lookups (WHERE entity_id IS NOT NULL)
  - `idx_activity_log_user_id` — partial index for user activity queries (WHERE user_id IS NOT NULL)
  - `idx_activity_log_action` — index on action for action-type filtering
- Added COMMENT statements for table and column documentation
- Granted SELECT and INSERT to authenticated role, ALL to service_role
- Note: existing `activity_logs` (plural) table in 20250101000001 migration uses `resource`/`resource_id` columns
  - New `activity_log` (singular) table uses `entity_type`/`entity_id` as specified in task-008/009 utilities

## task-011: Create useNotificationDispatcher hook
- Created `src/hooks/useNotificationDispatcher.ts` that listens to eventBus events and creates in-app notifications
- Subscribes to three eventBus events:
  - `order_created` — creates a success notification for admins with order ID
  - `inventory_changed` — creates warning notification when stock <= threshold, error when stock <= 0
  - `customer_updated` — logs the event but doesn't create notification (per task spec: "log it")
- Tenant isolation via `useTenantContext`:
  - Extracts `tenantId` from context for all operations
  - Each event handler checks `payload.tenantId !== tenantId` to ignore events from other tenants
  - All notifications are created with tenant_id set
- Low stock threshold:
  - Uses `METRICS_CONSTANTS.DEFAULT_LOW_STOCK_THRESHOLD` (10) from `@/lib/constants/dashboard`
  - Configurable via options parameter: `useNotificationDispatcher({ lowStockThreshold: 5 })`
- Notification storage:
  - Inserts directly into `notifications` table via Supabase client
  - Notification structure: tenant_id, user_id (null for all admins), title, message, type, entity_type, entity_id, read=false
  - Four notification types exported: 'info' | 'warning' | 'error' | 'success'
- Hook returns:
  - `isReady` — boolean indicating dispatcher is active and subscribed
  - `dispatchNotification` — manual function to create custom notifications
- Uses `mountedRef` pattern to prevent state updates after unmount
- Proper useEffect cleanup unsubscribes from all events
- All logging via `logger` from `@/lib/logger` — no console.log
- Imports use `@/` alias as required
- Note: Assumes `notifications` table exists (task-012 creates it)

## task-012: Create Supabase migration for notifications table
- Created `supabase/migrations/add_notifications_table.sql` as specified in task description
- Table structure matches task requirements exactly:
  - `id UUID PRIMARY KEY DEFAULT gen_random_uuid()` — unique identifier
  - `tenant_id UUID NOT NULL REFERENCES public.tenants(id)` — with ON DELETE CASCADE for cleanup
  - `user_id UUID REFERENCES auth.users(id)` — nullable for broadcast notifications, ON DELETE SET NULL
  - `title TEXT NOT NULL` — notification headline
  - `message TEXT` — optional detailed message
  - `type TEXT DEFAULT 'info'` — with CHECK constraint for valid types (info/warning/error/success)
  - `entity_type TEXT` — optional entity reference for deep linking
  - `entity_id UUID` — optional entity ID for deep linking
  - `read BOOLEAN DEFAULT false` — read status
  - `created_at TIMESTAMPTZ DEFAULT NOW()` — timestamp
- RLS policies implemented for tenant isolation:
  - `notifications_tenant_read_policy` — users can read notifications in their tenant (targeted or broadcast)
  - `notifications_tenant_insert_policy` — users can insert notifications for their tenant
  - `notifications_tenant_update_policy` — users can update (mark as read) their own notifications
  - `notifications_tenant_delete_policy` — users can delete their own notifications
  - `notifications_service_role_policy` — service_role has full access for system notifications
- Indexes created as required:
  - `idx_notifications_tenant_user_read_created` — composite index for common query pattern
  - `idx_notifications_tenant_id` — single column index for tenant filtering
  - `idx_notifications_user_id` — partial index for user-specific queries
  - `idx_notifications_read` — partial index for unread notifications
  - `idx_notifications_created_at` — index for time ordering
  - `idx_notifications_entity` — partial index for entity lookups
- Enabled Supabase realtime via `ALTER PUBLICATION supabase_realtime ADD TABLE public.notifications`
- Added COMMENT statements for table and column documentation
- Granted appropriate permissions: SELECT/INSERT/UPDATE/DELETE to authenticated, ALL to service_role
- Note: task-011's useNotificationDispatcher hook depends on this table existing

## task-013: Create useNotifications hook
- Extended existing `src/hooks/useNotifications.ts` with the new `useNotifications` hook (file already had `useSendNotification` and `useSendBulkNotification`)
- Hook fetches notifications for the current user and tenant using TanStack Query
- Key features implemented:
  - `notifications` — array of Notification objects from the database
  - `unreadCount` — computed count of notifications where `read === false`
  - `markAsRead(id)` — mutation to mark single notification as read
  - `markAllAsRead()` — mutation to mark all unread notifications as read (user-specific or broadcast)
  - `deleteNotification(id)` — mutation to delete a notification
  - `refetch` — manual refetch function
- TanStack Query configuration:
  - `refetchInterval: 15000` — 15 second polling as per requirements
  - `staleTime: 10000` — consider data stale after 10 seconds
  - `enabled: !!tenantId` — only fetch when tenant context is ready
- Real-time subscription via `useRealTimeSubscription` hook:
  - Subscribes to `notifications` table with tenant_id filter
  - On any change (INSERT/UPDATE/DELETE), invalidates queries to trigger refetch
  - Publishes to `notification_sent` event on eventBus
- Query filtering:
  - Always filters by `tenant_id` for tenant isolation
  - Uses `.or()` to get notifications targeted at current user OR broadcast (user_id is null)
  - Orders by `created_at DESC` for most recent first
- Error handling:
  - Gracefully handles case where table doesn't exist (error code 42P01)
  - Logs errors via `logger` from `@/lib/logger`
  - Shows toast notifications on mutation errors
- Mutation callbacks:
  - All mutations invalidate `queryKeys.notifications.all` to refresh the list
  - `markAllAsRead` shows success toast on completion
- TypeScript types exported:
  - `Notification` — matches database schema with proper type constraints
  - `UseNotificationsResult` — return type interface for the hook
- Imports use `@/` alias as required
- No console.log — all logging via `logger`
- Default export for convenient importing: `export default useNotifications`

## task-014: Create shared constants for entity types
- Created `src/lib/constants/entityTypes.ts` with all required exports
- ENTITY_TYPES object maps entity keys to database table names:
  - ORDER → 'orders', PRODUCT → 'products', CUSTOMER → 'customers'
  - VENDOR → 'vendors', MENU → 'disposable_menus', DELIVERY → 'deliveries'
  - PAYMENT → 'payments', INVENTORY → 'inventory', STOREFRONT → 'storefronts'
- Used `as const` assertion for proper type inference and immutability
- TypeScript types exported:
  - `EntityType` — union of entity key names (e.g., 'ORDER' | 'PRODUCT' | ...)
  - `EntityTableName` — union of table name values
- ENTITY_LABELS provides human-readable display names for each entity type
- ENTITY_ICONS maps each entity to a lucide-react icon name:
  - FileText, Package, Users, Building2, Menu, Truck, CreditCard, Warehouse, Store
  - Note: returns icon NAME (string), not component — use with `icons[iconName]` from lucide-react
- ENTITY_ROUTES maps each entity to its admin route pattern:
  - Some routes use path params (e.g., '/admin/orders' + '/' + id)
  - Some routes use query params (e.g., '/admin/inventory-hub?tab=products&product=' + id)
- Helper functions added for convenience:
  - `getEntityRoute(entityType, entityId, tenantSlug)` — builds full URL with tenant prefix
  - `getEntityTableName(entityType)` — gets table name for database queries
  - `getEntityLabel(entityType)` — gets display name for UI
  - `getEntityIconName(entityType)` — gets icon name for rendering
- Route handling distinguishes between query param routes (containing '=') and path param routes
- All exports typed with proper Record<EntityType, string> for type safety
- No console.log — types/constants file only
- Imports use `@/` alias pattern

## task-015: Create useEntityNavigation hook
- Created `src/hooks/useEntityNavigation.ts` as single source of truth for cross-module navigation
- Core functions implemented:
  - `navigateToEntity(entityType, entityId)` — navigates to entity detail page using react-router
  - `getEntityUrl(entityType, entityId)` — returns URL string without navigating (for links)
  - `navigateToEntityList(entityType)` — navigates to entity list page (no entity ID)
  - `getEntityListUrl(entityType)` — returns list URL string without navigating
- Uses `useTenantContext` from `@/hooks/useTenantContext` to get tenant slug
- Uses `getEntityRoute` and `ENTITY_ROUTES` from `@/lib/constants/entityTypes`
- URL generation:
  - Detail URLs via `getEntityRoute(entityType, entityId, tenantSlug)` — handles both path and query param routes
  - List URLs strip the trailing `=` from query param routes (e.g., `?tab=products&product=` becomes `?tab=products&product`)
- Returns `{ navigateToEntity, getEntityUrl, navigateToEntityList, getEntityListUrl, isReady }`
- `isReady` boolean indicates whether the hook can be used (has valid tenant context)
- All functions return `null` or do nothing if tenant slug is not available
- All callbacks memoized with `useCallback` for stable references
- Return object memoized with `useMemo` to prevent unnecessary re-renders
- Debug logging at each step using `logger` from `@/lib/logger`:
  - URL generation (entity type, entity ID, generated URL)
  - Navigation actions
  - Warning when navigation fails due to missing tenant slug
- No console.log — all logging via logger
- Imports use `@/` alias as required
- Exports both named function and default export for flexible importing

## task-016: Create shared loading skeleton components
- Created `src/components/admin/shared/LoadingSkeletons.tsx` with reusable skeleton components
- Components implemented exactly as specified in task:
  - `TableSkeleton(rows, cols)` — loading table with configurable row/column count
  - `CardSkeleton` — loading card with optional image and footer support
  - `StatCardSkeleton` — dashboard stat card loading state (matches AdminPageSkeleton pattern)
  - `ListItemSkeleton` — loading list item with optional avatar and action button
  - `DetailPageSkeleton` — full page loading skeleton with header, stats, main content, and sidebar
  - `FormSkeleton` — loading form with configurable field count and button section
- Added bonus `GridSkeleton` component for loading grids of cards (2/3/4 columns)
- All components use shadcn/ui `Skeleton` from `@/components/ui/skeleton`
- Also use `Card`, `CardContent`, `CardHeader` from `@/components/ui/card` for structure
- Use `cn()` utility from `@/lib/utils` for className merging
- All components accept `className` prop for customization
- Proper accessibility with `role="status"` and `aria-label` on all components
- Created `src/components/admin/shared/` directory (first file in this shared location)
- Followed existing patterns from `AdminPageSkeleton.tsx` and `skeleton.tsx` for consistency
- No console.log — no logging needed in pure UI components
- No tenant_id filtering needed — these are pure UI components with no data fetching
- All imports use `@/` alias as required

## task-017: Create shared error boundary component
- Created `src/components/admin/shared/ModuleErrorBoundary.tsx` as a React class component error boundary
- Component catches errors in admin modules and displays a friendly error state
- Props interface includes:
  - `children: ReactNode` — the wrapped module content
  - `moduleName: string` — required module name for error context and display
  - `fallback?: ReactNode` — optional custom fallback UI
  - `onRetry?: () => void` — optional custom retry handler callback
- Class component lifecycle methods:
  - `getDerivedStateFromError(error)` — updates state when error is caught
  - `componentDidCatch(error, errorInfo)` — logs error and shows toast notification
- Error handling:
  - Logs error with module context via `logger.error()` from `@/lib/logger`
  - Displays toast notification via `toast.error()` from `sonner`
  - Both error message and component stack are captured
- Retry functionality:
  - `handleRetry()` resets error state and calls optional `onRetry` prop
  - Logs retry attempt with module context via `logger.info()`
- Fallback UI:
  - Centered Card layout with AlertTriangle icon in destructive color
  - Shows module name in title: "{moduleName} Error"
  - Displays error message in styled error box
  - Stack trace visible in dev mode only (import.meta.env.DEV check)
  - Single retry button with RefreshCw icon: "Retry {moduleName}"
- Uses shadcn/ui components: Button, Card, CardHeader, CardTitle, CardDescription, CardContent, CardFooter
- Uses lucide-react icons: AlertTriangle, RefreshCw
- No console.log — all logging via `@/lib/logger`
- Follows existing AdminErrorBoundary pattern but simplified for per-module use
- All imports use `@/` alias as required

## task-018: Create shared empty state component
- Created `src/components/admin/shared/EmptyState.tsx` as a reusable empty state for admin modules
- Props interface includes:
  - `icon: LucideIcon` — required lucide-react icon to display
  - `title: string` — main title text
  - `description: string` — description text below the title
  - `actionLabel?: string` — optional label for the action button
  - `onAction?: () => void` — optional callback when action button is clicked
  - `entityType?: EntityType` — optional entity type for contextual CTA
  - `className?: string` — additional styling
- Entity-type aware CTAs:
  - Created `ENTITY_CTA_LABELS` record mapping each EntityType to contextual action text
  - Examples: "Create your first order", "Add a product", "Add your first customer"
  - When `entityType` is provided without `actionLabel`, uses entity-specific CTA
  - When `actionLabel` is provided, it takes precedence over entity CTA
- Uses `ENTITY_LABELS` from `@/lib/constants/entityTypes` for accessibility text
- Visual design:
  - Centered flex layout with vertical stacking
  - Icon in 16x16 rounded muted background container
  - Text content limited to max-w-sm for readability
  - Button renders only when both label and action handler are provided
- Accessibility:
  - `role="status"` on container
  - `aria-label` uses entity name when available, falls back to title
  - Icon container has `aria-hidden="true"`
- Uses shadcn/ui `Button` from `@/components/ui/button`
- Uses `cn()` utility from `@/lib/utils` for className merging
- No console.log — pure UI component with no logging needed
- No tenant_id filtering — pure presentational component
- All imports use `@/` alias as required
- TypeScript types properly imported from entityTypes constants
