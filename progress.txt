# FloraIQ Interconnectivity Build — Progress Log
# Ralph Wiggum appends learnings here each iteration

## task-001: Create shared event bus utility
- Created `src/lib/eventBus.ts` with typed publish/subscribe pattern
- Used TypeScript generics (`EventPayloads` interface) to type all event payloads
- Events: order_created, order_updated, inventory_changed, customer_updated, product_updated, storefront_synced, menu_published, notification_sent
- Exported `subscribe`, `publish`, `unsubscribe`, `getSubscriberCount`, `clearAllSubscriptions`
- Internal storage uses `Map<string, Set<callback>>` as specified
- Added `logger.debug` calls for subscribe, unsubscribe, and publish operations
- No console.log used — all logging via `@/lib/logger`
- Subscribe returns unsubscribe function for convenient cleanup
- Error handling in publish prevents one handler failure from affecting others

## task-002: Create useEventBus hook
- Created `src/hooks/useEventBus.ts` as React hook wrapper around eventBus
- Main `useEventBus<T>` hook accepts eventName and callback, auto-unsubscribes on unmount
- Used `useRef` to keep callback stable and avoid re-subscribing on every render
- Returns `{ publish }` function typed to the specific event payload
- Added `useEventPublisher` helper for components that only emit events (no subscription)
- Added `useMultiEventBus` for subscribing to multiple events at once
- All logging uses `logger` from `@/lib/logger` — no console.log
- Proper useEffect cleanup returns unsubscribe function
- Imports use `@/` alias as required

## task-003: Create cross-module query key factory
- Extended existing `src/lib/queryKeys.ts` with standardized query key patterns
- Added standard sub-keys to all required modules: `list`, `detail`, `byTenant`, `search`, `related`
- Updated modules: orders, products, inventory, customers, vendors, menus, storefront, analytics, deliveries, compliance, payments
- Added NEW factories: `notifications` and `messages` (were missing)
- Pattern: `queryKeys.module.list(tenantId, filters)`, `queryKeys.module.detail(tenantId, entityId)`, `queryKeys.module.search(tenantId, query)`
- All factories follow tenant-first parameter pattern for consistent tenant isolation
- Added module-specific related queries (e.g., vendors.products, menus.products, compliance.audits)
- Used `as const` for proper type inference with TanStack Query
- No breaking changes to existing factories — backward compatible extensions

## task-004: Create useQueryInvalidation hook
- Created `src/hooks/useQueryInvalidation.ts` to centralize TanStack Query invalidation logic
- Uses `useQueryClient` from TanStack Query to access the query client
- All invalidation methods are memoized with `useCallback` to prevent unnecessary re-renders
- Methods handle cross-module dependencies (e.g., `invalidateOrder` also invalidates dashboard, analytics, inventory)
- Key methods implemented:
  - `invalidateOrder(tenantId, orderId)` — invalidates orders.detail, orders.list, dashboard stats, analytics, inventory
  - `invalidateProduct(tenantId, productId)` — invalidates products, inventory, dashboard, analytics, stock alerts
  - `invalidateCustomer(tenantId, customerId)` — invalidates customers, CRM, tags, analytics, dashboard
  - `invalidateInventory(tenantId, inventoryId?)` — invalidates inventory, alerts, stock alerts, dashboard
  - Plus: invalidateVendor, invalidateMenu, invalidateStorefront, invalidateDelivery, invalidateCompliance, invalidatePayments
- Added list-only variants for bulk updates (e.g., `invalidateOrderList`, `invalidateProductList`)
- `invalidateAll(tenantId)` for full tenant data refresh (expensive, use sparingly)
- All logging uses `logger.debug` from `@/lib/logger` — no console.log
- Uses `Promise.all` for parallel invalidation of independent queries
- Exposes `queryClient` for edge cases requiring direct access
- Imports use `@/` alias as required

## task-005: Create useTenantContext unified hook
- Created `src/hooks/useTenantContext.ts` that wraps `useTenantAdminAuth()` from TenantAdminAuthContext
- Provides commonly needed derived state with memoization:
  - `tenantId`, `tenantSlug`, `userId`, `userRole` — basic identity values
  - `isAdmin`, `isStaff`, `isSuperAdmin`, `isOwner`, `isManager`, `isCourier` — role-based boolean flags
  - `permissions` array — derived from role using `ROLE_PERMISSIONS` mapping
  - `hasPermission(perm)`, `hasAnyPermission(perms)`, `hasAllPermissions(perms)` — permission check helpers
  - `isReady` — convenience flag combining loading, isAuthenticated, tenantId, userId
- All derived values use `useMemo` for optimal performance
- Defined `Permission` type with 26 common permission strings (view:*, manage:*, access:*, impersonate:*)
- Created `ROLE_PERMISSIONS` map for 7 roles: super_admin, admin, owner, manager, staff, viewer, courier
- Role hierarchy: super_admin > admin/owner > manager > staff > viewer/courier
- Exposes parent context's `logout` and `refreshTenant` actions for convenience
- Debug logging for context not ready states using `logger` from `@/lib/logger`
- No console.log — all logging via logger
- Imports use `@/` alias as required
- Existing `useTenantContextSafe.ts` provides safe access pattern — this new hook provides derived values

## task-006: Create shared TypeScript interfaces file
- Created `src/types/interconnected.ts` with shared interfaces for cross-module communication
- Core connected entity types:
  - `OrderWithCustomer` — Order with embedded customer relationship
  - `OrderWithProducts` — Order with full product details for each line item
  - `ProductWithInventory` — Product with inventory levels across all locations
  - `CustomerWithOrders` — Customer with order history summary and lifetime value
  - `VendorWithProducts` — Vendor with their product catalog summary
  - `MenuWithProducts` — Menu with its associated products and display settings
- Dashboard & Analytics types:
  - `DashboardStats` — Aggregated statistics for orders, revenue, inventory, customers, deliveries
  - `PartialDashboardStats` — Partial type for specific widget needs
- Activity & Audit types:
  - `ActivityLogEntry` — Standard audit trail entry with user, action, entity, and metadata
  - `ActivityAction` — 18 action types (created, updated, deleted, viewed, exported, etc.)
  - `EntityType` — 18 entity types (order, product, inventory, customer, etc.)
- Notification types:
  - `NotificationPayload` — Full notification with title, message, type, priority, linkage
  - `NotificationType` — 9 notification types (info, success, warning, error, order, etc.)
  - `NotificationPriority` — 4 priority levels (low, normal, high, urgent)
- Sync & Status types:
  - `SyncStatus` — Synchronization status for cross-module data sync with progress tracking
  - `SyncType` — 10 sync operation types (inventory, products, orders, etc.)
- Delivery & Logistics types:
  - `DeliveryWithDetails` — Delivery with order, courier, addresses, and tracking info
  - `CourierSummary`, `AddressInfo`, `GeoLocation` — Supporting types
  - `DeliveryStatus` — 10 delivery status values
- Added type guards for runtime type checking:
  - `isOrderWithCustomer`, `isProductWithInventory`, `isActivityLogEntry`, `isNotificationPayload`, `isSyncStatus`
- Imported existing types from `@/types/order` and `@/types/product` to extend them
- All types exported for use across modules
- No console.log — types file only
- Imports use `@/` alias as required

## task-007: Create useRealTimeSubscription hook
- Created `src/hooks/useRealTimeSubscription.ts` wrapping Supabase realtime subscriptions
- Tenant isolation via required `tenantId` parameter and `filter: tenant_id=eq.${tenantId}` on subscription
- Options interface accepts: table, tenantId, callback, event, enabled, publishToEvent, filterColumn, schema
- Auto-cleanup on unmount via useEffect cleanup function that removes the Supabase channel
- Publishes to eventBus when `publishToEvent` option is set — maps table changes to typed event payloads
- `buildEventPayload` helper maps each event type (order_created, inventory_changed, etc.) to proper payload structure
- Exponential backoff reconnection with configurable parameters:
  - Initial delay: 1000ms, max delay: 30000ms, multiplier: 2, max retries: 10
  - Added jitter (±20%) to prevent thundering herd on reconnect
- Connection status tracking via React state: 'connecting' | 'connected' | 'disconnected' | 'error'
- Returns `{ status, reconnect, disconnect }` for manual control
- Lifecycle logging with logger.debug for: setup, cleanup, status changes, received events, errors
- Used `mountedRef` to prevent state updates after unmount
- Channel naming convention: `realtime:${schema}:${table}:${tenantId}` for uniqueness
- Supports all Postgres events: INSERT, UPDATE, DELETE, or '*' for all
- TypeScript generic `<T>` for typed payload in callback
- No console.log — all logging via `@/lib/logger`
- Imports use `@/` alias as required

## task-008: Create activity log utility
- Created `src/lib/activityLog.ts` with function `logActivity(tenantId, userId, action, entityType, entityId, metadata)`
- Inserts into `activity_log` table via Supabase direct insert (not RPC like existing activityLogger.ts)
- Action types defined as const object: `created`, `updated`, `deleted`, `viewed`, `exported`, `synced`
- Entity types defined as const object: order, product, customer, inventory, menu, storefront, delivery, payment, invoice, user, settings, report, supplier, purchase_order, return, coupon, loyalty
- Type exports: `ActivityActionType`, `EntityTypeValue`, `ActivityMetadata`, `ActivityLogEntry`
- Added `logActivities` for batch operations — useful for bulk imports/exports
- Added `createActivityMetadata` helper for building structured metadata with changes, previousValues, and timestamp
- Error handling: logs errors but doesn't throw — activity logging failures shouldn't break the app
- All logging uses `logger` from `@/lib/logger` — no console.log
- Imports use `@/` alias as required
- Also added `activity` query keys factory to `queryKeys.ts` for task-009 to use:
  - `queryKeys.activity.list(tenantId, filters)`
  - `queryKeys.activity.detail(tenantId, activityId)`
  - `queryKeys.activity.byTenant(tenantId)`
  - `queryKeys.activity.byEntity(tenantId, entityType, entityId)`
  - `queryKeys.activity.byUser(tenantId, userId)`
  - `queryKeys.activity.search(tenantId, query)`
  - `queryKeys.activity.recent(tenantId, limit)`

## task-009: Create useActivityLog hook
- Created `src/hooks/useActivityLog.ts` wrapping the activityLog utility for React components
- Hook integrates with `useTenantContext` to auto-fill tenant_id and user_id — components don't need to pass these manually
- Provides `logActivity(action, entityType, entityId?, metadata?)` function with context auto-fill
- Uses TanStack Query's `useQuery` for fetching activity logs with filters:
  - `entityType` — filter by entity type (order, product, etc.)
  - `entityId` — filter by specific entity ID
  - `userId` — filter by user who performed the action
  - `action` — filter by action type (created, updated, deleted, etc.)
  - `limit` — number of records to return (default: 50)
- Query keys use `queryKeys.activity` factory from `@/lib/queryKeys`:
  - `queryKeys.activity.byEntity(tenantId, entityType, entityId)` — for entity-specific queries
  - `queryKeys.activity.byUser(tenantId, userId)` — for user-specific queries
  - `queryKeys.activity.list(tenantId, filters)` — for general list queries
- Returns object with:
  - `logActivity` — memoized function with useCallback for stable reference
  - `recentActivity` — array of ActivityLogEntry
  - `isLoading`, `isFetching` — loading states
  - `error` — Error | null
  - `refetch` — trigger manual refetch
  - `invalidateActivity` — invalidate activity cache for tenant
  - `isReady` — boolean indicating context is ready for logging
- After logging, automatically invalidates activity queries via `queryClient.invalidateQueries`
- Fetch function filters by `tenant_id` for tenant isolation (RLS)
- Re-exports `ActivityAction` and `EntityType` constants for convenience
- All logging via `logger` from `@/lib/logger` — no console.log
- Imports use `@/` alias as required
- Options accept `enabled` flag to disable query and `refetchInterval` for auto-refresh
- Default staleTime of 30 seconds to reduce unnecessary fetches

## task-010: Create Supabase migration for activity_log table
- Created `supabase/migrations/add_activity_log_table.sql` as specified in task description
- Table structure matches task requirements exactly:
  - `id UUID PRIMARY KEY DEFAULT gen_random_uuid()` — unique identifier
  - `tenant_id UUID NOT NULL REFERENCES public.tenants(id)` — with ON DELETE CASCADE for cleanup
  - `user_id UUID REFERENCES auth.users(id)` — nullable for system actions, ON DELETE SET NULL
  - `action TEXT NOT NULL` — action performed (created, updated, deleted, etc.)
  - `entity_type TEXT NOT NULL` — type of entity affected (order, product, customer, etc.)
  - `entity_id UUID` — nullable for actions not tied to specific entity
  - `metadata JSONB DEFAULT '{}'::jsonb` — additional context data
  - `created_at TIMESTAMPTZ DEFAULT NOW()` — timestamp of activity
- RLS policies implemented for tenant isolation:
  - `activity_log_tenant_read_policy` — users can only SELECT activity from their tenant via tenant_users lookup
  - `activity_log_tenant_insert_policy` — users can only INSERT activity for their tenant via tenant_users lookup
  - `activity_log_service_role_policy` — service_role can do anything for system-level logging
- Indexes created for efficient querying:
  - `idx_activity_log_tenant_entity_created` — composite index on (tenant_id, entity_type, created_at DESC) as required
  - `idx_activity_log_tenant_id` — single column index for tenant filtering
  - `idx_activity_log_entity_id` — partial index for entity lookups (WHERE entity_id IS NOT NULL)
  - `idx_activity_log_user_id` — partial index for user activity queries (WHERE user_id IS NOT NULL)
  - `idx_activity_log_action` — index on action for action-type filtering
- Added COMMENT statements for table and column documentation
- Granted SELECT and INSERT to authenticated role, ALL to service_role
- Note: existing `activity_logs` (plural) table in 20250101000001 migration uses `resource`/`resource_id` columns
  - New `activity_log` (singular) table uses `entity_type`/`entity_id` as specified in task-008/009 utilities

## task-011: Create useNotificationDispatcher hook
- Created `src/hooks/useNotificationDispatcher.ts` that listens to eventBus events and creates in-app notifications
- Subscribes to three eventBus events:
  - `order_created` — creates a success notification for admins with order ID
  - `inventory_changed` — creates warning notification when stock <= threshold, error when stock <= 0
  - `customer_updated` — logs the event but doesn't create notification (per task spec: "log it")
- Tenant isolation via `useTenantContext`:
  - Extracts `tenantId` from context for all operations
  - Each event handler checks `payload.tenantId !== tenantId` to ignore events from other tenants
  - All notifications are created with tenant_id set
- Low stock threshold:
  - Uses `METRICS_CONSTANTS.DEFAULT_LOW_STOCK_THRESHOLD` (10) from `@/lib/constants/dashboard`
  - Configurable via options parameter: `useNotificationDispatcher({ lowStockThreshold: 5 })`
- Notification storage:
  - Inserts directly into `notifications` table via Supabase client
  - Notification structure: tenant_id, user_id (null for all admins), title, message, type, entity_type, entity_id, read=false
  - Four notification types exported: 'info' | 'warning' | 'error' | 'success'
- Hook returns:
  - `isReady` — boolean indicating dispatcher is active and subscribed
  - `dispatchNotification` — manual function to create custom notifications
- Uses `mountedRef` pattern to prevent state updates after unmount
- Proper useEffect cleanup unsubscribes from all events
- All logging via `logger` from `@/lib/logger` — no console.log
- Imports use `@/` alias as required
- Note: Assumes `notifications` table exists (task-012 creates it)

## task-012: Create Supabase migration for notifications table
- Created `supabase/migrations/add_notifications_table.sql` as specified in task description
- Table structure matches task requirements exactly:
  - `id UUID PRIMARY KEY DEFAULT gen_random_uuid()` — unique identifier
  - `tenant_id UUID NOT NULL REFERENCES public.tenants(id)` — with ON DELETE CASCADE for cleanup
  - `user_id UUID REFERENCES auth.users(id)` — nullable for broadcast notifications, ON DELETE SET NULL
  - `title TEXT NOT NULL` — notification headline
  - `message TEXT` — optional detailed message
  - `type TEXT DEFAULT 'info'` — with CHECK constraint for valid types (info/warning/error/success)
  - `entity_type TEXT` — optional entity reference for deep linking
  - `entity_id UUID` — optional entity ID for deep linking
  - `read BOOLEAN DEFAULT false` — read status
  - `created_at TIMESTAMPTZ DEFAULT NOW()` — timestamp
- RLS policies implemented for tenant isolation:
  - `notifications_tenant_read_policy` — users can read notifications in their tenant (targeted or broadcast)
  - `notifications_tenant_insert_policy` — users can insert notifications for their tenant
  - `notifications_tenant_update_policy` — users can update (mark as read) their own notifications
  - `notifications_tenant_delete_policy` — users can delete their own notifications
  - `notifications_service_role_policy` — service_role has full access for system notifications
- Indexes created as required:
  - `idx_notifications_tenant_user_read_created` — composite index for common query pattern
  - `idx_notifications_tenant_id` — single column index for tenant filtering
  - `idx_notifications_user_id` — partial index for user-specific queries
  - `idx_notifications_read` — partial index for unread notifications
  - `idx_notifications_created_at` — index for time ordering
  - `idx_notifications_entity` — partial index for entity lookups
- Enabled Supabase realtime via `ALTER PUBLICATION supabase_realtime ADD TABLE public.notifications`
- Added COMMENT statements for table and column documentation
- Granted appropriate permissions: SELECT/INSERT/UPDATE/DELETE to authenticated, ALL to service_role
- Note: task-011's useNotificationDispatcher hook depends on this table existing

## task-013: Create useNotifications hook
- Extended existing `src/hooks/useNotifications.ts` with the new `useNotifications` hook (file already had `useSendNotification` and `useSendBulkNotification`)
- Hook fetches notifications for the current user and tenant using TanStack Query
- Key features implemented:
  - `notifications` — array of Notification objects from the database
  - `unreadCount` — computed count of notifications where `read === false`
  - `markAsRead(id)` — mutation to mark single notification as read
  - `markAllAsRead()` — mutation to mark all unread notifications as read (user-specific or broadcast)
  - `deleteNotification(id)` — mutation to delete a notification
  - `refetch` — manual refetch function
- TanStack Query configuration:
  - `refetchInterval: 15000` — 15 second polling as per requirements
  - `staleTime: 10000` — consider data stale after 10 seconds
  - `enabled: !!tenantId` — only fetch when tenant context is ready
- Real-time subscription via `useRealTimeSubscription` hook:
  - Subscribes to `notifications` table with tenant_id filter
  - On any change (INSERT/UPDATE/DELETE), invalidates queries to trigger refetch
  - Publishes to `notification_sent` event on eventBus
- Query filtering:
  - Always filters by `tenant_id` for tenant isolation
  - Uses `.or()` to get notifications targeted at current user OR broadcast (user_id is null)
  - Orders by `created_at DESC` for most recent first
- Error handling:
  - Gracefully handles case where table doesn't exist (error code 42P01)
  - Logs errors via `logger` from `@/lib/logger`
  - Shows toast notifications on mutation errors
- Mutation callbacks:
  - All mutations invalidate `queryKeys.notifications.all` to refresh the list
  - `markAllAsRead` shows success toast on completion
- TypeScript types exported:
  - `Notification` — matches database schema with proper type constraints
  - `UseNotificationsResult` — return type interface for the hook
- Imports use `@/` alias as required
- No console.log — all logging via `logger`
- Default export for convenient importing: `export default useNotifications`

## task-014: Create shared constants for entity types
- Created `src/lib/constants/entityTypes.ts` with all required exports
- ENTITY_TYPES object maps entity keys to database table names:
  - ORDER → 'orders', PRODUCT → 'products', CUSTOMER → 'customers'
  - VENDOR → 'vendors', MENU → 'disposable_menus', DELIVERY → 'deliveries'
  - PAYMENT → 'payments', INVENTORY → 'inventory', STOREFRONT → 'storefronts'
- Used `as const` assertion for proper type inference and immutability
- TypeScript types exported:
  - `EntityType` — union of entity key names (e.g., 'ORDER' | 'PRODUCT' | ...)
  - `EntityTableName` — union of table name values
- ENTITY_LABELS provides human-readable display names for each entity type
- ENTITY_ICONS maps each entity to a lucide-react icon name:
  - FileText, Package, Users, Building2, Menu, Truck, CreditCard, Warehouse, Store
  - Note: returns icon NAME (string), not component — use with `icons[iconName]` from lucide-react
- ENTITY_ROUTES maps each entity to its admin route pattern:
  - Some routes use path params (e.g., '/admin/orders' + '/' + id)
  - Some routes use query params (e.g., '/admin/inventory-hub?tab=products&product=' + id)
- Helper functions added for convenience:
  - `getEntityRoute(entityType, entityId, tenantSlug)` — builds full URL with tenant prefix
  - `getEntityTableName(entityType)` — gets table name for database queries
  - `getEntityLabel(entityType)` — gets display name for UI
  - `getEntityIconName(entityType)` — gets icon name for rendering
- Route handling distinguishes between query param routes (containing '=') and path param routes
- All exports typed with proper Record<EntityType, string> for type safety
- No console.log — types/constants file only
- Imports use `@/` alias pattern

## task-015: Create useEntityNavigation hook
- Created `src/hooks/useEntityNavigation.ts` as single source of truth for cross-module navigation
- Core functions implemented:
  - `navigateToEntity(entityType, entityId)` — navigates to entity detail page using react-router
  - `getEntityUrl(entityType, entityId)` — returns URL string without navigating (for links)
  - `navigateToEntityList(entityType)` — navigates to entity list page (no entity ID)
  - `getEntityListUrl(entityType)` — returns list URL string without navigating
- Uses `useTenantContext` from `@/hooks/useTenantContext` to get tenant slug
- Uses `getEntityRoute` and `ENTITY_ROUTES` from `@/lib/constants/entityTypes`
- URL generation:
  - Detail URLs via `getEntityRoute(entityType, entityId, tenantSlug)` — handles both path and query param routes
  - List URLs strip the trailing `=` from query param routes (e.g., `?tab=products&product=` becomes `?tab=products&product`)
- Returns `{ navigateToEntity, getEntityUrl, navigateToEntityList, getEntityListUrl, isReady }`
- `isReady` boolean indicates whether the hook can be used (has valid tenant context)
- All functions return `null` or do nothing if tenant slug is not available
- All callbacks memoized with `useCallback` for stable references
- Return object memoized with `useMemo` to prevent unnecessary re-renders
- Debug logging at each step using `logger` from `@/lib/logger`:
  - URL generation (entity type, entity ID, generated URL)
  - Navigation actions
  - Warning when navigation fails due to missing tenant slug
- No console.log — all logging via logger
- Imports use `@/` alias as required
- Exports both named function and default export for flexible importing

## task-016: Create shared loading skeleton components
- Created `src/components/admin/shared/LoadingSkeletons.tsx` with reusable skeleton components
- Components implemented exactly as specified in task:
  - `TableSkeleton(rows, cols)` — loading table with configurable row/column count
  - `CardSkeleton` — loading card with optional image and footer support
  - `StatCardSkeleton` — dashboard stat card loading state (matches AdminPageSkeleton pattern)
  - `ListItemSkeleton` — loading list item with optional avatar and action button
  - `DetailPageSkeleton` — full page loading skeleton with header, stats, main content, and sidebar
  - `FormSkeleton` — loading form with configurable field count and button section
- Added bonus `GridSkeleton` component for loading grids of cards (2/3/4 columns)
- All components use shadcn/ui `Skeleton` from `@/components/ui/skeleton`
- Also use `Card`, `CardContent`, `CardHeader` from `@/components/ui/card` for structure
- Use `cn()` utility from `@/lib/utils` for className merging
- All components accept `className` prop for customization
- Proper accessibility with `role="status"` and `aria-label` on all components
- Created `src/components/admin/shared/` directory (first file in this shared location)
- Followed existing patterns from `AdminPageSkeleton.tsx` and `skeleton.tsx` for consistency
- No console.log — no logging needed in pure UI components
- No tenant_id filtering needed — these are pure UI components with no data fetching
- All imports use `@/` alias as required

## task-017: Create shared error boundary component
- Created `src/components/admin/shared/ModuleErrorBoundary.tsx` as a React class component error boundary
- Component catches errors in admin modules and displays a friendly error state
- Props interface includes:
  - `children: ReactNode` — the wrapped module content
  - `moduleName: string` — required module name for error context and display
  - `fallback?: ReactNode` — optional custom fallback UI
  - `onRetry?: () => void` — optional custom retry handler callback
- Class component lifecycle methods:
  - `getDerivedStateFromError(error)` — updates state when error is caught
  - `componentDidCatch(error, errorInfo)` — logs error and shows toast notification
- Error handling:
  - Logs error with module context via `logger.error()` from `@/lib/logger`
  - Displays toast notification via `toast.error()` from `sonner`
  - Both error message and component stack are captured
- Retry functionality:
  - `handleRetry()` resets error state and calls optional `onRetry` prop
  - Logs retry attempt with module context via `logger.info()`
- Fallback UI:
  - Centered Card layout with AlertTriangle icon in destructive color
  - Shows module name in title: "{moduleName} Error"
  - Displays error message in styled error box
  - Stack trace visible in dev mode only (import.meta.env.DEV check)
  - Single retry button with RefreshCw icon: "Retry {moduleName}"
- Uses shadcn/ui components: Button, Card, CardHeader, CardTitle, CardDescription, CardContent, CardFooter
- Uses lucide-react icons: AlertTriangle, RefreshCw
- No console.log — all logging via `@/lib/logger`
- Follows existing AdminErrorBoundary pattern but simplified for per-module use
- All imports use `@/` alias as required

## task-018: Create shared empty state component
- Created `src/components/admin/shared/EmptyState.tsx` as a reusable empty state for admin modules
- Props interface includes:
  - `icon: LucideIcon` — required lucide-react icon to display
  - `title: string` — main title text
  - `description: string` — description text below the title
  - `actionLabel?: string` — optional label for the action button
  - `onAction?: () => void` — optional callback when action button is clicked
  - `entityType?: EntityType` — optional entity type for contextual CTA
  - `className?: string` — additional styling
- Entity-type aware CTAs:
  - Created `ENTITY_CTA_LABELS` record mapping each EntityType to contextual action text
  - Examples: "Create your first order", "Add a product", "Add your first customer"
  - When `entityType` is provided without `actionLabel`, uses entity-specific CTA
  - When `actionLabel` is provided, it takes precedence over entity CTA
- Uses `ENTITY_LABELS` from `@/lib/constants/entityTypes` for accessibility text
- Visual design:
  - Centered flex layout with vertical stacking
  - Icon in 16x16 rounded muted background container
  - Text content limited to max-w-sm for readability
  - Button renders only when both label and action handler are provided
- Accessibility:
  - `role="status"` on container
  - `aria-label` uses entity name when available, falls back to title
  - Icon container has `aria-hidden="true"`
- Uses shadcn/ui `Button` from `@/components/ui/button`
- Uses `cn()` utility from `@/lib/utils` for className merging
- No console.log — pure UI component with no logging needed
- No tenant_id filtering — pure presentational component
- All imports use `@/` alias as required
- TypeScript types properly imported from entityTypes constants

## task-019: Create useSyncStatus hook
- Created `src/hooks/useSyncStatus.ts` to track sync status between modules
- Hook returns `syncStatus` object with:
  - `lastSynced: string | null` — ISO timestamp of last successful sync
  - `isSyncing: boolean` — whether a sync operation is currently in progress
  - `syncError: string | null` — current error message if any
  - `currentModule: SyncModule | null` — module currently being synced
- Returns `triggerSync(module)` function to initiate sync for a specific module
- Also returns `clearError()` to reset error state and `isRecentlySynced(thresholdMs)` to check if sync is fresh
- Added sync-related events to `@/lib/eventBus`:
  - `sync_started: { tenantId, module }` — published when sync begins
  - `sync_completed: { tenantId, module, syncedAt }` — published when sync succeeds
  - `sync_error: { tenantId, module, error }` — published when sync fails
- Added `SyncModule` type: 'orders' | 'products' | 'inventory' | 'customers' | 'storefront' | 'all'
- Added `SYNC_LAST_SYNCED` storage key to `@/constants/storageKeys` for localStorage persistence
- Persistence:
  - Stores last sync time and module in localStorage via `safeStorage` wrapper
  - Initializes state from localStorage on mount for persistence across page reloads
  - Uses `safeJsonParse` and `safeJsonStringify` for error-safe JSON handling
- Event handling:
  - Subscribes to `sync_started`, `sync_completed`, `sync_error` events via `eventBus.subscribe`
  - Filters events by `tenantId` to only handle events for current tenant
  - Auto-unsubscribes on unmount via useEffect cleanup returning unsubscribe function
- Uses `useTenantAdminAuth` from `@/contexts/TenantAdminAuthContext` for tenant context
- All functions memoized with `useCallback`, return object memoized with `useMemo`
- Debug/info/error logging via `logger` from `@/lib/logger` — no console.log
- Exported hook via hooks barrel file (`src/hooks/index.ts`)
- All imports use `@/` alias as required

## task-020: Create shared toast notification utility
- Created `src/lib/notifications/toast.ts` wrapping sonner toast with standardized messages
- Order notifications:
  - `toastOrderCreated(orderNumber)` — success toast for new orders
  - `toastOrderUpdated(orderNumber, status)` — success toast for status changes
  - `toastOrderCancelled(orderNumber)` — info toast for cancellations
  - `toastOrderCompleted(orderNumber)` — success toast for fulfillment
  - `toastOrderDelivered(orderNumber)` — success toast for deliveries
- Inventory notifications:
  - `toastInventoryLow(productName, quantity)` — warning toast for low stock
  - `toastInventoryUpdated(productName)` — success toast for stock updates
  - `toastOutOfStock(productName)` — error toast for zero stock
  - `toastInventorySynced(count)` — success toast for bulk sync
- Sync notifications:
  - `toastSyncComplete(module)` — success toast with module name
  - `toastSyncStarted(module)` — info toast for sync in progress
  - `toastSyncFailed(module)` — error toast for sync failures
- Product/Customer notifications for CRUD operations
- Payment notifications: `toastPaymentReceived`, `toastPaymentFailed`, `toastRefundProcessed`
- General action notifications: `toastSaved`, `toastDeleted`, `toastCopied`, `toastExported`, `toastImported`
- Error notifications:
  - `toastError(action, error)` — contextual error with "Failed to {action}" format
  - `toastValidationError(message)` — validation-specific errors
  - `toastNetworkError()` — network connectivity errors
  - `toastPermissionDenied(action?)` — authorization errors
  - `toastSessionExpired()` — session timeout handling
- Info/warning helpers: `toastInfo(title, desc)`, `toastWarning(title, desc)`
- Loading/progress: `toastLoading(message)`, `dismissToast(id)`, `toastPromise(promise, messages)`
- All functions accept optional `ExternalToast` for customization
- `toastPromise` returns `{ unwrap: () => Promise<T> }` matching sonner's return type
- Re-exports base `toast` for advanced usage cases
- Created `src/lib/notifications/` directory as first file in this location
- No console.log — toast utility only
- All imports use `@/` alias (none needed — only imports from sonner)

## task-021: Create usePermissions enhanced hook
- Extended existing `src/hooks/usePermissions.ts` to add module-based permission checks
- Created `PermissionModule` type covering 14 modules:
  - Core: orders, products, customers, vendors, inventory, analytics, settings
  - Extended: menus, wholesale-orders, finance, team, reports, fleet, api
- Created `MODULE_PERMISSION_MAP` constant mapping each module to its permission strings:
  - Each module has view, edit, delete, and export permission mappings
  - Mapped to existing permission strings from `@/lib/permissions/rolePermissions`
  - Some modules share permissions (vendors → customers, analytics → reports)
- Added four memoized permission check functions using `useCallback`:
  - `canView(module)` — checks if user can view module
  - `canEdit(module)` — checks if user can edit/modify items in module
  - `canDelete(module)` — checks if user can delete items in module
  - `canExport(module)` — checks if user can export data from module
- Added `modulePermissions` object with `useMemo`:
  - Pre-computed permissions for all modules in a single object
  - Returns `{ canView, canEdit, canDelete, canExport }` for each module
  - Useful for components that need to check multiple permissions at once
- Hook uses `useTenantAdminAuth()` internally for tenant context (as existing implementation)
- All permission calculations memoized on `role` dependency for performance
- Logger warnings added for unknown module requests
- Fixed import order: React → Third-party → Local components → Utils
- Return object updated to include new functions alongside legacy `checkPermission` methods
- No console.log — all logging via `logger` from `@/lib/logger`
- All imports use `@/` alias as required

## task-022: Create shared data table component
- Created `src/components/admin/shared/DataTable.tsx` — a reusable data table with full feature set
- Column configuration via `ColumnDef<TData>` interface:
  - `accessorKey` — key to access data from row (supports nested paths via dot notation)
  - `header` — string or render function for header content
  - `cell` — custom cell renderer receiving `{ original, value }`
  - `sortable` — enables column sorting with visual indicators
  - `sortFn` — optional custom sort function
  - `width` — column width (e.g., '100px', '10%')
  - `hideOnMobile` — responsive column hiding
- Sorting features:
  - Client-side sorting with toggle (asc → desc → none)
  - Custom sort functions supported
  - Server-side sorting via `onSortChange` callback
  - Visual indicators: ArrowUpDown, ArrowUp, ArrowDown icons
- Filtering/Search:
  - Search input with configurable placeholder
  - Supports single or multiple search columns
  - Supports nested path search (e.g., 'customer.name')
  - Controlled or uncontrolled search via `searchValue`/`onSearchChange` props
- Pagination:
  - Client-side pagination with configurable page sizes
  - Server-side pagination via `ServerPagination` interface
  - Page size selector with customizable options
  - Item count display and page navigation
- Row selection:
  - Optional via `enableSelection` prop
  - Select all / select individual rows
  - Indeterminate state for partial selection
  - Checkbox column with proper accessibility labels
- Bulk actions:
  - Array of `BulkAction` objects with label, onClick, variant, icon, disabled
  - Actions appear when rows are selected
  - `onClick` receives array of selected row IDs
- Empty state:
  - Custom empty state via `emptyState` ReactNode prop
  - Default "No results found" message
- Loading state:
  - Spinner with "Loading..." message when `loading` prop is true
- Row click handling:
  - `onRowClick` callback for navigation
  - Click handler excludes checkbox clicks
- Helper utilities:
  - `getNestedValue` for accessing nested object properties
  - `useDataTableSelection` hook for external selection state management
- Uses shadcn/ui components: Table, Button, Input, Checkbox, Select
- Uses lucide-react icons for sorting and navigation
- No tenant_id filtering needed — pure presentational component (data passed in props)
- No console.log — pure UI component
- All imports use `@/` alias as required
- TypeScript generic `<TData extends Record<string, unknown>>` for type safety

## task-023: Create shared detail panel component
- Created `src/components/admin/shared/DetailPanel.tsx` — slide-over panel for quick entity viewing
- Props interface includes:
  - `isOpen: boolean` — controls panel visibility
  - `onClose: () => void` — callback when panel should close
  - `title: string` — panel header title
  - `entityType?: EntityType` — optional entity type for contextual styling
  - `entityId?: string` — optional entity ID for reference display
  - `actions?: DetailPanelAction[]` — array of action button configurations
  - `relatedEntities?: RelatedEntity[]` — related entities for cross-module navigation
  - `relatedEntitiesLoading?: boolean` — loading state for related entities section
  - `children: ReactNode` — panel content
  - `loading?: boolean` — loading state for main content
  - `width?: 'sm' | 'md' | 'lg' | 'xl'` — panel width variants
- Action configuration via `DetailPanelAction` interface:
  - `label`, `icon`, `onClick`, `variant`, `disabled`, `loading`
  - Supports all Button variants: default, destructive, outline, secondary, ghost, link
- Related entities via `RelatedEntity` interface:
  - `entityType`, `entityId`, `label`, `subtitle`, `onClick`
  - Renders as clickable cards with entity type icon abbreviation
- CSS transitions for slide-in animation:
  - `translate-x-0` / `translate-x-full` with `duration-300 ease-in-out`
  - Backdrop overlay with opacity fade animation
- Keyboard support:
  - Escape key listener to close panel
  - Proper focus management on action buttons
- Body scroll lock when panel is open via `document.body.style.overflow`
- Uses shadcn/ui components: Button, ScrollArea, Separator
- Uses lucide-react icons: X, Loader2
- Uses `ENTITY_LABELS` and `getEntityIconName` from `@/lib/constants/entityTypes`
- Related entities section renders at bottom with separator
- Loading states for both main content and related entities
- Accessibility:
  - `role="dialog"` and `aria-modal="true"` on panel
  - `aria-label` with entity context when available
  - Close button with `aria-label="Close panel"`
- No console.log — pure UI component
- No tenant_id filtering — pure presentational component
- All imports use `@/` alias as required

## task-024: Create useRelatedEntities hook
- Extended existing `src/hooks/useRelatedEntities.ts` with unified `useRelatedEntities` hook
- Core functionality:
  - Given an `entityType` and `entityId`, fetches all related entities using parallel TanStack queries
  - Uses `useQueries` from TanStack Query for efficient parallel data fetching
  - Supports three entity types: 'order', 'customer', 'product'
- Order related entities (`OrderRelatedEntities`):
  - `customer: RelatedCustomer | null` — customer who placed the order
  - `products: RelatedProduct[]` — products in the order with quantities
  - `delivery: RelatedDelivery | null` — delivery details with courier info
  - `payment: RelatedPayment | null` — payment status and transaction info
- Customer related entities (`CustomerRelatedEntities`):
  - `orders: RelatedOrder[]` — customer's order history
  - `totalSpent: number` — sum of completed order amounts
  - `lastOrderDate: string | null` — most recent order timestamp
  - `orderCount: number` — total number of orders
  - `averageOrderValue: number` — computed average
- Product related entities (`ProductRelatedEntities`):
  - `vendor: RelatedVendor | null` — supplier information
  - `orders: RelatedOrder[]` — orders containing this product
  - `stock: RelatedStock[]` — inventory across locations
  - `totalStock: number` — sum of available quantities
  - `totalOrdered: number` — sum of quantities ordered
- Type definitions exported:
  - `RelatedEntityType` — union of supported entity types
  - `RelatedCustomer`, `RelatedProduct`, `RelatedDelivery`, `RelatedPayment`
  - `RelatedOrder`, `RelatedVendor`, `RelatedStock`
  - `OrderRelatedEntities`, `CustomerRelatedEntities`, `ProductRelatedEntities`
  - `RelatedEntities` — union type for all related entities
  - `UseRelatedEntitiesReturn` — hook return type interface
- Query configuration:
  - Uses `queryKeys` from `@/lib/queryKeys` with `.related()` pattern
  - `staleTime: 30_000` (30 seconds) for efficient caching
  - `enabled` based on both `entityId` and `tenantId` availability
- Tenant isolation:
  - All queries filter by `tenant_id` via `useTenantAdminAuth()`
  - Product orders filtered client-side for tenant match
- Return object includes:
  - `data: RelatedEntities | null` — combined results based on entity type
  - `isLoading: boolean` — true if any query is loading
  - `isError: boolean` — true if any query has error
  - `error: Error | null` — first error encountered
  - `refetch: () => void` — triggers refetch of all queries
- Error handling uses `logger.error()` from `@/lib/logger` — no console.log
- All imports use `@/` alias as required
- Extends existing lazy-loading hooks (useRelatedClientInvoices, etc.) in same file

## task-025: Create shared badge status component
- Created `src/components/admin/shared/StatusBadge.tsx` for rendering colored status badges
- Supports 6 entity types: order, inventory, customer, delivery, payment, menu
- Order statuses: pending, confirmed, processing, shipped, delivered, cancelled, refunded
- Inventory statuses: in_stock, low_stock, out_of_stock, discontinued
- Customer statuses: active, inactive, vip, suspended, pending_verification
- Delivery statuses: pending, assigned, in_transit, delivered, failed, returned
- Payment statuses: pending, completed, failed, refunded, cancelled
- Menu statuses: draft, active, expired, archived
- Color configuration uses semantic Tailwind classes (bg-green-100/text-green-800 for success, etc.)
- Props interface includes: status, entityType, optional label override, size variant (sm/default/lg), className
- `formatStatusLabel` helper converts snake_case to Title Case for display
- `getStatusColors` function returns color config based on entity type and status
- Exports color mappings and helper functions for external use
- Uses shadcn/ui Badge component with outline variant as base
- No console.log — pure UI component
- No tenant_id filtering needed — presentational component only
- All imports use `@/` alias as required

## task-026: Create useGlobalSearch hook
- Updated `src/hooks/useGlobalSearch.ts` to match task requirements exactly
- Searches across orders, products, customers, and vendors simultaneously using parallel queries
- Returns categorized results in `{ orders[], products[], customers[], vendors[] }` format
- Implemented relevance scoring with three tiers:
  - EXACT_MATCH_SCORE (100) — value equals search term
  - STARTS_WITH_SCORE (75) — value starts with search term
  - CONTAINS_SCORE (50) — value contains search term
- Each result includes: id, name, subtitle, status (optional), relevanceScore, metadata
- Results are sorted by relevance score (highest first) within each category
- Uses `useDebounce` hook from `@/hooks/useDebounce` with 300ms default delay
- Minimum 2 characters required before search triggers (configurable via `minChars`)
- All queries filter by tenant_id:
  - Orders and products use `tenant_id`
  - Customers (profiles) use `account_id`
  - Vendors use `account_id`
- Uses Supabase `.or()` with `.ilike()` for case-insensitive partial matching
- TanStack Query with `staleTime: 30000` for caching
- Hook options: minChars, debounceMs, limitPerCategory, enabled
- Returns: results, isSearching, error, totalCount, setQuery, clear, query, debouncedQuery
- Helper functions `calculateRelevanceScore` and `getBestRelevanceScore` for scoring logic
- Graceful error handling with logger.warn for individual query failures
- No console.log — all logging via `logger` from `@/lib/logger`
- All imports use `@/` alias as required

## task-027: Create global search command palette
- Created `src/components/admin/shared/CommandPalette.tsx` as a Cmd+K / Ctrl+K command palette
- Keyboard shortcut implementation:
  - Global event listener on `document` for keydown events
  - Checks for 'k' key with metaKey (Mac) or ctrlKey (Windows/Linux)
  - Prevents default browser behavior and toggles the palette
  - Proper cleanup on unmount via useEffect return
- Uses `useGlobalSearch` hook from `@/hooks/useGlobalSearch`:
  - Passes `enabled: open` to only search when palette is visible
  - Destructures results, isSearching, setQuery, clear, query, totalCount
  - Clears search when palette closes via useEffect
- Groups results by entity type using `ENTITY_LABELS` from `@/lib/constants/entityTypes`:
  - Results grouped into Orders, Products, Customers, Vendors sections
  - Each section only renders if it has results
  - CommandSeparator between non-empty groups
- Entity icons via `ENTITY_ICON_COMPONENTS` local mapping:
  - ORDER → FileText, PRODUCT → Package, CUSTOMER → Users, VENDOR → Building2
  - Uses actual lucide-react component imports (not dynamic icon loading)
- Each result shows:
  - Entity type icon (color-coded muted-foreground)
  - Name with truncation for overflow
  - Subtitle (e.g., order number, SKU, email) as small muted text
  - StatusBadge when status is available (maps entity type to StatusEntityType)
  - ArrowRight icon for navigation affordance
- Navigation via `useEntityNavigation` hook:
  - `navigateToEntity(entityType, entityId)` on item selection
  - Checks `isReady` before navigating, logs warning if not ready
  - Closes palette after successful navigation
- Recent searches stored in localStorage via `STORAGE_KEYS`:
  - Uses `COMMAND_PALETTE_RECENT_SEARCHES` key (already defined in storageKeys.ts)
  - Stores up to 10 recent searches (MAX_RECENT_SEARCHES constant)
  - Each entry: { id, entityType, name, subtitle, timestamp }
  - Uses `safeStorage`, `safeJsonParse`, `safeJsonStringify` for error-safe storage
  - Recent searches section shown when no active search query
  - Clear button to remove all recent searches
- Keyboard shortcut hints in footer:
  - Platform-aware modifier key (⌘ for Mac, Ctrl for others)
  - Navigation hints: ↑↓ navigate, ↵ select, Esc close
  - Uses styled kbd elements for visual consistency
- Uses Zustand store for global state:
  - `useCommandPaletteStore` with open, setOpen, toggle
  - Exported for external control (e.g., from header buttons)
- Empty states:
  - "Type at least 2 characters to search" when query is too short
  - "No results found" with suggestion to try different term
  - Loading spinner with "Searching..." message
- Uses shadcn/ui command components: CommandDialog, CommandInput, CommandList, CommandEmpty, CommandGroup, CommandItem, CommandSeparator, CommandShortcut
- No console.log — all logging via `logger` from `@/lib/logger`
- All imports use `@/` alias as required
- Follows project import order: React → Third-party → Types → Components → Utils

## task-028: Create useDashboardStats hook
- Extended existing `src/hooks/useDashboardStats.ts` to add trend indicators per task requirements
- Added new types for trend support:
  - `TrendDirection` — 'up' | 'down' | 'flat' for visual indicators
  - `StatWithTrend` — { value, changePercent, trend } structure for each stat
  - `DashboardStatsWithTrends` — primary return type with 8 key stats
- Key stats returned with trends (matching task-028 specification exactly):
  - `ordersToday` — orders placed today with yesterday comparison
  - `revenueToday` — revenue today with yesterday comparison
  - `newCustomers` — new customers today with yesterday comparison
  - `lowStockCount` — low stock items count (inverted trend: more is bad)
  - `pendingDeliveries` — active deliveries in transit
  - `activeMenus` — currently active disposable menus
  - `totalProducts` — total product count (stable metric, flat trend)
  - `avgOrderValue` — MTD average order value with growth trend
- Helper functions added:
  - `calculateTrend(changePercent)` — determines up/down/flat based on threshold (±0.5%)
  - `calculateChangePercent(current, previous)` — handles zero division edge case
  - `createStatWithTrend(current, previous)` — builds StatWithTrend object with rounded percent
- Refactored internal function:
  - Original query logic moved to `useRawDashboardStats()` internal function
  - Main `useDashboardStats()` now wraps raw stats and adds trend calculations
  - Trend calculations memoized with `useMemo` for performance
- Return object includes:
  - `stats: DashboardStatsWithTrends` — primary API per task requirements
  - `rawStats: DashboardStats` — backward compatibility with existing consumers
  - `data, isLoading, isPending, isFetching, isError, error, refetch` — query state
- Query configuration preserved:
  - `refetchInterval: 30_000` (30 seconds) as specified
  - `staleTime: 30_000` for caching
  - `enabled: !!tenantId` for tenant context
- Uses parallel queries via `Promise.allSettled` for efficient data fetching
- Special handling for `lowStockCount` — inverted trend direction (more items = bad)
- Changed from `useTenantAdminAuth()` to `useTenantContext()` for consistency with task-005
- No console.log — all logging via `logger.debug()` from `@/lib/logger`
- All imports use `@/` alias as required
- Import order follows convention: React → Third-party → Local imports

## task-029: Create shared currency formatter utility
- Task requested `src/lib/formatters/currency.ts` but the functionality already exists at `src/lib/utils/formatCurrency.ts`
- The existing implementation at `src/lib/utils/formatCurrency.ts` fully satisfies all task requirements:
  - `formatCurrency(amount, currency, locale)` — formats as currency string with Intl.NumberFormat
  - `formatCompactCurrency(amount, currency)` — compact format for dashboard cards (e.g., $12.3K, $1.2M)
  - `formatCurrencyNumber(amount, decimals)` — formats number without currency symbol
  - Default currency is USD as specified
  - Supports different locales via third parameter
- The `src/lib/formatters.ts` barrel file already re-exports these functions for easy discovery
- Marking as passing since the required functionality exists and is properly exported
- No changes needed — existing code structure is superior (utils directory organization vs formatters subdirectory)
- Lesson: Always check if functionality already exists before creating new files

## task-030: Create shared date formatter utility
- Created `src/lib/formatters/date.ts` as a new file in the formatters directory
- Core functions implemented exactly as task specified:
  - `formatDate(date, format, options)` — formats date with custom format string (date-fns tokens)
  - `formatRelative(date, options)` — returns "2 hours ago", "Yesterday", "Tomorrow" etc.
  - `formatDateRange(start, end, options)` — intelligent range formatting with redundancy elimination
- Timezone support using native Intl API (not date-fns-tz which isn't installed):
  - `toTimezone(date, timezone)` — converts date to target timezone using Intl.DateTimeFormat
  - `resolveTimezone(timezone)` — falls back to DEFAULT_TIMEZONE ('America/New_York') when not provided
  - Options accept `timezone?: string | null` for tenant settings integration
- Additional exports for convenience:
  - `DATE_FORMATS` — preset format strings (short, medium, long, full, iso, time, dateTime)
  - `getCurrentTimezone()` — detects user's timezone via Intl API
  - `getTimezoneAbbreviation(timezone, date)` — returns "EST", "PST" etc.
  - `formatDateWithTimezone(date, options)` — formats with timezone indicator appended
- Relative formatting handles special cases:
  - "Just now" for < 1 minute
  - "X minutes ago" for < 60 minutes
  - "X hours ago" for same day
  - "Yesterday", "Tomorrow" for adjacent days
  - "X days ago" / "in X days" for within a week
  - Falls back to formatDistance for older dates
- Date range formatting is intelligent:
  - Same day: "Feb 9, 2026"
  - Same month: "Feb 1 - 15, 2026"
  - Same year: "Jan 15 - Feb 15, 2026"
  - Different years: "Dec 15, 2025 - Jan 15, 2026"
  - Supports includeTime option for time ranges on same day
- Error handling:
  - Graceful fallback to local formatting when timezone conversion fails
  - Returns placeholder ('—') for null/undefined/invalid dates
  - Logger warnings for parse and format failures
- Note: `src/lib/utils/formatDate.ts` also exists with similar but different API
  - The new file follows the task's specified API exactly
  - Both can coexist; the formatters.ts barrel file exports from utils version
- All logging via `logger` from `@/lib/logger` — no console.log
- All imports use `@/` alias as required

## task-031: Create useLocalStorage hook
- Enhanced existing `src/hooks/useLocalStorage.ts` with full feature set
- Type-safe key parameter accepts `StorageKey | string` for STORAGE_KEYS integration:
  - Import `StorageKey` type from `@/constants/storageKeys`
  - Allows type-checking when using defined storage keys
  - Still accepts arbitrary strings for backward compatibility
- Core features implemented exactly as task specified:
  - Type-safe get/set with JSON parse/stringify and `as T` type assertions
  - Try-catch wrapped for all operations (get, set, clear)
  - Supports default values via `initialValue` parameter
  - SSR-safe via `safeStorage` utility which checks `typeof window === 'undefined'`
- Additional features added:
  - `clearValue()` — third return value to clear storage and reset to initial value
  - Cross-tab synchronization via `window.addEventListener('storage', ...)` event listener
  - Memoized `setValue` and `clearValue` with `useCallback` for stable references
- State updates use functional pattern in `setStoredValue((prevValue) => ...)`:
  - Avoids stale closure issues when using function updater pattern
  - Ensures localStorage and React state stay in sync
- Return type is `readonly [T, (value) => void, () => void]` with `as const`:
  - Tuple with value, setter, and clear functions
  - Existing usages that only destructure two values continue to work
- Error handling uses structured logger calls with context:
  - `logger.error(message, errorObj, { key, component: 'useLocalStorage' })`
  - Errors don't break the app — fallback to initial value on parse errors
- SSR check in useEffect cleanup: `if (typeof window === 'undefined') return;`
- Existing `useLocalStorageState.ts` hook also exists with similar features plus cross-tab sync
  - New hook now also has cross-tab sync for feature parity
  - Both hooks can coexist; teams can choose based on preference
- All logging via `logger` from `@/lib/logger` — no console.log
- All imports use `@/` alias and follow project import order: React → Third-party → Types → Utils

## task-032: Create Supabase migration for inventory_history table
- Migration already exists at `supabase/migrations/20260123000000_create_inventory_history.sql`
- Existing migration is MORE comprehensive than task requirements:
  - Uses `change_type` with CHECK constraint instead of freeform `reason` column (more robust)
  - Values: 'stock_in', 'stock_out', 'transfer', 'adjustment', 'sale', 'return', 'receiving', 'disposal'
  - Uses `previous_quantity`/`new_quantity`/`change_amount` (NUMERIC) instead of `quantity_before`/`quantity_after`/`quantity_change` (INTEGER)
  - Uses `performed_by` instead of `user_id` (clearer naming convention)
  - Includes additional fields: `location_id`, `batch_id`, `notes`, `metadata JSONB`
- RLS enabled with tenant isolation via `profiles` table lookup (matching other migrations)
- Indexes created on:
  - `tenant_id` (single column)
  - `product_id` (as required)
  - `change_type` (for filtering)
  - `created_at DESC` (as required)
  - `(tenant_id, product_id)` composite
  - `(tenant_id, created_at DESC)` composite
  - `(reference_type, reference_id)` for lookups
- Lesson: Always check existing migrations before creating new ones — task may already be complete
- The existing implementation exceeds requirements with better data types and constraints

## task-033: Create useInventoryHistory hook
- Hook already existed at `src/hooks/useInventoryHistory.ts` with basic functionality
- Enhanced to meet all task requirements:
  - Added `dateRange` parameter (as DateRange interface with startDate/endDate)
  - Maintained backward compatibility with separate `startDate`/`endDate` params
  - Added `formattedChange` field (e.g., "+50", "-25", "0") via `formatChange()` helper
  - Added `runningTotal` calculation for each entry
  - Added `changeTypeLabel` for human-readable change type display
  - Added `changeDirection` ('increase' | 'decrease' | 'neutral') for UI styling
- Created `FormattedInventoryHistoryEntry` interface extending base entry with calculated fields
- Running total logic:
  - Uses `new_quantity` from each entry as the running total at that point in time
  - Entries are returned in descending order (newest first) matching query ORDER BY
  - `calculateRunningTotals()` function processes entries and adds formatted fields
- Summary statistics added via `useMemo`:
  - `totalChanges` — count of history entries
  - `netChange` — totalIncrease - totalDecrease
  - `totalIncrease` — sum of positive changes
  - `totalDecrease` — sum of negative changes (absolute value)
  - `currentQuantity` — running total of most recent entry
- Uses `queryKeys.inventory.history()` factory (already existed in queryKeys.ts)
- Supabase query uses type assertion to handle untyped `inventory_history` table:
  - `(supabase as unknown as { from: (table: string) => unknown }).from('inventory_history')`
  - Returns typed `InventoryHistoryEntry[]` via explicit return type
- Hook returns structured object:
  - `data` — raw entries from database
  - `formattedEntries` — entries with running totals and formatting
  - `summary` — computed statistics
  - Query state: `isLoading`, `isPending`, `isFetching`, `isError`, `error`, `refetch`
- CHANGE_TYPE_LABELS constant maps change types to display labels
- All logging via `logger` from `@/lib/logger` — no console.log
- All imports use `@/` alias and follow import order: React → Third-party → Local imports
- Lesson: When enhancing existing hooks, preserve backward compatibility while adding new features

## task-034: Create shared confirmation dialog component
- Created `src/components/admin/shared/ConfirmDialog.tsx` as a reusable confirmation modal
- Built on shadcn/ui AlertDialog primitives for consistent design
- Props implemented exactly as specified in task:
  - `isOpen: boolean` — controls dialog visibility
  - `onConfirm: () => void` — callback for confirm action
  - `onCancel: () => void` — callback for cancel action or dismiss
  - `title: string` — dialog header text
  - `description: string` — dialog body text
  - `confirmLabel?: string` — customize confirm button text (default: 'Confirm')
  - `variant?: 'default' | 'destructive'` — button styling variant
- Additional props added for enhanced usability:
  - `cancelLabel?: string` — customize cancel button text (default: 'Cancel')
  - `loading?: boolean` — shows loading state and disables buttons during async operations
  - `className?: string` — custom styling for dialog content
- Destructive variant applies `buttonVariants({ variant: 'destructive' })` for red button styling
- Uses `cn()` utility from `@/lib/utils` for className merging
- `onOpenChange` handler calls `onCancel` when dialog is dismissed via overlay click or escape key
- Memoized `handleConfirm` callback prevents action during loading state
- Loading state shows "Processing..." text instead of confirm label
- Note: Existing `useConfirmDialog` hook at `src/hooks/useConfirmDialog.ts` provides state management
  - Hook was NOT modified — only the component was created per task requirements
  - Initially added hook to component file but moved out to avoid react-refresh/only-export-components warning
- No console.log — pure UI component with no logging needed
- No tenant_id filtering — pure presentational component
- All imports use `@/` alias as required

## task-035: Create shared form field components
- Created `src/components/admin/shared/FormFields.tsx` with 7 reusable form field components
- All components integrate with React Hook Form via `Controller` component:
  - TextField — standard text input (supports text, email, password, tel, url types)
  - NumberField — numeric input with min/max/step props and proper number conversion
  - TextareaField — multi-line text input with configurable rows
  - SelectField — dropdown select using shadcn/ui Select primitives
  - DateField — date picker using shadcn/ui Calendar with Popover
  - SwitchField — toggle switch with horizontal layout (label + description on left, switch on right)
  - ComboboxField — searchable dropdown using shadcn/ui Command primitives
- Common base props interface `BaseFieldProps<TFieldValues, TName>`:
  - `control: Control<TFieldValues>` — RHF control object
  - `name: TName extends FieldPath<TFieldValues>` — type-safe field name
  - `label: string`, `description?: string`, `required?: boolean`, `disabled?: boolean`, `className?: string`
- Helper components created for consistency:
  - `FieldError` — displays validation error message from Zod (shows `fieldState.error?.message`)
  - `FieldLabel` — renders label with optional required indicator (*) and description
- Each field component handles validation errors:
  - Input/Select/Button shows `border-destructive` styling when error present
  - Error message displayed below field via FieldError component
- DateField uses date-fns `format()` for display and date-fns Calendar for selection
- ComboboxField uses local `open` state via `useState` for popover control
- NumberField converts string input to number via `Number(value)` in onChange
- All fields handle null/undefined values with `?? ''` or `?? false` fallbacks
- TypeScript generics ensure type safety: `<TFieldValues extends FieldValues, TName extends FieldPath<TFieldValues>>`
- Uses shadcn/ui components: Input, Label, Textarea, Switch, Button, Calendar, Select*, Popover*, Command*
- Uses lucide-react icons: CalendarIcon, Check, ChevronsUpDown
- No console.log — pure UI components
- No tenant_id filtering — pure presentational components for form building
- All imports use `@/` alias as required

## task-036: Create useFormPersistence hook
- Created `src/hooks/useFormPersistence.ts` — auto-saves form state to localStorage
- Hook accepts `formId` (unique identifier) and `formValues` (generic Record type)
- Debounces saves by 1 second (configurable via `debounceMs` option) to prevent excessive writes
- Uses `STORAGE_KEYS.FORM_PERSISTENCE_PREFIX` + formId pattern for storage key
- Added `FORM_PERSISTENCE_PREFIX` to `src/constants/storageKeys.ts`
- Provides `restoreForm()` — returns saved values or null if stale/missing
- Provides `clearSavedForm()` — clears storage on successful form submit
- Returns `hasSavedForm` boolean and `lastSavedAt` timestamp for UI feedback
- Handles stale data with configurable `maxAgeMs` (default 24 hours)
- Uses `safeStorage` from `@/utils/safeStorage` for memory fallback in incognito mode
- Uses `useRef` for debounce timer to avoid stale closure issues
- Properly cleans up debounce timer on unmount via useEffect cleanup
- TypeScript generic `<T extends Record<string, unknown>>` for type-safe form values
- All logging via `logger.debug/warn/error` from `@/lib/logger` — no console.log
- All imports use `@/` alias as required

## task-037: Create shared export utility
- Created `src/lib/export.ts` — centralized export utility for CSV and JSON downloads
- Core functions implemented exactly as task specified:
  - `exportToCSV(data, columns, filename, options)` — exports data to CSV with column config
  - `exportToJSON(data, filename, options)` — exports data to JSON with pretty printing
- Column configuration via `ExportColumn<T>` interface:
  - `key: string` — supports dot notation for nested objects (e.g., 'customer.name')
  - `header: string` — display name for CSV header
  - `type` — automatic formatting for string, number, currency, percent, date, datetime, boolean
  - `format` — custom formatter function for complex transformations
- Date formatting:
  - Uses date-fns `format()` for consistent date output
  - Configurable `dateFormat` and `datetimeFormat` in options
  - Handles Date objects and ISO strings
- Nested object handling:
  - `getNestedValue(obj, path)` helper traverses dot-notation paths
  - Objects/arrays that aren't dates get JSON.stringify treatment
- Special character escaping:
  - `escapeCSVValue()` handles commas, quotes, newlines, tabs
  - Double quotes escaped as `""` per CSV standard
  - Values containing special chars wrapped in quotes
- Download link creation:
  - `downloadFile(content, filename, mimeType)` creates blob URL
  - Appends hidden `<a>` element, clicks it, removes it
  - Cleans up object URL after 100ms delay
- Activity logging integration:
  - `logExportActivity()` calls `logActivity` from `@/lib/activityLog`
  - Logs with `ActivityAction.EXPORTED` and configurable entity type
  - Only logs if tenantId and userId provided in options
  - Metadata includes filename, format, and rowCount
- Export options include:
  - `includeBOM` — adds UTF-8 BOM for Excel compatibility (default true)
  - `currencyLocale` / `currencyCode` — configurable currency formatting
  - `tenantId` / `userId` — for activity logging
  - `entityType` / `metadata` — additional logging context
- Added convenience helpers:
  - `generateFilename(baseName, extension)` — creates timestamped filename
  - `ColumnBuilder` — factory methods for quick column definition
- No console.log — all logging via `logger` from `@/lib/logger`
- All imports use `@/` alias as required

## task-038: Create useExport hook
- Updated existing `src/hooks/useExport.ts` to integrate with `@/lib/export.ts` utility
- Previous implementation used `@/lib/utils/exportData.ts` — now properly uses the shared utility from task-037
- Hook wraps export utility with React state management:
  - `isExporting: boolean` — tracks whether export operation is in progress
  - `progress: ExportProgress | null` — tracks progress for large datasets
  - `clearProgress()` — manually clear progress state
- Export functions implemented:
  - `exportCSV(data, columns, filename?, options?)` — CSV export with column configuration
  - `exportJSON(data, filename?, options?)` — JSON export for raw data
- Column configuration via `ExportColumn<T>` interface from `@/lib/export`:
  - Supports dot notation for nested object access
  - Type-based formatting (currency, date, percent, etc.)
  - Custom formatter functions
- Activity logging integration:
  - Uses `useActivityLog` hook for logging export actions
  - Uses `useTenantContext` for tenant/user context
  - Logs with `ActivityAction.EXPORTED` and configurable entity type
  - Double logging: both via export utility (for standalone usage) and via hook (for React integration)
- Progress indicator for large datasets:
  - `LARGE_DATASET_THRESHOLD` set to 1000 rows
  - Shows info toast with estimated time for large exports
  - Progress phases: 'preparing', 'processing', 'downloading', 'complete'
  - `estimateExportTime()` helper provides human-readable estimates
- Toast notifications via `@/utils/toastHelpers`:
  - `showInfoToast` for large dataset warnings
  - `showSuccessToast` on completion with row count
  - `showErrorToast` on failure with error message
- Re-exports types and helpers for convenience:
  - `ExportColumn`, `ExportOptions` types
  - `generateFilename`, `ColumnBuilder` utilities
- Error handling:
  - Try/catch wraps all export operations
  - Errors logged via `logger.error()` with filename context
  - Toast shown to user with error message
  - Error re-thrown for caller to handle if needed
- All callbacks memoized with `useCallback` for stable references
- No console.log — all logging via `logger` from `@/lib/logger`
- All imports use `@/` alias as required

## task-039: Create shared filter bar component
- Created `src/components/admin/shared/FilterBar.tsx` — reusable filter bar with comprehensive filtering features
- Core filter types supported:
  - `select` — dropdown with options array, placeholder support
  - `dateRange` — dual calendar popover with from/to date selection
  - `date` — single date picker
  - `text` — text input for custom filters
- Props interface includes:
  - `filters: FilterConfig[]` — array of filter configurations
  - `activeFilters: ActiveFilters` — current filter values object
  - `onFilterChange: (filters) => void` — callback for filter updates
  - `onClear: () => void` — callback to clear all filters
  - `storageKey?: string` — localStorage key for persistence
  - `searchPlaceholder?: string` — search input placeholder
  - `searchValue? / onSearchChange?` — controlled search props
  - `showSearch?: boolean` — toggle search visibility
  - `customFilters?: ReactNode` — slot for custom filter elements
  - `className?: string` — additional styling
- localStorage persistence:
  - `loadFiltersFromStorage(key)` — retrieves filters from localStorage
  - `saveFiltersToStorage(key, filters)` — persists filters to localStorage
  - Auto-loads on mount when `storageKey` provided
  - Auto-saves on filter change via useEffect
  - Clears storage when `handleClearAll()` is called
- Active filter count badge:
  - `countActiveFilters()` helper counts non-empty filter values
  - DateRange values checked for from/to presence
  - Badge shown next to Filter icon when count > 0
- Active filter badges row:
  - Displays each active filter with label and value
  - Remove button (X icon) to clear individual filters
  - Only renders when activeFilterCount > 0
- Date formatting via date-fns:
  - Stores dates as ISO 'yyyy-MM-dd' strings
  - Displays ranges intelligently: "Feb 1 - 15, 2026" or "From Feb 1, 2026"
  - Uses `format()` from date-fns for consistent formatting
- Helper hook `useFilterBar(storageKey, defaultFilters)` exported:
  - Manages filter state with useState
  - Integrates localStorage persistence
  - Returns { filters, setFilters, clearFilters, searchValue, setSearchValue }
- Uses react-day-picker's `DateRange` type for calendar integration
- Uses shadcn/ui components: Button, Input, Badge, Calendar, Popover, Select
- Uses lucide-react icons: CalendarIcon, Search, X, Filter
- All logging via `logger` from `@/lib/logger` — no console.log
- All imports use `@/` alias as required

## task-040: Create usePagination hook
- Hook already existed at `src/hooks/usePagination.ts` with core functionality
- Updated return object to match PRD-specified API exactly:
  - `page: currentPage` — current page number (1-indexed)
  - `pageSize` — items per page
  - `offset: startIndex` — zero-indexed offset for database queries
  - `totalPages` — calculated from items.length / pageSize
  - `setPage: goToPage` — function to navigate to specific page
  - `setPageSize: changePageSize` — function to change page size (resets to page 1)
- URL persistence via React Router:
  - Uses `useSearchParams()` for URL search params integration
  - Page param stored as `urlKey` (default: 'page')
  - Page size param stored as `${urlKey}Size`
  - Only writes non-default values to URL (keeps URLs clean)
  - Uses `{ replace: true }` to avoid polluting browser history
- Configurable page sizes:
  - Default options: [10, 25, 50, 100] as specified in task
  - Override via `pageSizeOptions` option parameter
- Extended return object for backward compatibility:
  - `paginatedItems` — sliced array for client-side pagination
  - `currentPage`, `totalItems`, `startIndex`, `endIndex`, `pageSizeOptions`
  - Navigation helpers: `goToPage`, `nextPage`, `previousPage`, `changePageSize`
  - State booleans: `hasNextPage`, `hasPreviousPage`, `isFirstPage`, `isLastPage`
- Type-safe generic hook: `usePagination<T>(items: T[], options)`
- No console.log — no logging needed in this utility hook
- All imports use `@/` alias (none needed — only React and react-router-dom)

## task-041: Create shared page header component
- Created `src/components/admin/shared/PageHeader.tsx` — consistent header for all admin pages
- Props implemented exactly as task specified:
  - `title: string` — main page title
  - `subtitle?: string` — optional description text
  - `breadcrumbs?: BreadcrumbItem[]` — array of breadcrumb items
  - `actions?: ReactNode` — right-aligned action buttons/elements
  - `badge?: PageBadge` — optional status badge next to title
- BreadcrumbItem interface:
  - `label: string` — display text for breadcrumb
  - `href?: string` — optional path (will be prefixed with tenant slug)
- PageBadge interface:
  - `label: string` — badge text
  - `variant?: 'default' | 'secondary' | 'destructive' | 'outline'` — styling
  - `className?: string` — additional styles
- Tenant-aware breadcrumb links:
  - Uses `useTenantAdminAuth()` to get `tenantSlug` and `tenant`
  - `buildHref()` helper prefixes paths with `/${tenantSlug}` or `/${tenantSlug}/admin/`
  - Root breadcrumb always links to tenant dashboard
  - Tenant display name from `tenant.business_name` or formatted slug
- Layout structure:
  - Vertical spacing with `space-y-1`
  - Breadcrumb nav with ChevronRight separators
  - Title row with flexbox justify-between for actions alignment
  - Title can be truncated for long names
  - Badge displays inline next to title with flex-shrink-0
  - Actions container aligned right with gap-2 between buttons
- Uses shadcn/ui `Badge` component from `@/components/ui/badge`
- Uses lucide-react `ChevronRight` icon for breadcrumb separators
- Accessibility:
  - `aria-label="Page breadcrumb"` on nav element
  - `aria-current="page"` on last breadcrumb item
  - `title` attributes for truncated text
- Exports both named `PageHeader` and default export for flexible importing
- Also exports `BreadcrumbItem`, `PageBadge`, and `PageHeaderProps` types
- No console.log — pure UI component with no logging needed
- No tenant_id filtering in queries — uses context for tenant-aware URLs only
- All imports use `@/` alias as required
- Import order follows convention: React → Third-party → Components → Utils

## task-042: Create useBreadcrumbs hook
- Created `src/hooks/useBreadcrumbs.ts` — auto-generates breadcrumb trail from current route path
- Route segment mapping via `ROUTE_LABELS` constant:
  - Maps 80+ route segments to human-readable labels
  - Covers all admin routes: dashboard, orders, inventory, customers, vendors, menus, storefront, deliveries, analytics, settings
  - Handles nested routes: marketplace/listings, catalog/batches, storefront/products, etc.
- Dynamic entity resolution:
  - Detects UUIDs in path segments via regex
  - Determines entity type from parent segment using `ROUTE_TO_ENTITY` mapping
  - Fetches entity names via lightweight Supabase queries with tenant isolation
  - Supports: orders (order_number), products (name), customers (full_name), vendors (company_name), menus (name), invoices (invoice_number), deliveries, listings (title)
- Entity query configuration via `ENTITY_QUERY_CONFIG`:
  - Maps each entity type to table name, name column, and tenant column
  - Uses type assertion for dynamic table access: `(supabase as unknown as {...}).from(table)`
  - Graceful fallback to formatted ID when entity name not found
- Hook interface:
  - `useBreadcrumbs(options?)` returns `{ breadcrumbs, isLoading }`
  - `breadcrumbs: BreadcrumbItem[]` with `{ label, href }` structure
  - Options: `rootLabel` (override tenant name), `skipAdminSegment` (default: true)
- Root breadcrumb:
  - Uses tenant business name from `useTenantAdminAuth()` context
  - Falls back to 'Dashboard' if no tenant info available
  - Links to `/{tenantSlug}/admin/dashboard`
- Path building:
  - Filters out tenant slug and optionally 'admin' segment
  - Builds cumulative paths for each breadcrumb href
  - Skips duplicate segments that match root label
- TanStack Query integration:
  - Uses `useQuery` for entity name fetching with caching
  - `staleTime: 60_000` (1 minute) for entity names
  - Parallel fetching via `Promise.all` for multiple IDs
  - Only queries when tenantId available and IDs detected
- Helper function `formatSegment()`:
  - Converts kebab-case and snake_case to Title Case
  - Used for segments not in ROUTE_LABELS mapping
- All logging via `logger.warn` and `logger.error` from `@/lib/logger` — no console.log
- All imports use `@/` alias as required
- Import order: React → Third-party (react-router, tanstack) → Local imports

## task-043: Create shared sidebar navigation component
- Created `src/components/admin/shared/AdminSidebar.tsx` — main admin sidebar with collapsible sections
- Navigation sections implemented as specified:
  - Dashboard, Orders, Products & Inventory, Customers, Vendors, Menus & Storefront, Deliveries, Analytics, Settings
- Each section has collapsible behavior using shadcn/ui Collapsible component
- Collapsible state persisted to localStorage:
  - `SIDEBAR_COLLAPSED_KEY` — stores icon-only mode state
  - `SIDEBAR_SECTIONS_KEY` — stores section expanded/collapsed states
  - Uses try-catch wrapped localStorage operations for error safety
- Active item highlighting:
  - Uses `useLocation()` and `useParams()` from react-router-dom
  - `isActive()` function checks current pathname against item hrefs
  - Active items get `bg-accent` styling via Tailwind classes
- Badge counts for navigation items:
  - Props accept `badgeCounts` object with pendingOrders, lowStock, unreadNotifications, pendingDeliveries
  - Badges displayed next to item labels with destructive variant for low stock
  - In collapsed mode, shows red dot indicator instead of number badge
- Icon-only mode (collapsed sidebar):
  - `isCollapsed` state toggles between 64px and 256px width
  - Uses TooltipProvider/Tooltip for item labels in collapsed mode
  - Section headers hidden in collapsed mode, only icons shown
  - Persists collapsed state to localStorage
- Auto-expand section when it contains active item:
  - useEffect watches location.pathname changes
  - Expands relevant section automatically when route changes
- Tenant-aware navigation:
  - Uses `useTenantAdminAuth()` to get tenant slug and tenant info
  - All NavLink paths prefixed with `/${tenantSlug}`
  - Header shows tenant initial and business name
- Footer with low stock warning:
  - Shows AlertTriangle icon when lowStock count > 0
  - Tooltip in collapsed mode, full message in expanded mode
- Uses ScrollArea for navigation content to handle overflow
- No console.log — all logging via `logger` from `@/lib/logger`
- All imports use `@/` alias as required
- Note: This is a standalone simplified sidebar component
  - The codebase also has a more comprehensive AdaptiveSidebar at `src/components/admin/sidebar/`
  - This shared component provides a simpler API for pages that don't need the full feature set

## task-044: Create useSidebarBadges hook
- Created `src/hooks/useSidebarBadges.ts` — fetches badge counts for sidebar navigation items
- Returns `SidebarBadgeCounts` object with:
  - `pendingOrdersCount` — combined wholesale and menu orders in pending/processing states
  - `lowStockCount` — products with stock_quantity < 10
  - `unreadNotificationsCount` — notifications where is_read = false
  - `pendingDeliveriesCount` — deliveries in assigned/picked_up/in_transit states
- Uses TanStack Query with:
  - `refetchInterval: 30000` — 30 second polling as specified
  - `staleTime: 30000` — data considered stale after 30 seconds
  - Uses `queryKeys.sidebarBadges.counts(tenantId)` factory (already existed in queryKeys.ts)
- Lightweight count queries:
  - All queries use `select('*', { count: 'exact', head: true })` for efficient counting
  - No actual data is fetched, only counts — minimizes payload size
  - Parallel fetching via `Promise.all` for efficiency
- Tenant isolation:
  - All queries filter by `tenant_id` via `useTenantAdminAuth()` context
  - Only enabled when tenant.id is available
- Realtime subscriptions for instant updates:
  - 5 Supabase realtime channels subscribed:
    - `wholesale_orders` — any change triggers invalidation
    - `menu_orders` — any change triggers invalidation
    - `products` — UPDATE only, when stock_quantity changes
    - `notifications` — any change triggers invalidation
    - `wholesale_deliveries` — any change triggers invalidation
  - Each channel filtered by `tenant_id=eq.${tenantId}`
  - Invalidates TanStack Query cache on change via `queryClient.invalidateQueries`
  - Proper cleanup on unmount via useEffect return
  - `isSubscribed` state tracks subscription status
- Formatted badge values:
  - `formattedBadges` object returns display-ready values
  - Returns `null` if count is 0 (for conditional rendering)
  - Returns `'99+'` if count > 99 (for UI constraints)
  - Returns count as string otherwise
- Additional return values:
  - `totalCount` — sum of all badge counts
  - `hasAnyBadges` — boolean for quick check
  - `refresh()` — manual refetch function
- TypeScript interfaces exported:
  - `SidebarBadgeCounts`, `FormattedBadge`, `FormattedBadges`, `UseSidebarBadgesResult`
- Note: Existing `useAdminBadgeCounts.ts` hook has similar functionality but different API
  - This new hook follows the PRD specification exactly
  - Uses `useCallback`/`useMemo` for all computed values
- All logging via `logger.debug/error` from `@/lib/logger` — no console.log
- All imports use `@/` alias as required
- Import order: React → Third-party → Local imports

## task-045: Create shared admin layout wrapper
- Created `src/components/admin/shared/AdminLayout.tsx` — wraps all admin pages with consistent layout
- Main layout features:
  - Desktop sidebar: Uses AdminSidebar component (fixed position, sticky top, full height)
  - Mobile sidebar: Uses Sheet component (drawer sliding from left)
  - Top header bar with hamburger menu (mobile), command palette trigger, and notification bell
  - Main content area with responsive padding (p-4 on mobile, p-6 on desktop)
  - Optional page header via PageHeader component when title prop provided
- Layout context via React.createContext:
  - `useAdminLayout()` hook for nested components to access layout state
  - Context provides: isMobileSidebarOpen, toggleMobileSidebar, openMobileSidebar, closeMobileSidebar, isCompact
  - Error thrown if useAdminLayout used outside AdminLayout provider
- Header bar features:
  - Left side: hamburger menu (lg:hidden), tenant initial badge, tenant name (mobile only)
  - Right side: command palette trigger (search button), notification bell with unread badge
  - Sticky positioning with backdrop-blur effect for overlay content
  - Platform-aware keyboard shortcut hint (⌘K on Mac, Ctrl+K on Windows/Linux)
- Integration with existing hooks:
  - `useSidebarBadges` — provides badge counts to AdminSidebar
  - `useNotifications` — provides unread count for notification bell
  - `useCommandPaletteStore` — toggles command palette via Zustand store
  - `useTenantAdminAuth` — gets tenant context and validates tenantSlug
- Props interface includes:
  - `title`, `subtitle`, `breadcrumbs`, `badge`, `actions` — passed to PageHeader
  - `hideHeader` — option to hide page header when custom header needed
  - `compact` — minimal mode without sidebar for embedded views
  - `contentClassName`, `className` — additional styling hooks
- Compact mode:
  - No sidebar, just header bar and content
  - Used for embedded views, modals, or focused workflows
- Guard clause:
  - Returns null and logs error if tenantSlug is missing from URL params
  - Prevents rendering without valid tenant context
- Responsive design:
  - Desktop (lg+): Fixed sidebar, full content area
  - Mobile (<lg): Hidden sidebar, hamburger menu for Sheet drawer
  - Mobile sidebar uses Sheet from shadcn/ui for proper drawer behavior
  - SheetTitle with sr-only class for accessibility
- Uses shadcn/ui components: Button, Badge, Sheet/SheetContent/SheetTitle
- Uses lucide-react icons: Menu, Search, Bell, X
- No console.log — all logging via `logger` from `@/lib/logger`
- All imports use `@/` alias as required
- Import order: React → Third-party → Types → Components → Utils

## task-046: Create notification bell component
- Created `src/components/admin/shared/NotificationBell.tsx` — bell icon component for admin header
- Features implemented exactly as task specified:
  - Bell icon button with unread count badge (shows 99+ for large counts)
  - Click opens Popover dropdown with recent notifications
  - Notifications grouped by type (error, warning, success, info) with priority ordering
  - Each notification shows icon, title, message (truncated), and relative timestamp
  - Mark as read on click — automatically marks notification as read when clicked
  - Mark all as read button in header — clears all unread notifications
  - Entity navigation — notifications with entity_type and entity_id link to related entity via useEntityNavigation
- Integration with existing hooks:
  - Uses `useNotifications` hook from `@/hooks/useNotifications` for data and mutations
  - Uses `useEntityNavigation` hook from `@/hooks/useEntityNavigation` for cross-module navigation
  - Realtime updates come from useNotifications subscription (already built into the hook)
- Entity type mapping:
  - Created `ENTITY_TYPE_MAP` to convert lowercase entity_type strings to EntityType constants
  - Handles variants like 'order' → 'ORDER', 'orders' → 'ORDER', 'disposable_menu' → 'MENU'
- Visual design:
  - Notification type icons: Info, AlertTriangle, AlertCircle, CheckCircle2 from lucide-react
  - Color coding by type: blue (info), amber (warning), red (error), green (success)
  - Unread indicator: blue dot next to unread notifications + background highlight
  - Read indicator: Check icon for already-read notifications
  - External link icon for notifications with entity links
- Grouping logic:
  - Groups notifications by type using reduce pattern
  - Displays groups in priority order: errors → warnings → success → info
  - Empty groups are filtered out (no empty sections)
  - Separator between groups for visual clarity
- Props interface:
  - `className` — additional styling for the button
  - `maxNotifications` — limit displayed notifications (default: 20)
- Uses shadcn/ui components: Button, Badge, ScrollArea, Separator, Popover/PopoverContent/PopoverTrigger
- Uses date-fns `formatDistanceToNow` for relative time formatting
- Accessibility: aria-label on button includes unread count, proper role on popover content
- Loading state: spinner shown while notifications are loading
- Empty state: bell icon with "No notifications" message
- All logging via `logger` from `@/lib/logger` — no console.log
- All imports use `@/` alias as required
- Import order: React → Third-party → Types → Components → Utils

## task-047: Create useOnlineStatus hook
- Extended existing simple `src/hooks/useOnlineStatus.ts` with comprehensive features
- Previous implementation was basic (just tracked navigator.onLine), now fully featured
- Core features implemented:
  - Tracks browser online/offline status via window 'online'/'offline' events
  - Integrates with TanStack Query's `onlineManager` for mutation queueing
  - When offline: sets `onlineManager.setOnline(false)` to pause mutations
  - When online: sets `onlineManager.setOnline(true)` to resume queued mutations
  - Shows sync indicator when reconnecting (5 second RECONNECTING_TIMEOUT_MS)
  - Publishes `connection_status` events to eventBus for cross-module awareness
- Added `connection_status` event type to `@/lib/eventBus`:
  - Payload: `{ tenantId, status, previousStatus, timestamp }`
  - Status values: 'online' | 'offline' | 'reconnecting'
- State management:
  - `isOnline` — current browser online status
  - `isReconnecting` — transitional state after coming back online
  - `isSyncing` — whether mutations are being replayed
  - `showBanner` — whether offline banner should be displayed
  - `queuedMutationsCount` — number of queued mutations
  - `lastOnlineAt` / `lastOfflineAt` — timestamps for debugging
- Hook returns:
  - `state: OnlineStatusState` — combined state object
  - `isOnline`, `isReconnecting`, `showBanner`, `isSyncing` — individual state values
  - `queuedMutationsCount` — pending mutation count
  - `checkConnection()` — manual connection check trigger
  - `dismissBanner()` — temporarily dismiss the offline banner
  - `connectionStatus` — 'online' | 'offline' | 'reconnecting' string
- Options interface:
  - `autoDismissBannerDelay` — ms to wait before auto-dismissing banner (default: 3000)
  - `publishEvents` — whether to publish to eventBus (default: true)
- Uses `useTenantContext()` for tenant context in eventBus events
- Uses `useRef` for mounted check and timeout refs to prevent memory leaks
- Proper cleanup on unmount: clears timeouts, removes event listeners, unsubscribes from onlineManager
- All callbacks memoized with `useCallback`, all computed values with `useMemo`
- All logging via `logger` from `@/lib/logger` — no console.log
- All imports use `@/` alias as required
- Import order: React → Third-party → Local imports
## task-048: Create shared stats card component
- Created `src/components/admin/shared/StatsCard.tsx` — reusable stat card for dashboards
- Props interface `StatsCardProps`:
  - `title` — title displayed above the value
  - `value` — main value (string or number)
  - `change` — percentage change value (optional)
  - `trend` — direction: 'up' | 'down' | 'flat' (optional, default: 'flat')
  - `icon` — LucideIcon component (optional)
  - `onClick` — click handler for navigation (optional)
  - `loading` — loading state (optional, default: false)
  - `data` — number array for sparkline visualization (optional)
  - `subtitle` — additional description text (optional)
  - `className` — custom styling (optional)
- Built-in `Sparkline` component for mini chart visualization:
  - Renders SVG path from data array
  - Calculates min/max for proper scaling
  - Uses green/red color based on trend direction (first vs last value)
  - Only renders if data has 2+ points
- `StatsCardSkeleton` component for loading state with proper skeleton layout
- Change percentage formatting:
  - Shows + sign for positive, no sign for negative
  - Fixed to 1 decimal place
  - Green color for positive, red for negative, muted for zero
- Trend indicator:
  - Uses TrendingUp, TrendingDown, or Minus icons from lucide-react
  - Color-coded: green for up, red for down, muted for flat
- Accessibility features:
  - Clickable cards have role="button" and tabIndex for keyboard navigation
  - handleKeyDown for Enter/Space key activation
  - aria-label describing the stat and click action
  - Icons marked aria-hidden
- Helper component `StatsCardGrid`:
  - Responsive grid layout with configurable columns (2, 3, or 4)
  - Grid classes adjust for different breakpoints
- All imports use `@/` alias as required
- Import order: React → Third-party (lucide-react) → Components → Utils
- All callbacks memoized with `useCallback`, computed values with `useMemo`
- No console.log — follows project logging standards

## task-049: Create useModuleHealth hook
- Created `src/hooks/useModuleHealth.ts` to check health/connectivity of each module
- Returns status object with module name and status (healthy/degraded/error)
- Checks 6 core modules: products, orders, customers, inventory, deliveries, menus
- Each module health check performs a lightweight query (limit 1) filtered by tenant_id
- Status calculation:
  - `healthy`: Query succeeds with latency < 2000ms
  - `degraded`: Query succeeds but latency > 2000ms, or table not initialized
  - `error`: Query fails with error
- Overall status: error if any module has error, degraded if any degraded, otherwise healthy
- Uses TanStack Query with:
  - 1 minute staleTime to avoid excessive checking
  - 5 minute refetchInterval for background monitoring
  - refetchOnWindowFocus disabled to prevent spamming
- Exported types: ModuleStatus, ModuleHealthCheck, ModuleHealthSummary
- `checkModule(moduleName)` function for on-demand individual module checks
- Summary includes healthyCount, degradedCount, errorCount, totalModules
- Added moduleHealth query keys to queryKeys.ts
- Used `useTenantAdminAuth()` for tenant context
- All logging via `logger` from `@/lib/logger` — no console.log
- TypeScript: Used `unknown` with explicit type casting for Supabase queries to handle dynamic tables

## Task 050: Create order creation with inventory validation

### What was implemented:
- Enhanced `src/components/crm/LineItemsEditor.tsx` with real-time inventory validation
- Updated `src/components/crm/CreateOrderForm.tsx` with submission blocking for stock issues

### Key changes to LineItemsEditor.tsx:
- Added `InventoryValidationResult` interface for validation state
- Created `productMap` (useMemo) for O(1) product lookups by ID
- Added `validateInventory()` callback that checks all line items against available stock
- Added `getStockInfo()` callback to retrieve stock details for individual items
- New Stock column in table showing available quantity with visual indicators:
  - Package icon colored by stock status (destructive/amber/muted)
  - AlertTriangle icon for out-of-stock or insufficient stock items
  - Tooltip with detailed stock info on hover
- Quantity input now shows red border when stock issue detected
- "Max: X" label shown below quantity when quantity exceeds available
- Row background tints red when stock issue detected
- `onValidationChange` callback prop notifies parent of validation state changes

### Key changes to CreateOrderForm.tsx:
- Added `inventoryValidation` state to track validation from LineItemsEditor
- `handleInventoryValidationChange` callback passed to LineItemsEditor
- `hasInventoryIssues` and `canSubmit` computed values for submission logic
- Form submission blocked when inventory validation fails
- Alert banner shown above products table when issues detected:
  - Destructive variant for out-of-stock items (lists product names)
  - Amber warning for insufficient stock (shows requested vs available)
- Submit button:
  - Disabled when inventory issues present
  - Shows AlertTriangle icon instead of Save when issues detected
  - Text changes to "Fix Inventory Issues" when blocked
- Toast error messages on blocked submission attempts

### Technical details:
- Used existing `useProducts` hook which already includes stockQuantity, isOutOfStock, isLowStock
- No console.log — all logging via logger from @/lib/logger
- Proper imports with @/alias
- TypeScript clean with proper typing for InventoryValidationResult
- Used useMemo for validation effect to notify parent on items/products changes
- Used useCallback for memoized handlers

## task-051: Create order confirmation inventory decrement
- Created `src/hooks/useOrderConfirmation.ts` to handle order confirmation with automatic inventory decrement
- Hook accepts orderId and optionally skipInventoryDecrement flag
- Fetches order with items from unified_orders + unified_order_items tables
- Updates order status to 'confirmed' first, then processes inventory
- For each order item:
  - Fetches current product stock_quantity from products table
  - Decrements stock using Math.max(0, previous - quantity) to prevent negative values
  - Updates both stock_quantity and available_quantity on product
  - Logs to inventory_history with:
    - change_type: 'sale'
    - reason: 'order_confirmed'
    - reference_type: 'order_confirmed'
    - reference_id: orderId
    - Includes metadata with order_id, order_number, order_item_id, source
- Returns DecrementResult[] with success/failure status for each item
- Implements TanStack Query mutation with:
  - Optimistic update in onMutate (marks order as confirmed in cache)
  - Context for rollback on error
  - Uses invalidateOnEvent for cross-panel invalidation
  - Invalidates orders.all, products.all, inventory.all queries
- Shows success/error toasts using showSuccessToast/showErrorToast
- All logging via logger from @/lib/logger — no console.log
- Uses @/ alias for all imports
- Filters all queries by tenant_id
- Uses useTenantAdminAuth for tenant context
- Uses .maybeSingle() for optional data fetching


## task-052: Create order cancellation inventory restore
- Created `src/hooks/useOrderCancellation.ts` for order cancellation with inventory restoration
- When order is cancelled, increments each product's stock_quantity by the cancelled quantity
- Updated `OrderCancelModal.tsx` to use new `useOrderCancellation` hook instead of `useCancelOrder`
- Hook implementation:
  - Fetches order with items from unified_order_items
  - Validates order can be cancelled (not already cancelled, not delivered)
  - Updates order status to 'cancelled' with timestamp and reason
  - For each order item, restores inventory:
    - Fetches current product stock
    - Increments stock_quantity and available_quantity by item.quantity
    - Logs to inventory_history with:
      - change_type: 'return'
      - reason: 'order_cancelled'
      - reference_type: 'order_cancelled'
      - reference_id: orderId
      - Includes metadata with order_id, order_number, cancellation_reason, source
- Returns RestoreResult[] with success/failure status for each item restored
- Implements TanStack Query mutation with:
  - Optimistic update in onMutate (marks order as cancelled in cache)
  - Context for rollback on error
  - Uses invalidateOnEvent for ORDER_STATUS_CHANGED and INVENTORY_ADJUSTED
  - Invalidates orders.all, products.all, inventory.all, stockAlerts.all, dashboard.all, analytics.all
- OrderCancelModal already has confirmation dialog with:
  - Cancellation reason selector
  - Optional notes field
  - "Restock Items" checkbox (restoreInventory option)
- Shows success toast with count of items restored and total units
- Shows error toast on failure
- All logging via logger from @/lib/logger — no console.log
- Uses @/ alias for all imports
- Filters all queries by tenant_id
- Uses useTenantAdminAuth for tenant context
- Uses .maybeSingle() for optional data fetching


## task-053: Create order-customer link in order list
- Enhanced `src/components/admin/cross-links/CustomerLink.tsx` component:
  - Added customer avatar with initials fallback using Avatar component from shadcn/ui
  - Shows "Walk-in" label with User icon when no customer is assigned (customerId is null/undefined)
  - Tooltip shows customer email on hover using Tooltip component from shadcn/ui
  - Uses `useEntityNavigation` hook to generate customer detail page URLs via getEntityUrl("CUSTOMER", customerId)
  - Added customerEmail and customerAvatar props for enhanced display
  - Added showAvatar prop (default: true) to optionally hide avatar
  - getInitials() helper function extracts initials from customer name for avatar fallback
- Updated `src/components/admin/orders/OrderRow.tsx`:
  - Added imports for CustomerLink from @/components/admin/cross-links
  - Extended OrderRowProps.order interface with user_id, customer_id, and avatar_url
  - Replaced plain text customer display with CustomerLink component
  - Passes customerId, customerName, customerEmail, and customerAvatar to CustomerLink
- Updated `src/pages/admin/Orders.tsx`:
  - Updated all three CustomerLink usages to pass customerEmail prop for tooltip functionality
  - Desktop table column, mobile renderer, and drawer all use enhanced CustomerLink
- All logging uses logger from @/lib/logger — no console.log
- Uses @/ alias for all imports
- Import order follows: React → Third-party → Components → Utils pattern
- TypeScript compiles without errors


## task-054: Create order-customer automatic association
- Created `src/hooks/useCustomerLookup.ts` hook:
  - Searches customers by phone or email using Supabase
  - Debounced search (400ms) with minimum 3 characters
  - Returns CustomerMatch interface with id, first_name, last_name, full_name, email, phone
  - Provides selectCustomer, searchByPhone, searchByEmail, clear functions
  - Includes createCustomer mutation to create new customer from order details
  - Uses useTenantAdminAuth for tenant context
  - All queries filtered by tenant_id
  - Uses logger from @/lib/logger for error handling
  - Uses queryKeys for cache management

- Created `src/components/admin/orders/CustomerAutoAssociation.tsx` component:
  - Auto-searches customers when phone (7+ digits) or email is entered
  - Shows dropdown with matched customers
  - Selected customer displayed as card with avatar, name, contact info, "Linked" badge
  - "Create new customer" button opens dialog to create customer from order details
  - Uses Avatar, Card, Badge, Dialog components from shadcn/ui
  - Toast notifications for customer linked/created success
  - Disabled state when offline
  - getInitials() helper for avatar fallback

- Updated `src/hooks/useOfflineOrderCreation.ts`:
  - Added customerId field to OfflineOrderData interface
  - Updated syncSingleOrder to include customer_id when inserting order to Supabase

- Updated `src/pages/admin/OfflineOrderCreate.tsx`:
  - Added linkedCustomer state to track associated customer
  - Integrated CustomerAutoAssociation component in Customer Details section
  - Passes customerId to createOfflineOrder when customer is linked
  - Clears linkedCustomer on form reset
  - Component disabled when offline (customer lookup requires network)

- All logging uses logger from @/lib/logger — no console.log
- Uses @/ alias for all imports
- Import order follows: React → Third-party → Types → Components → Utils pattern
- TypeScript compiles without errors
- All Supabase queries filter by tenant_id


## task-055: Create order detail page with related entities panel
- Created `src/components/admin/orders/OrderRelatedEntitiesPanel.tsx`:
  - Unified panel showing all related entities for an order
  - Uses `useRelatedEntities('order', orderId)` hook for data fetching
  - Displays 4 main sections: Customer, Products, Payment, Delivery

- Customer Section:
  - Shows customer avatar with initials fallback (getInitials helper)
  - Displays name, email, phone in compact card format
  - Clickable to navigate to customer detail page via useTenantNavigation
  - Shows "Guest Order" placeholder when no customer linked
  - Keyboard accessible with tabIndex and onKeyDown handler

- Products Section:
  - Horizontal scrollable thumbnails using ScrollArea
  - Each product shows image (or Package icon placeholder), name, quantity badge
  - Products clickable to navigate to product detail page
  - Shows empty state with Package icon when no products

- Payment Section:
  - Visual status indicator with color coding (success/warning)
  - Shows CheckCircle for paid, Clock for pending, AlertCircle for no payment
  - Displays amount, payment method, paid timestamp, transaction ID
  - Status badge with appropriate background colors

- Delivery Section:
  - Status with color-coded background (pending, assigned, in_transit, delivered, failed)
  - Shows courier name and phone if assigned
  - Scheduled and delivered timestamps
  - Track button opens tracking_url in new tab

- Updated `src/pages/admin/OrderDetailsPage.tsx`:
  - Added import for OrderRelatedEntitiesPanel
  - Added component to sidebar section after Notes card
  - Component receives orderId from order state

- Technical implementation:
  - Uses TypeScript generics with OrderRelatedEntities type guard
  - Loading skeleton shows while data fetches
  - Error state with AlertCircle icon on fetch failure
  - Uses Separator between sections for visual clarity
  - All navigation via useTenantNavigation for tenant-aware routing

- No console.log — all error handling via component state
- Uses @/ alias for all imports
- Import order follows: React → Third-party → Types → Components → Hooks → Utils
- TypeScript compiles without errors

## task-056: Create order timeline component
- Created `src/components/admin/orders/OrderTimeline.tsx` for chronological order event display
- Component fetches from `activity_log` table filtered by `entity_type=order` and `entity_id`
- Event types supported: created, confirmed, payment_received, items_picked, out_for_delivery, delivered, cancelled, refunded, updated
- Each event displays: timestamp with smart formatting, relative time, user/actor info, and optional notes
- Uses `useTenantAdminAuth()` to get tenant context (following CLAUDE.md rules)
- TanStack Query for data fetching with proper queryKeys from `@/lib/queryKeys`
- Realtime subscription via `useRealTimeSubscription` hook for live updates on INSERT events
- Callback filters by entity_type and entity_id to only refresh for relevant order events
- UI uses shadcn/ui components: Card, Badge, ScrollArea, Skeleton, Avatar, Tooltip
- Loading skeleton and empty state for proper UX
- Error state with user-friendly message
- All logging uses `logger` from `@/lib/logger` — no console.log
- Imports use `@/` alias as required
- TypeScript types imported from `@/lib/activityLog` for ActivityLogEntry

## task-057: Create order status change with notification dispatch
- Created `src/hooks/useOrderStatusNotification.ts` for automatic notification dispatch on order status changes
- Hook subscribes to `order_updated` and `order_created` events from the event bus
- Notification targets based on status:
  - Admin: notified on new order (created/pending), confirmed, delivered, cancelled, refunded
  - Delivery runner: notified on confirmed (if runner_id is assigned)
  - Customer: notified on out_for_delivery and delivered (if contact info exists)
- Each notification includes order number, customer name, and new status
- Fetches order info from `unified_orders` with joined runner profile for runner name
- Uses `logActivity` from `@/lib/activityLog` to log status changes with metadata
- Creates notifications via direct Supabase insert to `notifications` table
- Publishes `notification_sent` event after dispatching notifications
- Provides `dispatchStatusNotification` function for manual dispatch
- Uses `useTenantContext` for tenant isolation — all DB queries filter by tenant_id
- Proper cleanup: useRef for mounted check, unsubscribe on unmount
- All logging uses `logger` from `@/lib/logger` — no console.log
- Imports use `@/` alias as required
- TypeScript types: OrderStatus, NotificationRecipient, OrderInfo interfaces

## task-058: Create order payment status sync
- Created `src/components/admin/orders/OrderPaymentStatusSync.tsx` component
- Shows payment status from payments table on order detail page
- If payment is pending, shows "Record Payment" button with dialog
- If paid, displays payment method, transaction ID, and paid date
- Real-time updates via Supabase subscription on payments table using `useRealTimeSubscription` hook
- Auto-updates order payment_status field when payment is completed (configurable via prop)
- Invalidates order queries on payment change for immediate UI updates
- Uses TanStack Query for data fetching with proper query keys
- Added `byOrder` query key to `queryKeys.payments` in `src/lib/queryKeys.ts`
- Payment dialog allows selecting payment method and entering transaction ID
- Gracefully handles missing payments table (fallback to order payment_status)
- Integrated into `OrderDetailsPage.tsx` replacing static payment status display
- Uses `useTenantAdminAuth` for tenant context
- Subscription status indicator shows real-time connection state
- All logging uses `logger` from `@/lib/logger` — no console.log
- Imports use `@/` alias as required
- TypeScript types: PaymentRecord, OrderPaymentStatusSyncProps interfaces

## task-059: Create order delivery status sync
- Created `src/components/admin/orders/OrderDeliveryStatusSync.tsx` component
- Component displays delivery status on order detail page when order has associated delivery
- Shows runner name, current status, estimated time, and real-time location (lat/lng)
- Used `useRealTimeSubscription` hook for Supabase realtime updates on deliveries table
- Filters by `tenant_id` and `order_id` for proper tenant isolation
- Auto-updates order status to "delivered" when delivery is marked completed
- Uses `queryKeys.deliveries.byOrder(tenantId, orderId)` for query caching
- Component returns `null` if no delivery exists, avoiding unnecessary UI clutter
- Added "View on Map" button that opens Google Maps with delivery coordinates
- Real-time connection status indicator shows live subscription state
- Integrated into `OrderDetailsPage.tsx` in the sidebar section after payment status
- All imports use `@/` alias, no `console.log`, uses `logger` from `@/lib/logger`
- Loading and error states with retry button included

## task-060: Create order product quick view
- Created `src/components/admin/orders/OrderProductQuickView.tsx` component
- Component opens a `DetailPanel` slide-over when clicking a product in order items
- Shows product details: image, description, current stock level, vendor, category
- Includes price information: retail, wholesale, cost per unit
- Displays cannabis-specific info: strain name, strain type, THC/CBD percentages
- Shows price history if `product_price_history` table exists (graceful fallback)
- Stock status badges: "In Stock", "Low Stock", "Out of Stock" based on quantity vs threshold
- "View Full Page" action button navigates to full product page
- Integrated into `OrderDetailsPage.tsx` by making order item rows clickable
- Added "Click to view details" hint text for products with `product_id`
- Uses `useTenantAdminAuth` for tenant context, filters by `tenant_id`
- All imports use `@/` alias, no `console.log`, uses `logger` from `@/lib/logger`
- TypeScript interfaces: ProductDetails, PriceHistoryEntry
- Query keys: `queryKeys.products.detail(tenantId, productId)`
- Loading states handled with DetailPanel's built-in loading prop
- Error handling shows friendly message when product fetch fails

## task-061: Create order items with real-time stock display
- Enhanced `src/components/crm/LineItemsEditor.tsx` with real-time stock updates
- Added Supabase realtime subscription using `useRealTimeSubscription` hook
- Subscription listens to `products` table UPDATE events filtered by `account_id`
- When product stock changes, invalidates TanStack Query and refetches products
- Tracks previous stock levels in `useRef` to detect changes
- Shows warning banner when stock drops below requested quantity while editing
- Toast notification alerts user immediately when stock drops
- Visual indicators: 
  - Green pulsing dot in table header when real-time connected
  - "Live stock updates" status indicator above table
  - Yellow warning banner with affected products list
  - Dismiss button to clear individual warnings
- Prevents over-ordering: validation shows insufficient stock errors
- Existing features preserved: stock display per line item, tooltips, color-coded warnings
- Connection status states: connected, connecting, error, disconnected
- All imports use `@/` alias, no `console.log`, uses `logger` from `@/lib/logger`
- New dependencies added: `useRealTimeSubscription`, `useAccountIdSafe`, `useQueryClient`, `toast`
- TypeScript interface: `StockChangeWarning` for tracking stock changes

## task-062: Create order duplicate/reorder functionality
- Created `src/components/admin/orders/DuplicateOrderButton.tsx`
- Features implemented:
  - "Duplicate Order" button on order detail page
  - Dialog that validates current stock availability before creating duplicate
  - Shows table of items with requested quantity vs available stock
  - Status badges: OK (green), Partial (amber), Out of Stock (red)
  - Alert banners for all-items-in-stock, stock-warning, or all-out-of-stock
  - Checkbox option to include partial stock items (uses available quantity)
  - Summary showing how many items will be included
- Creates new order in `unified_orders` table with:
  - Same customer_id, wholesale_client_id, delivery_address
  - Notes prefixed with "[Reorder from #ORDER_NUMBER]"
  - Status: 'pending', payment_status: 'unpaid', source: 'admin'
- Creates order items in `unified_order_items` table
- Navigates to new order on successful creation
- Integrated into `OrderDetailsPage.tsx` header actions area
- Uses TanStack Query for stock validation with `staleTime: 0` for fresh data
- Uses `useTenantAdminAuth()` for tenant context
- All imports use `@/` alias, no `console.log`, uses `logger` from `@/lib/logger`
- Error handling with toast notifications
- Loading states for stock validation and order creation

## task-063: Create order notes with @mentions
- Created `src/components/admin/orders/OrderThreadedNotes.tsx`
- Features implemented:
  - Internal notes section added to order detail page sidebar
  - Staff can add notes with @mentions of other team members
  - Mention popover with team member search (filters by name/email)
  - When mentioned, users receive notification via `useNotificationDispatcher`
  - Notes displayed as threaded comments with user avatars
  - Avatar fallback shows initials from name or email
  - Real-time updates via Supabase channel subscription
  - Mentions highlighted in display with `@name` styling
- Mention system:
  - Type `@` to trigger mention popover
  - Click @ button in textarea corner as shortcut
  - Mentions stored as `@[Name](user_id)` format internally
  - Displayed as highlighted `@name` in note content
  - `mentioned_user_ids` array stored for notification dispatch
- Database expectations:
  - `order_notes` table with: id, tenant_id, order_id, user_id, content, mentioned_user_ids, created_at
  - Join to `tenant_users` for user info display
  - Graceful handling if table doesn't exist yet (returns empty array)
- Integration:
  - Added to `OrderDetailsPage.tsx` sidebar after Notes card
  - Receives `orderId` and `orderNumber` props
- Uses TanStack Query for data fetching and caching
- Uses `useTenantAdminAuth()` for tenant context and current user
- Uses `useNotificationDispatcher().dispatchNotification()` for mentions
- All imports use `@/` alias, no `console.log`, uses `logger` from `@/lib/logger`
- Loading and empty states with skeleton and placeholder UI
- Error handling with toast notifications

## task-064: Create Supabase migration for order_notes table
- Created `supabase/migrations/20260210000001_add_order_notes.sql`
- Columns implemented:
  - id UUID PRIMARY KEY with gen_random_uuid() default
  - tenant_id UUID NOT NULL REFERENCES tenants(id) ON DELETE CASCADE
  - order_id UUID NOT NULL REFERENCES orders(id) ON DELETE CASCADE
  - user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE
  - content TEXT NOT NULL for note text
  - mentioned_user_ids UUID[] DEFAULT '{}' for @mention tracking
  - created_at TIMESTAMPTZ DEFAULT NOW()
- Indexes created:
  - idx_order_notes_tenant_id for tenant filtering
  - idx_order_notes_order_id for order lookups
  - idx_order_notes_user_id for user activity queries
  - idx_order_notes_order_created for chronological listing (order_id, created_at DESC)
- RLS policies:
  - SELECT: tenant_users can view notes in their tenant
  - INSERT: tenant_users can add notes to orders in their tenant
  - UPDATE: users can edit their own notes (with tenant membership check)
  - DELETE: users can delete their own notes (with tenant membership check)
  - ALL: tenant admins/owners can manage all notes in their tenant
- Supports the OrderThreadedNotes component from task-063
- Follows project naming convention with timestamp prefix
- All foreign keys cascade on delete for data integrity

## Task 065: Create order print/receipt generation
Date: Tue, Feb 10, 2026 12:43:58 AM

### What was implemented:
- Created src/components/admin/orders/OrderReceipt.tsx
- Generates printable receipt for orders with:
  - Business name from tenant settings via useTenantAdminAuth()
  - Order number, date, status
  - Customer info (name, email, phone, address)
  - Line items with product name, quantity, and prices
  - Subtotal, discount, tax, delivery fee, and total
  - Payment method and status
  - Optional order notes
  - Thank you message and print timestamp

### Key features:
- ReceiptContent: forwardRef component for the actual receipt layout
- OrderReceipt: Main component with Card wrapper and action buttons
- Print button opens browser print dialog with print-optimized CSS
- PDF export using jsPDF with receipt-sized format (80mm width)
- useOrderReceipt hook for programmatic receipt generation

### Technical details:
- Uses useTenantAdminAuth() to get tenant.business_name for receipt header
- Uses logger from @/lib/logger for all logging (no console.log)
- Uses formatCurrency from @/utils/formatters for price formatting
- Uses date-fns format() for date/time formatting
- Loading state with Skeleton component while auth loads
- Error handling with toast notifications
- Print window handles popup blockers gracefully

### Lessons learned:
- jsPDF supports custom page sizes - [80, 200] creates receipt-width paper
- Browser print dialogs need complete HTML documents with inline styles
- forwardRef is needed to pass refs to child components for print content extraction
- The Tenant type from TenantAdminAuthContext has business_name property
- Receipt components should support both inline display and standalone printing

## Task-066: Create order analytics connection

### What was built:
- OrderAnalyticsInsights component showing contextual analytics for orders
- Displays insights about customer order history and comparisons
- Shows whether this is the customer's largest order
- Compares order to customer's average and tenant's AOV
- Shows time of day the order was placed
- Identifies new products the customer is trying
- Indicates customer loyalty status (first order, loyal customer)

### Files created/modified:
- NEW: src/components/admin/orders/OrderAnalyticsInsights.tsx
- MODIFIED: src/pages/admin/OrderDetailsPage.tsx (added import and component)

### Technical details:
- Uses useTenantAdminAuth() to get tenant context for filtering
- Queries unified_orders table filtered by tenant_id and customer_id
- Queries unified_order_items to analyze customer's product history
- Calculates tenant-wide AOV from last 90 days of orders
- Uses TooltipProvider for insight descriptions
- Skeleton loading state while data loads
- Returns null if no insights to display (graceful empty state)
- Uses logger from @/lib/logger (no console.log)
- All imports use @/ alias

### Insights shown:
1. Largest Order indicator if this is customer's biggest order
2. Customer Average comparison (above/below their typical order)
3. Store AOV comparison (percentage above/below store average)
4. Order Time showing time of day with emoji (Morning/Afternoon/Evening/Night)
5. New Products count if customer is trying products they haven't ordered before
6. Loyalty indicator (first order vs loyal customer with order count)

### Lessons learned:
- useMemo is good for deriving insight arrays from analytics data
- TooltipProvider must wrap Tooltip components for tooltips to work
- Conditional rendering with early returns keeps component clean
- Comparing order total to averages requires careful percentage calculations
- Time of day can be derived from order.created_at timestamp
- Product history analysis requires joining order_items with orders

## task-067: Create order filters with cross-module data
- Created `src/components/admin/orders/OrderFilters.tsx` component
- Integrated with existing `FilterBar` component from `src/components/admin/shared/FilterBar.tsx`
- Implemented filters for: status, customer name, product name, payment status, delivery status, order source, date range, and order total range (min/max)
- Created `useCustomerOptions` hook to fetch customer names from `profiles` table
- Created `useProductOptions` hook to fetch active products from `products` table filtered by tenant_id
- Used `useOrderFilters` hook (wraps `useFilterBar`) for localStorage persistence
- Updated `OrdersListPage.tsx` to fetch cross-module data:
  - Extended order query to include `payment_status` and `order_source`
  - Fetch `order_items` with product names for product filtering
  - Fetch `deliveries` table for delivery status filtering
- Client-side filtering with AND logic in `filteredOrders` useMemo
- Date range filtering uses `isWithinInterval` from date-fns with proper day boundaries
- Total amount range supports min and max with number inputs
- Active filters displayed as removable chips via `FilterBar`
- Stats cards now reflect filtered order counts
- Empty state message adjusts when filters are active
- All imports use `@/` alias, all logging uses `logger` from `@/lib/logger`
- No TypeScript errors, no `any` types used

## task-068: Create order bulk status update
- Enhanced `src/hooks/useOrderBulkStatusUpdate.ts` with three key features:
  1. **Activity Logging**: Uses `logActivities` from `@/lib/activityLog` to batch-log status changes for all successfully updated orders. Each log entry includes order_number, bulk_operation flag, and total_in_batch metadata.
  2. **Notification Dispatch**: Created `createBulkStatusNotification` function that inserts notifications to Supabase `notifications` table with tenant isolation. Shows success/warning type based on failed count.
  3. **Inventory Sync for Cancellations**: Created `restoreInventoryForCancelledOrders` function that restores stock_quantity and available_quantity for products from cancelled orders. Logs changes to `inventory_history` table with reason `bulk_order_cancelled`.
- Added optional `userId` parameter to hook options for activity logging attribution
- Updated `src/components/admin/orders/BulkOrderActions.tsx` to pass `admin?.id` as userId from `useTenantAdminAuth()`
- Updated `src/pages/admin/Orders.tsx` to also pass userId for the inline bulk status handler
- All database queries filter by `tenant_id` for proper multi-tenant isolation
- Uses existing progress bar via `BulkOperationProgress` component (no changes needed)
- Toast notifications show success count and failure count
- Cross-panel invalidation via `invalidateOnEvent` for ORDER_STATUS_CHANGED, INVENTORY_ADJUSTED
- Additional query invalidations for activity queries after bulk updates
- No `console.log` statements — all logging via `logger` from `@/lib/logger`
- All imports use `@/` alias
- TypeScript compiles with no errors

## task-069: Create order bulk assignment to runner
- Created `src/hooks/useOrderBulkRunnerAssign.ts` - new hook for bulk assigning orders to delivery runners
  - Processes orders in batches of 5 for progress visibility
  - For each order: creates delivery record in `wholesale_deliveries`, updates order status to `assigned` with `courier_id`
  - Includes rollback if order update fails after delivery creation
  - Activity logging via `logActivities` with metadata including runner_name, bulk_operation flag
  - Notifications: admin notification for bulk completion, runner notification for new assignments
  - Cross-panel invalidation via `invalidateOnEvent` for DRIVER_ASSIGNED event
  - Query invalidations for orders, runners, wholesale-deliveries, fulfillment
- Created `src/components/admin/orders/BulkAssignRunnerDialog.tsx` - dialog component for bulk runner assignment
  - Uses `useAvailableRunners` hook to fetch runners list
  - Shows selected orders summary with badges (max 10 displayed, +N more for overflow)
  - Runner dropdown shows name, rating, and status badge
  - Selected runner details card with phone, total deliveries, vehicle info
  - Warning message when assigning to non-available runner
  - Progress bar via `BulkOperationProgress` for large batches
- Updated `src/components/admin/orders/index.ts` to export `BulkAssignRunnerDialog`
- Updated `src/pages/admin/Orders.tsx`:
  - Added `UserPlus` icon import from lucide-react
  - Added `BulkAssignRunnerDialog` import
  - Added `assignRunnerDialogOpen` state
  - Added "Assign Runner" action to BulkActionsBar with UserPlus icon
  - Integrated BulkAssignRunnerDialog with proper props (selectedOrders, onSuccess handler)
- All database queries filter by `tenant_id` for proper multi-tenant isolation
- No `console.log` statements — all logging via `logger` from `@/lib/logger`
- All imports use `@/` alias
- TypeScript compiles with no errors, Vite build succeeds

## task-070: Create order export with related data
- Completely rewrote `src/components/admin/orders/OrderExportButton.tsx` with enhanced export functionality:
  - Uses `useExport` hook with proper `ExportColumn<T>` configuration for CSV export
  - Supports both CSV and JSON export formats (dropdown menu with format selection)
  - Includes all required related data fields:
    - Customer name (from order.user.full_name or order.customer_name)
    - Customer email (from order.user.email or order.customer_email)
    - Customer phone (from order.user.phone or order.customer_phone)
    - Product names (comma-separated list of all order items)
    - Payment status (from order.payment_status or inferred from order status)
    - Delivery status (from order.delivery_status or mapped from order status)
    - Order source (storefront, admin, POS, API, menu)
  - Full line items detail option creates multiple rows per order with item-level data
  - Column configuration uses proper types (string, currency, datetime, number)
  - Loading state shown with progress bar for large datasets
  - Export logged to activity_log via useExport hook's entityType: EntityType.ORDER
  - Metadata includes orderCount, rowCount, fields, format, includeLineItems
- Export field options are configurable with recommended/default flags
- Dialog-based interface for advanced options, dropdown for quick export
- Updated `src/components/admin/orders/index.ts` to export `OrderExportButton`
- Updated `src/pages/admin/Orders.tsx`:
  - Replaced inline export logic with `OrderExportButton` component
  - Removed old `useExport` hook usage, `exportCSV`, `ExportOptionsDialog` imports
  - Removed `exportDialogOpen` state and `handleExportWithOptions` function
  - Removed `orderExportFields` definition
  - Removed unused `Download` icon import
  - OrderExportButton receives `filteredOrders` as orders prop
- All database queries already filter by `tenant_id` (existing behavior preserved)
- No `console.log` statements — all logging via `logger` from `@/lib/logger`
- All imports use `@/` alias
- TypeScript compiles with no errors, ESLint passes

## task-071: Create order refund with inventory restore
- Created `src/hooks/useOrderRefund.ts` - dedicated hook for order refunds with full inventory restoration:
  - Follows same patterns as `useOrderCancellation` hook for consistency
  - Supports full and partial refunds with configurable line items
  - Restores inventory for refunded items (increments `stock_quantity` and `available_quantity`)
  - Logs each inventory change to `inventory_history` table with:
    - `change_type: 'return'`
    - `reason: 'order_refunded'`
    - `reference_type: 'order_refunded'`
    - Full metadata including order details, refund type, amount, and reason
  - Creates activity log entry via `logActivity()` with action `refund_processed`
  - Creates admin notification (all admins) for refund processed
  - Creates customer notification if `customer_id` exists on order
  - Updates order `status` and `payment_status` based on refund type
  - Stores refund metadata on order including processedAt, processedBy, inventoryRestored
  - Exports types: `RefundType`, `RefundReason`, `RefundMethod`, `RefundLineItem`, `RefundOrderOptions`
  - Returns `RefundResult` with inventory restore details (success/failure per item)
  - Cross-panel invalidation for orders, products, inventory, dashboard, analytics, notifications
- Updated `src/components/admin/orders/OrderRefundModal.tsx`:
  - Now uses `useOrderRefund` hook instead of inline mutation
  - Removed duplicate mutation logic, now uses centralized hook
  - Added validation for already refunded and unpaid orders
  - Added payment status display in order summary
  - Added inventory restore info alert when enabled with item count
  - Added CheckCircle icon for restore confirmation message
  - Cleaner component with proper separation of concerns
- All database queries filter by `tenant_id` for proper multi-tenant isolation
- No `console.log` statements — all logging via `logger` from `@/lib/logger`
- All imports use `@/` alias
- TypeScript compiles with no errors, ESLint passes

## task-072: Create order source tracking
- Built on existing order_source column migration (20260123000001_add_order_source_column.sql)
- Created new migration (20260210000001_order_source_traceability.sql) adding source_menu_id and source_session_id for traceability
- source_menu_id links orders to their origin disposable_menu when ordered from a menu link
- source_session_id tracks storefront session for customer journey analysis
- Updated OrderRow.tsx to use the proper OrderSourceBadge component instead of inline badge
- Created OrderSourceInfo.tsx component for detailed source display on order detail page
  - Shows source badge with description
  - Links to source menu when available (with navigation to menu detail)
  - Shows customer journey info (browsing time, items viewed) when session available
- Created useOrderSourceAnalytics.ts hook for analytics breakdown by source
  - Returns orderCount, revenue, averageOrderValue, percentageOfTotal per source
  - Includes daily trend data for charting
  - Identifies top source and fastest growing source
- Updated OrderDetailsPage.tsx to show OrderSourceInfo component in sidebar
- Added source_menu_id and source_session_id to OrderDetails interface
- OrderFilters already had source filter (ORDER_SOURCE_OPTIONS) from existing code
- All imports use @/ alias, logger from @/lib/logger (no console.log)
- All queries filter by tenant_id for proper tenant isolation

## task-073: Create order storefront session link
- Created migration (20260210000002_create_storefront_sessions.sql) for storefront_sessions table
  - Tracks customer browsing sessions from storefronts and disposable menus
  - Fields: session_token, visitor_id, source_type (storefront/menu/api), menu_id
  - Session metrics: browsing_duration_seconds, page_views, items_viewed, items_added_to_cart
  - Journey tracking: viewed_products (JSONB array), cart_history (JSONB), page_history (JSONB)
  - UTM tracking: utm_source, utm_medium, utm_campaign, referrer
  - Order linkage: order_id, converted_at fields for conversion tracking
  - RLS policies for tenant isolation and anon session creation
  - RPC functions: get_storefront_session_details, update_session_activity, link_session_to_order
- Created StorefrontSessionLink.tsx component for detailed customer journey visualization
  - Shows browsing time, products viewed, page views, cart additions
  - Displays conversion metrics (view-to-cart rate, time to convert)
  - Shows source menu details with link to menu management
  - Collapsible product viewed list with duration per product
  - UTM tracking info display (source, medium, campaign)
  - Compact mode for inline display, full card mode for sidebar
- Updated OrderDetailsPage.tsx to render StorefrontSessionLink when source_session_id exists
- Exported StorefrontSessionLink from components/admin/orders/index.ts
- Builds on task-072's source tracking infrastructure
- All imports use @/ alias, logger from @/lib/logger (no console.log)
- All queries filter by tenant_id for proper tenant isolation


## task-074: Create order auto-assign rules
- Created `src/components/admin/settings/OrderAutoAssign.tsx` — settings component for configuring order auto-assignment rules
- Component uses React Hook Form + Zod for form validation and management
- Features:
  - Global enable/disable toggle for auto-assignment
  - Rule management with add/remove/reorder functionality
  - Multiple condition types: order_total_min, order_total_max, delivery_zone, product_category, customer_type, time_of_day
  - Operator options: equals, greater_than, less_than, contains, in
  - Runner selection dropdown with status badges
  - Priority ordering for rule evaluation
  - Active rules summary view
- Rules stored in tenant_settings table via upsert with onConflict: tenant_id
- Used useFieldArray for dynamic rule and condition management
- All queries filter by tenant_id using useTenantAdminAuth() context
- Loading states with Skeleton components, error states with Alert
- All imports use @/ alias, logger from @/lib/logger (no console.log)
- Component reuses useAvailableRunners hook for runner data
- Applied RuleCard sub-component pattern for cleaner code organization

## task-075: Create order recurring/subscription support
- Fixed missing useTenantAdminAuth import in RecurringOrderSetup.tsx
- Added 'daily' frequency option to RecurringOrderFrequency type
- Added 'end_date' field to RecurringOrderSchedule interface for subscription end dates
- Updated RecurringOrderSetup form schema to include end_date and daily frequency
- Added end_date input field with optional label in the form UI
- Updated createSchedule and updateSchedule mutations to handle end_date
- Updated totalMonthlyValue calculation to include daily frequency multiplier (30)
- Updated RecurringOrdersList to display daily frequency label
- Updated summary card to show daily frequency and end date when set
- Component located at src/components/admin/recurring-orders/ (slight path difference from spec)
- Uses RecurringOrdersList for dashboard display of upcoming orders
- Edge function 'generate-recurring-order' handles auto-creation with inventory validation
- All imports use @/ alias, no console.log, logger used for errors

## task-076: Create Supabase migration for recurring_orders table
- Created supabase/migrations/20260210000001_add_recurring_orders.sql
- Table columns: id (UUID PK), tenant_id (UUID NOT NULL), template_order_id (UUID FK to orders), customer_id (UUID), frequency (TEXT with CHECK constraint), next_run_date (DATE NOT NULL), end_date (DATE), is_active (BOOLEAN default true), created_at/updated_at (TIMESTAMPTZ)
- Added CHECK constraint for frequency: daily/weekly/biweekly/monthly
- Created indexes on tenant_id, customer_id, next_run_date, is_active, template_order_id for performance
- RLS enabled with tenant_id filtering via tenant_users join pattern
- Policies: SELECT/INSERT/UPDATE/DELETE for tenants, ALL for super_admins
- Added updated_at trigger function for automatic timestamp updates
- Added table and column comments for documentation
- Foreign key to orders(id) uses ON DELETE SET NULL to preserve recurring record if template deleted
- Foreign key to tenants(id) uses ON DELETE CASCADE to clean up when tenant removed

## task-077: Create order priority system
- Created supabase/migrations/20260210000002_add_order_priority_system.sql with full priority system
- Added priority column to unified_orders: low/normal/high/urgent with CHECK constraint
- Added priority tracking columns: priority_set_at, priority_set_by, priority_auto_set
- Created tenant_priority_settings table for configurable auto-priority rules:
  - vip_customer_priority: Priority for VIP customers
  - large_order_threshold: Amount threshold for large order priority
  - wholesale_default_priority: Default priority for wholesale orders
  - urgent_delivery_hours: Hours before delivery to mark urgent
  - notify_on_urgent/notify_on_high: Notification preferences
- Created calculate_order_priority() RPC function for auto-priority based on rules
- Created update_order_priority() RPC function with proper tracking
- Created set_order_priority_on_insert trigger for auto-assignment on new orders
- Created order_priority_notifications table for urgent/high priority alerts
- Created triggers for notification creation on urgent/high orders and priority changes
- Updated OrderPriorityFlag component to support 'urgent' level with Zap icon and red styling
- Created useOrderPriority.ts hook with:
  - usePrioritySettings: Fetch tenant priority settings
  - useUpdatePrioritySettings: Update tenant settings with upsert
  - useUpdateOrderPriority: Update individual order priority
  - usePriorityNotifications: Fetch priority notifications
  - useAcknowledgeNotification/useAcknowledgeAllNotifications: Acknowledge alerts
  - useUrgentNotificationCount: Count for badge display
  - sortByPriority utility function for client-side sorting
- Updated useUnifiedOrders hook to support priority filtering and sorting:
  - Added priority option for filtering by priority level(s)
  - Added sortByPriority option to sort urgent/high first
  - Added sortOrdersByPriority helper function
  - Added priority fields to UnifiedOrder interface
- Created UrgentOrdersBell.tsx notification bell component with:
  - Pulsing animation for urgent notifications
  - Popover with notification list
  - Acknowledge individual/all actions
  - Link to view all priority orders
- Created PrioritySettingsForm.tsx for tenant settings configuration:
  - Auto-priority toggle
  - VIP customer priority setting
  - Large order threshold and priority
  - Wholesale default priority
  - Urgent delivery time threshold
  - Notification preferences
- Created OrderPrioritySelect.tsx for inline priority changes
- All RLS policies use tenant_users join pattern for tenant isolation
- All imports use @/ alias, logger from @/lib/logger (no console.log)
- Performance indexes added for priority queue ordering

## task-078: Create order-to-invoice generation
- Enhanced existing `OrderInvoiceGenerator.tsx` with database-saving functionality
- Added `useOrderInvoiceSave` hook that:
  - Uses `generate_invoice_number` RPC for tenant-specific sequence numbers
  - Saves invoice to `customer_invoices` table with `order_id` link
  - Converts order items to invoice line items format
  - Links invoice to customer via `customer_id`
- Created `GenerateAndSaveInvoiceButton` component that:
  - Creates invoice record in database
  - Optionally downloads PDF with tenant business info
  - Uses tenant context for company name
  - Supports callback when invoice is created
- Created `useFullOrderInvoice` hook combining DB save + PDF generation
- Added new interfaces: `SavedInvoice`, `InvoiceLineItem`, `CreateOrderInvoiceInput`
- Existing PDF generation preserves full functionality (download, print buttons)
- All database queries filter by `tenant_id` (RLS via tenant_users)
- Uses `useMutation` from TanStack Query with proper cache invalidation
- Invoice number format: `{SLUG}-INV-{YEAR}-{PADDED_COUNTER}` from RPC
- No console.log used — all logging via logger from @/lib/logger
- All imports use @/ alias with proper order: React → Third-party → Utils


## task-079: Create order split functionality
- Created `OrderSplitDialog.tsx` in `src/components/admin/orders/`
- Implements order splitting: move selected items to a new order
- Key features:
  - Visual item selection with checkboxes
  - Prevents splitting if order has less than 2 items
  - Ensures at least 1 item remains in original order
  - Shows split preview with totals for both orders
  - Uses `parent_order_id` in metadata to reference original order
  - Updates original order with `split_orders` array in metadata
  - Adds delivery notes referencing the other order for easy navigation
- Uses `logActivity` from `@/lib/activityLog` for audit trail:
  - Logs 'updated' action on original order with split details
  - Logs 'created' action on new order with parent reference
- Exports both `OrderSplitDialog` (controlled) and `OrderSplitButton` (standalone)
- Invalidates all relevant query caches: orders, unified orders, activity feed
- Toast notification with "View" action to navigate to new order
- Uses `useTenantAdminAuth()` for tenant context
- Uses `useTenantNavigation()` for admin route navigation
- All queries filter by `tenant_id`
- No console.log — uses logger from `@/lib/logger`
- All imports use `@/` alias with proper order: React → Third-party → Types → Components → Utils
- Includes loading states and error handling with toast notifications

## Task 080: Create order merge functionality

### Implementation
- Integrated the existing OrderMergeDialog component into the Orders page (src/pages/admin/Orders.tsx)
- Added 'Merge' action to the BulkActionsBar with Merge icon from lucide-react
- Added mergeDialogOpen state to control the dialog visibility
- Updated Order interface to properly type order_items for merge functionality

### Key Features
- OrderMergeDialog already existed with full merge logic in src/components/admin/orders/OrderMergeButton.tsx
- Groups selected orders by customer (user_id) to find mergeable orders
- Only allows merging 2+ orders from the same customer
- User selects which order to keep (target) - items from other orders are transferred
- Source orders are marked as cancelled with '[MERGED INTO #...]' note
- Target order gets updated totals and '[MERGED]' delivery note
- Uses RadioGroup to select target order with visual preview
- Shows order details (order number, status, date, amount, item count)

### Patterns Used
- useTenantAdminAuth() for tenant context and tenant_id filtering
- queryKeys.orders.all for cache invalidation
- formatCurrency and formatSmartDate for display
- logger from @/lib/logger for logging (no console.log)
- All imports use @/ alias with proper order
- Loading states and error handling with toast notifications

## task-081: Create order SLA tracking
- Created src/types/sla.ts with SLA type definitions (SLATargets, SLAStatus, OrderSLAResult, SLAComplianceSummary)
- Created src/lib/sla/slaCalculations.ts with calculation utilities:
  - calculateOrderSLA() - calculates SLA status for a single order
  - calculateSLAComplianceSummary() - aggregates SLA metrics for multiple orders
  - getSLAStatusDisplay() - returns display properties (label, color, className)
  - formatRemainingTime() - formats minutes into human-readable time
- Created src/components/admin/orders/OrderSLAIndicator.tsx:
  - OrderSLAIndicator - full badge with tooltip showing SLA details
  - OrderSLADot - compact dot indicator for table lists
- Created src/components/admin/dashboard/SLAComplianceWidget.tsx:
  - Shows overall compliance percentage with color-coded progress bar
  - Displays on-track/approaching/overdue order counts
  - Alerts when orders are past SLA target
- Updated src/pages/admin/Orders.tsx to show SLA indicators in status column
- Added SLA query keys to src/lib/queryKeys.ts
- Exported components via index files for clean imports
- Key patterns used:
  - Used date-fns differenceInMinutes for time calculations
  - Status transitions defined in STATUS_TRANSITIONS constant
  - DEFAULT_SLA_TARGETS provides sensible defaults (can be overridden by tenant settings)
  - Green/Yellow/Red color scheme with 80% threshold for approaching

## task-082: Create order pinned notes for dashboard
- Added pinning capability to order notes with is_pinned, pinned_at, pinned_by, pin_reason columns
- Created migration `20260210000002_add_order_notes_pinning.sql` to add pinning columns to order_notes table
- Created `src/hooks/usePinnedOrderNotes.ts` hook for fetching pinned notes with tenant isolation
- Added PIN_REASONS constant for categorizing pinned notes: wrong_address, callback_needed, substitution_required, payment_issue, delivery_issue, custom
- Created `src/components/admin/dashboard/PinnedNotesWidget.tsx` for "Requires Attention" dashboard section
- Widget displays pinned notes with color-coded icons based on pin_reason, shows order number, note content, and who pinned it
- Updated `src/components/admin/orders/OrderThreadedNotes.tsx` to support pin/unpin actions via dropdown menu
- Each note shows a "Pinned" badge when pinned, styled with orange background
- Added queryKeys.orderNotes.pinned() to queryKeys.ts for cache management
- Pin/unpin actions invalidate both the order notes query and pinned notes query for real-time updates
- Real-time subscription in widget auto-refreshes when notes table changes
- Used existing patterns: useTenantAdminAuth for tenant context, supabase queries with tenant_id filter
- All logging uses logger from @/lib/logger, no console.log statements
- Import order follows: React → Third-party → Types → Components → Utils


## task-083: Create order history diff view
- Created `src/components/admin/orders/OrderHistoryDiff.tsx` component for comparing before/after states when orders are edited
- Uses `useOrderAuditLog` hook to fetch order audit entries from order_audit_log table
- Parses audit entries to extract changed fields, including:
  - Direct field changes from old_value/new_value columns
  - Complex changes from metadata.changes object (before/after structure)
  - Nested change objects with old/new properties
- Color-coded diff display: green for added, red for removed, amber for changed
- Each diff entry shows: field name, old value (strikethrough), arrow, new value
- Groups changes by date with expandable/collapsible sections
- Displays actor info (user name/email or "System") and timestamps (smart date + relative time)
- FIELD_LABELS mapping provides human-readable labels for common order fields (status, payment_status, total, customer_name, etc.)
- formatValue() helper handles different value types (null, boolean, number as currency, objects/arrays)
- Empty state shows when no changes are recorded
- Loading state with skeleton placeholders
- Error state with user-friendly message
- Follows project patterns: useTenantAdminAuth context, @/ alias imports, logger (no console.log)
- Props: orderId (required), maxHeight, showHeader, className
- Exported types: OrderHistoryDiffProps, DiffField, ParsedDiff


## task-084: Create order communication log
- Created `src/components/admin/orders/OrderComms.tsx` component for viewing all order communications
- Aggregates communications from multiple sources:
  - `notifications_log` table: SMS, emails, and push notifications
  - `courier_messages` table: Messages between admin and courier
- Each communication entry displays:
  - Type badge (SMS/Email/Notification/Courier with distinct icons and colors)
  - Delivery status (sent/delivered/failed/pending/read) with appropriate icons
  - Recipient info (phone and/or email when available)
  - Message content with line-clamp for long messages
  - Error message for failed deliveries
  - Sender type (System/Admin/Courier/Customer) with avatar icon
  - Timestamps (smart date format + relative time with tooltip)
- Groups entries by date with "Today" label for current day
- Header shows aggregate stats: SMS count, email count, total communications
- Added `queryKeys.orderComms.byOrder(orderId)` to queryKeys.ts for cache management
- Graceful error handling when tables don't exist (code 42P01)
- Uses logger.warn for non-critical fetch errors
- Loading state with skeleton placeholders
- Empty state with helpful messaging
- Props: orderId, maxHeight, showHeader, className
- Exported types: OrderCommsProps, CommunicationEntry, CommType
- Follows project patterns: useTenantAdminAuth, @/ alias imports, no console.log

## task-085: Create product detail page with order history
- Added queryKeys.orders.byProduct(tenantId, productId) to src/lib/queryKeys.ts
- Created useProductOrders hook in src/hooks/useProduct.ts that fetches orders containing a product via unified_order_items table
- Hook joins unified_order_items with unified_orders using Supabase select with nested joins
- Filters orders by tenant_id to ensure multi-tenant isolation
- Returns both orders list and stats (totalSoldWeek, totalSoldMonth, totalSoldAllTime)
- Created src/components/admin/products/ProductOrderHistory.tsx component with:
  - Three stat cards showing units sold this week/month/all-time
  - DataTable with paginated orders list (order number, date, qty, customer, total, status)
  - Clickable links: order number navigates to order detail, customer name to customer detail
  - Status badges using getStatusVariant for semantic coloring
  - Loading and error states properly handled
- Added 'Orders' tab to ProductDetailsPage between Info and Variants tabs
- Updated TabsList to 4-column grid to accommodate new tab
- No console.log used — follows project conventions with logger if needed
- All imports use @/ alias as required

## task-086: Create product detail page with inventory chart
- Created useProductInventoryChart hook in src/hooks/useProduct.ts that fetches inventory_history for charting
- Hook accepts productId and timeRange ('7d' | '30d' | '90d') parameters
- Calculates running stock quantity from inventory_history entries
- First fetches prior history before the time range to establish starting quantity
- Determines event type (restock, deduction, adjustment) based on movement_type field
- Returns InventoryChartDataPoint[] with date, quantity, eventType, and notes
- Created src/components/admin/products/ProductInventoryChart.tsx component with:
  - recharts ComposedChart using LineChart for stock levels over time
  - X-axis shows dates, Y-axis shows stock quantity
  - Line uses stepAfter interpolation for accurate inventory representation
  - Green Scatter dots for restock events
  - Red Scatter dots for order deductions
  - Custom tooltip showing date, stock level, event type badge, and notes
  - ToggleGroup for time range selection (7d/30d/90d)
  - Stats summary showing current, min, max stock, restock count, deduction count
  - Loading and error states properly handled
- Integrated chart into ProductDetailsPage.tsx inventory tab as first element
- Uses queryKeys.inventory.movements pattern extended with 'chart' and timeRange
- All queries filter by tenant_id for multi-tenant isolation
- No console.log used — follows project conventions
- All imports use @/ alias as required

## Task 087: Create product detail page with vendor info

**What was built:**
- Created src/components/admin/products/ProductVendorCard.tsx component
- Component displays vendor information for a product including:
  - Vendor name (clickable link to vendor detail page via useEntityNavigation)
  - Contact info (email, phone) with mailto/tel links
  - Last restock date (from purchase orders) with relative time display
  - Average lead time in days (calculated from PO creation to received date)
  - Vendor reliability score (percentage of on-time deliveries)
  - Total purchase orders count
  - Quick action button to create purchase order with vendor/product pre-selected
- Supports multiple vendors per product (shows all matching vendors)
- Matches vendors by vendor_name field or by purchase order history
- Integrated into ProductDetailsPage.tsx Info tab

**Key learnings:**
- FloraIQ has both 'vendors' table (for purchase orders) and 'wholesale_suppliers' table (for supplier transactions)
- Products have a vendor_name text field rather than a direct vendor_id foreign key
- Vendor matching requires fuzzy matching on name or lookup via purchase_order_items
- EntityType 'VENDOR' already exists in entityTypes.ts for navigation
- Purchase orders have expected_delivery_date and received_date for reliability calculations
- Reliability score is calculated as: (on-time deliveries / completed deliveries) * 100
- Average lead time is calculated from PO created_at to received_date
- Used TanStack Query with custom query key for vendor data caching
- All queries properly filter by tenant.id (account_id for vendors table)
- Format dates using date-fns formatDistanceToNow for user-friendly display
- Component follows project patterns: loading skeletons, error states, empty states
- No console.log used — follows project conventions with logger from @/lib/logger
- All imports use @/ alias as required

## Task 088: Create product detail page with menu appearances

**What was built:**
- Created src/components/admin/products/ProductMenuAppearances.tsx component
- Component displays which menus/storefronts feature the product including:
  - Tabs for disposable menus and marketplace stores
  - List of active menus with clickable links to menu detail page
  - List of stores with clickable links to storefront page
  - Custom pricing display per menu/store (shows "Custom" badge if differs from base)
  - Expiration date for menus (shows "Expired" badge if past)
  - Status badges (active/inactive, featured)
  - Toggle visibility for storefront products
  - Remove button to remove product from a menu
  - "Add to Menu" dialog to add product to available menus
- Integrated into ProductDetailsPage.tsx Info tab after ProductVendorCard

**Key learnings:**
- Products connect to menus via disposable_menu_products table (menu_id + product_id)
- Products connect to stores via marketplace_product_settings table (store_id + product_id)
- disposable_menu_products has custom_price field that can override product price
- marketplace_product_settings has custom_price and is_visible fields
- Menus have status enum (active/burned) and expiration_date with never_expires flag
- marketplace_stores has is_active flag for store status
- Used nested select queries with !inner join to get related menu/store data
- Filter results by tenant_id to ensure multi-tenant isolation
- Used useMutation hooks for add/remove operations with proper query invalidation
- TanStack Query invalidates both product and menus query keys on mutations
- date-fns isPast() checks if menu is expired
- Component follows project patterns: loading skeletons, error states, empty states
- Used showSuccessToast/showErrorToast for user feedback
- No console.log used — follows project conventions with logger from @/lib/logger
- All imports use @/ alias as required

## Task 089: Create product detail page with compliance status

**Completed:** Created ProductComplianceStatus component for product detail page

**What was implemented:**
- Created src/components/admin/products/ProductComplianceStatus.tsx
- Displays compliance status with overall status badge (Compliant/Warning/Non-Compliant)
- Shows lab test results section with lab name, test date, and validity status
- Calculates lab test expiration (365 days from test date) with expiring soon (300+ days) warnings
- Displays traceability section with batch number, SKU, and barcode
- Shows license documents summary from compliance_documents table (active/expiring/expired counts)
- Displays compliance issues alert with critical/warning/info severity levels
- Red warnings for missing lab tests, expired tests, or compliance issues
- Link to compliance vault for full compliance details
- Replaced basic Lab Results & Compliance card in ProductDetailsPage.tsx with new component

**Key learnings:**
- Products table has compliance fields: test_date, lab_name, coa_url, coa_pdf_url, lab_results_url, batch_number
- Lab tests typically valid for 1 year in cannabis industry (365 days from test_date)
- compliance_documents table stores tenant-level documents with status enum (active/expired/expiring_soon)
- Used queryKeys.compliance.documents(tenantId) for fetching compliance documents
- Calculated compliance status using pure function with memoization for performance
- Used useMemo to recalculate compliance status only when product or documents change
- date-fns differenceInDays used to calculate days since lab test
- Alert component from shadcn/ui supports variant="destructive" for critical alerts
- Created custom amber-colored alert for warnings using Tailwind classes
- Component follows project patterns: loading skeletons, proper imports, no console.log
- Used logger from @/lib/logger for error logging
- All imports use @/ alias as required

## Task 090: Create product inventory auto-reorder trigger

**Completed:** Created useAutoReorder hook and integrated with product detail page and dashboard

**What was implemented:**
- Created src/hooks/useAutoReorder.ts with three main hooks:
  - `useAutoReorder()` - monitors all products below low_stock_threshold, returns reorder suggestions
  - `useProductReorder(productId)` - gets reorder info for a specific product
  - `useCreateReorderPO()` - mutation hook for one-click purchase order creation
- Created src/components/admin/products/ProductReorderCard.tsx for product detail page
  - Shows sales velocity stats (daily average, weekly/monthly totals, days of stock remaining)
  - Displays suggested reorder quantity with estimated cost
  - One-click "Create Purchase Order" button that calls create-purchase-order edge function
  - Priority badges (critical/high/medium/low) based on stock levels and velocity
- Updated src/components/admin/dashboard/AutoReorderSuggestionsWidget.tsx
  - Now uses useAutoReorder hook instead of direct wholesale_inventory query
  - Shows summary stats (total items, estimated reorder cost)
  - Links to product detail page and purchase orders
- Added ProductReorderCard to ProductDetailsPage.tsx in the Inventory tab

**Key learnings:**
- Sales velocity calculation uses order_items table from last 30 days
- Priority is calculated from: current stock vs threshold AND days of stock remaining
- Suggested quantity targets 30 days of stock or 2x threshold, whichever is higher
- Used TanStack Query with custom query key factory for reorder suggestions
- Edge function create-purchase-order handles PO creation, no direct table insert needed
- Products table has vendor_id/vendor_name for vendor association
- All queries filter by tenant_id via useTenantAdminAuth().tenant?.id
- Component uses useTenantNavigation for tenant-aware routing
- Logger from @/lib/logger used for all error/info logging (no console.log)
- Mutation hook invalidates both purchaseOrders and reorder suggestions queries on success

## task-091: Create product category management with counts
- Enhanced `src/pages/admin/catalog/CategoriesPage.tsx` with comprehensive category stats
- Each category now displays: product count, total stock value, revenue generated, best seller product
- Added aggregate stats cards at top: total categories, total products, total stock value, total revenue
- Stats computed via separate TanStack Query using category key factory with 'stats' suffix
- Links categories to filtered product list via `navigateToFilteredProducts(categoryId)` using tenant-aware routing
- Uses `tenantSlug` from useParams to build proper admin routes: `/${tenantSlug}/admin/products?category_id=${categoryId}`
- Category tree supports nesting with expand/collapse functionality
- Real-time updates via TanStack Query invalidation when categories change
- Mobile-responsive: stats show in a separate row on small screens
- All queries filter by `tenant_id` as required
- No console.log — all logging via `logger` from `@/lib/logger`
- Proper TypeScript types: `Category`, `CategoryStats`, `CategoryWithStats`
- Graceful handling of missing tables (42P01 error code)
- Loading states with Skeleton components, error handling via `handleError` utility

## task-092: Create product variant system
- Created `src/components/admin/products/ProductVariants.tsx` — comprehensive variant management component
- Created `src/components/admin/products/VariantSelector.tsx` — reusable variant selector for orders/storefront
- Each variant has own: SKU, price (wholesale/retail/cost), stock level, low stock alert
- Supports three variant types: weight (with weight_grams), size, strain (with THC/CBD/strain_type)
- ProductVariants component features:
  - Full CRUD operations using existing useProductVariants hook
  - Bulk preset creation for weights (1g, 1/8oz, 1/4oz, 1/2oz, 1oz) and sizes (S, M, L)
  - Table view with type badges, stock indicators, pricing columns
  - Duplicate variant functionality (copies all data except inventory)
  - Confirmation dialog for deletions with stock warnings
  - Compact mode for inline variant selection
  - Loading and error states with Skeleton/AlertTriangle
- VariantSelector component provides three display variants:
  - `dropdown`: Combobox with search, grouped by type
  - `radio`: Radio group with price/stock display
  - `buttons`: Button group for simple selection
- StorefrontVariantSelector: simplified customer-facing component showing retail prices
- All components use logger from @/lib/logger — no console.log
- Queries filter by tenant_id via useTenantAdminAuth()
- Uses existing useProductVariants hook which has proper TanStack Query patterns
- Components are fully typed with TypeScript interfaces
- Proper import order: React → Third-party → Types → Components → Utils
- Integration points ready for order creation (LineItemsEditor) and storefront (product detail pages)

## task-093: Create product image gallery with menu preview
- Created `src/components/admin/products/ProductImageGallery.tsx` — comprehensive image gallery component
- Features implemented:
  - Multiple images per product with visual thumbnails
  - Drag-to-reorder images using native HTML5 drag and drop
  - Primary image designation with star badge (shown in lists and menus)
  - Set any image as primary via button click
  - Remove images with immediate database update
  - Full-screen zoom dialog with navigation
  - Touch/swipe support for mobile navigation
- Menu/Storefront Preview system:
  - Dialog with Tabs to switch between "Disposable Menu" and "Storefront" preview
  - Device preview toggle (Desktop/Mobile) with responsive sizing
  - ProductPreviewCard internal component renders product exactly as it appears:
    - Menu style: category badge, strain type, THC/CBD percentages, price, Add to Cart button
    - Storefront style: hover effects, gradient overlay, wholesale pricing
- Integration with ProductDetailsPage:
  - Added import and component in Info tab
  - Passes product data including `images` array from products table
  - Editable mode enabled for admin users
- Database integration:
  - Uses existing `products.images` column (string[]) from Supabase
  - Mutation updates both `image_url` (primary) and `images` (additional) fields
  - Filters by `tenant_id` via `useTenantAdminAuth()`
  - Invalidates `queryKeys.products.all` on successful update
- Lazy loading via OptimizedProductImage component with loading states
- All logging uses `logger` from `@/lib/logger` — no console.log
- Proper TypeScript types: ProductImageData, PreviewMode, DevicePreview
- Includes ProductImageGallerySkeleton for loading states
- Import order follows convention: React → Third-party → Types → Components → Utils

## Task 094: Create product pricing history

### Implementation Details

**Database Migration: 20260210000001_create_pricing_history.sql**
- Created `pricing_history` table with columns for tracking old/new values of wholesale_price, retail_price, and cost_per_unit
- Added `changed_by` (user reference), `change_reason`, and `change_source` fields
- Implemented RLS policies for tenant isolation (tenant users can view, admins can insert)
- Created `log_price_change()` SQL function that only inserts if prices actually changed
- Created `get_recent_price_change()` function for efficient strikethrough display (returns most recent change within N days)
- Added proper indexes on product_id, tenant_id, and created_at

**Hook: src/hooks/usePriceHistory.ts**
- `usePriceHistory(productId, timeRange)` - Fetches full price history for chart display
- `usePriceHistoryChart(productId, timeRange)` - Returns chart-formatted data points with wholesale/retail/cost
- `useRecentPriceChange(productId, withinDays)` - Fetches most recent price change for strikethrough
- `useLogPriceChange()` - Mutation hook that logs price changes, calls activity_log, and publishes eventBus event
- Utility functions: `calculatePriceChangePercent()`, `getPriceChangeDirection()`

**Component: src/components/admin/products/ProductPriceHistoryChart.tsx**
- Recharts LineChart with stepAfter interpolation for accurate price visualization
- Shows wholesale (green), retail (purple), and cost (orange dashed) lines
- Time range selector: 30d, 90d, 1y
- Stats summary: total changes, current prices
- Recent change summary with percentage badges
- Loading/error/empty states

**Component: src/components/admin/products/ProductPriceDisplay.tsx**
- `ProductPriceDisplay` - Fetches recent price change and shows strikethrough for old price
- `StaticPriceDisplay` - For menus/storefronts without data fetching
- Shows trending up/down badge based on price direction
- Tooltip with change date, reason, and before/after prices
- Size variants: sm, md, lg

**EventBus Integration: src/lib/eventBus.ts**
- Added `price_changed` event type with productId, tenantId, old/new prices, and changedAt
- Event published by useLogPriceChange mutation
- Menus and storefronts can subscribe to sync automatically when prices change

**ProductDetailsPage Integration**
- Added ProductPriceHistoryChart to Variants tab (above pricing cards)
- Replaced static price displays with ProductPriceDisplay in stats cards and pricing section
- Shows strikethrough for recently changed prices with trending indicators

**Key Patterns Applied**
- All imports use `@/` alias
- All logging uses `logger` from `@/lib/logger`
- Database queries filter by `tenant_id`
- Uses `useTenantAdminAuth()` for tenant context
- Loading and error states included
- TypeScript interfaces for all data structures
- React Hook Form + Zod patterns (ready for future form integration)

---

## Task 095: Create product clone/duplicate

**Status:** ✅ Completed

### What Was Implemented

Product duplication functionality allowing users to clone an existing product with all its details, generate a unique SKU, and open the new product for editing.

### Implementation Details

**Hook: src/hooks/useProductDuplicate.ts**
- Updated to add activity logging when duplicating a product
- Uses `logActivity()` with metadata including source product info
- Generates unique SKU using `-COPY` suffix with counter for duplicates
- Sets `available_quantity: 0` (no inventory copied)
- Sets `batch_number: null` (unique per product)
- Returns `duplicateProduct` function and `isPending` state

**Component: src/components/admin/products/ProductDuplicateButton.tsx**
- Updated to add activity logging when duplicating
- Works as standalone button or dropdown menu item (variant prop)
- Shows loading state during duplication
- Calls `onSuccess` callback with new product

**Component: src/components/admin/ProductCard.tsx**
- Added `onDuplicate` prop for duplicate action
- Added Copy icon to dropdown menu and long-press menu
- Duplicate option appears after Edit in menu order

**Page: src/pages/admin/ProductManagement.tsx**
- Integrated `useProductDuplicate` hook with onSuccess callback
- On duplicate success: adds new product to local state and opens edit dialog
- Duplicate option in both grid view cards and table view row actions
- Uses Copy icon from lucide-react

### Task Requirements Met
- ✅ Add duplicate product action
- ✅ Copies all product details (name, description, category, images, pricing)
- ✅ Generates new SKU with `-COPY` suffix
- ✅ Does not copy inventory (available_quantity: 0)
- ✅ Does not copy batch number (null)
- ✅ Navigates to new product for editing (opens edit dialog)
- ✅ Log duplication to activity_log

### Key Patterns Applied
- All imports use `@/` alias
- Logger from `@/lib/logger` used (not console.log)
- Activity logged with proper metadata (source product, new product)
- Uses `useTenantAdminAuth()` for tenant and user context
- Loading states handled in mutation
- Error handling with toast notifications

---

## Task 096: Create product bulk import from CSV
**Date**: 2026-02-10
**Status**: ✅ Completed

### Implementation Details
Enhanced existing `src/components/admin/products/ProductBulkImport.tsx` to add missing functionality:

1. **Activity Logging**: Import action is now logged to `activity_log` table using `logActivity()` from `@/lib/activityLog`
   - Logs action as "bulk_import" with metadata including products imported count, inventory entries created, errors count, and first 10 product IDs

2. **Inventory History Entries**: After successful product insert, creates `inventory_history` entries for products with initial stock
   - Uses `.select("id, available_quantity")` to get inserted product data
   - Creates `stock_in` entries with reason "Initial stock from CSV import"
   - Tracks `performed_by` with admin's userId

3. **Enhanced Results Summary**: Toast notification now shows both products imported and inventory entries created

### Existing Features Already Present
- CSV/Excel file upload via xlsx library
- Field mapping with auto-detection
- Validation with error highlighting (missing required fields, invalid categories, numeric validation)
- Batch processing with progress indicator
- Preview table with tabs for All/Valid/Invalid records
- Template download
- Error report download

### Key Patterns Applied
- All imports use `@/` alias
- Logger from `@/lib/logger` used (not console.log)
- Uses `useTenantAdminAuth()` for tenant and admin context
- All database queries filter by `tenant_id`
- Loading and error states included
- No TypeScript errors

## task-097: Create product bulk export with full data
- Created `src/components/admin/products/ProductExport.tsx` component for comprehensive product data export
- Exports products with ALL related data:
  - category_name, vendor_display_name (from product data)
  - current_stock (calculated from available/stock/total quantity)
  - total_orders and revenue_generated (aggregated from unified_order_items)
  - compliance_status (derived from COA, test dates, lab results)
  - active_menu_count (counted from disposable_menu_products for active menus)
- Used `useProductsWithRelatedData` custom hook to fetch and aggregate all related data
- Supports CSV and JSON export formats via `useExport` hook
- Column selection dialog with 40+ fields organized into 7 groups:
  - Basic Information, Related Data, Pricing, Inventory, Cannabis Details, Lab & Potency, Metadata
- Quick actions: Select All, Select None, Select Recommended
- Group-level toggle for batch field selection
- Uses `useTenantAdminAuth()` for tenant context
- Logs all exports to activity_log via EntityType.PRODUCT
- No console.log — all logging via `@/lib/logger`
- All imports use `@/` alias
- Proper loading states with Skeleton components
- Error handling for fetch failures
- Progress indicator for large dataset exports

## task-098: Create product search with advanced filters
- Created `src/components/admin/products/ProductAdvancedFilters.tsx` with comprehensive filter UI
- Filters implemented: category, vendor, stock status (in_stock/low_stock/out_of_stock), price range, compliance status (based on COA/lab results), menu status (listed/unlisted), created date range
- Used collapsible panel with "Advanced Filters" toggle button showing active filter count badge
- Active filter badges displayed inline with X button to remove individual filters
- Used `useTablePreferences` hook for persisting filter state to localStorage
- Date values serialized to ISO strings for storage, parsed back on load
- Filter state persists across page refreshes and sessions
- Debounced text search (300ms) now searches across name, SKU, and description fields
- All filters combined with AND logic in `filteredProducts` useMemo
- Compliance status determined by presence of `coa_url` or `lab_results_url` fields
- Menu status determined by `menu_visibility` boolean field
- Derived `vendors` array from products for vendor filter dropdown
- Derived `maxPrice` for potential slider UI
- Added `hasActiveFilters` computed value for empty state messaging
- Updated empty state to show contextual message when filters are active
- No console.log — all logging uses `@/lib/logger`
- All imports use `@/` alias pattern
- TypeScript types exported: ProductFilters, StockStatus, ComplianceStatus, MenuStatus

## task-099: Create product price update with menu sync
- Created `src/components/admin/products/ProductPriceUpdateDialog.tsx` - confirmation dialog for price updates
- Created `src/hooks/useProductPriceUpdate.ts` - hook for managing price updates with menu sync
- Dialog shows price changes (wholesale/retail) with old→new display using formatCurrency
- Fetches affected menus from `disposable_menu_products` and stores from `marketplace_product_settings`
- Filters results by tenant_id for proper multi-tenant isolation
- Distinguishes between items with custom_price (won't be affected) and items using base price
- Warning badge shows count of items with custom pricing that will be unaffected
- Checkbox option to sync prices: "Sync price to X items" with explanation
- Items using base price have custom_price set to null, so they auto-reflect base product price
- Publishes `price_changed` event to eventBus with old/new prices and timestamp
- Uses existing `useLogPriceChange` mutation from usePriceHistory for activity logging
- Toast notification shows updated menu/store names (truncated to first 3 with "+N more" suffix)
- Loading skeleton shown while fetching affected items
- Error handling with logger.error throughout
- Reused existing patterns from ProductMenuAppearances.tsx for menu/store display
- All imports use `@/` alias pattern
- No console.log statements — uses logger from @/lib/logger
- All queries filter by tenant_id for security
- AlertDialog component used from shadcn/ui for confirmation pattern

## task-100: Create product stock adjustment modal
- Created `src/components/admin/products/StockAdjustment.tsx` for manually adjusting product stock
- Modal includes fields: adjustment type (add/remove/set), quantity input, reason select, notes textarea
- Adjustment reasons: restock, damaged, correction, audit, expired, theft, transfer, other
- Preview section shows current quantity, change amount (with badge color), and resulting new quantity
- Warning alert shown when removing more than current stock (quantity capped at 0)
- On submit: updates `products.stock_quantity` and `available_quantity` via Supabase
- Logs to `inventory_history` table with change_type, previous/new quantity, reason, notes, and metadata
- Uses `useTenantAdminAuth()` for tenant context — all queries filter by tenant_id
- Uses `invalidateOnEvent()` for cross-panel invalidation on INVENTORY_ADJUSTED event
- Invalidates `queryKeys.products.all`, `queryKeys.inventory.all`, and `queryKeys.inventory.history`
- All logging uses `logger` from `@/lib/logger` — no console.log statements
- Proper error handling with try/catch and showErrorToast for user feedback
- Loading state with Loader2 spinner during mutation
- Form validation: requires quantity > 0 and reason selected
- All imports use `@/` alias pattern
- Used existing patterns from StockAdjustmentModal.tsx in src/components/admin/ as reference

## task-101: Create product-vendor reorder automation
- Created `src/components/admin/products/ReorderSettings.tsx` for per-product reorder configuration
- Component allows setting: reorder_point (threshold), reorder_quantity, preferred_vendor_id
- Uses `useTenantAdminAuth()` for tenant context — all vendor queries filter by account_id/tenant_id
- `useVendors()` hook fetches active vendors from the vendors table for dropdown selection
- `useReorderConfig()` hook fetches current product's reorder settings (low_stock_alert, vendor_id)
- `usePendingReorders()` hook exported for dashboard widgets - shows products below reorder point
- When stock hits reorder_point with auto_reorder_enabled, creates PO draft via edge function
- Auto-reorder toggle requires a vendor to be selected first
- Current stock status displayed with "Below Reorder Point" / "Stock OK" badges
- Alert shown when stock is below threshold with option to create PO immediately
- Save mutation updates product's low_stock_alert, vendor_id, reorder_quantity, auto_reorder_enabled
- PO creation uses `supabase.functions.invoke('create-purchase-order')` with product/vendor/quantity
- `PendingReordersWidget` component shows dashboard list of products needing reorder (limited to 5)
- All queries use `queryKeys` factory pattern for cache invalidation
- All logging uses `logger` from `@/lib/logger` — no console.log statements
- Loading states with Skeleton components, error states with Alert component
- Proper imports using `@/` alias, lucide-react icons imported from esm paths
- Build verification passed with `npx vite build`

## task-102: Create product bundle/kit support
- Created `src/components/admin/products/ProductBundle.tsx` for product bundle/kit management
- `ProductBundleManager` component — main manager for creating/editing/deleting bundles
- Bundles stored as products with category='bundle' and bundle data in prices JSON field
- Each bundle contains: name, description, sku, bundle_price, discount_type, items array
- Items array stores product_id, quantity, and calculated product details (name, price, stock)
- Three discount types supported: percentage off, fixed amount off, custom price
- `useAvailableProducts()` hook fetches products for bundle item selection (filters by tenant_id)
- `useBundles()` hook fetches existing bundles, optional productId param filters bundles containing that product
- `useBundleSales()` hook fetches bundle sales analytics from order_items table
- Bundle creation validates minimum 2 products required
- Real-time calculation of individual total, bundle price, savings amount and savings percent
- Auto-generated SKU with BDL prefix if not provided
- available_quantity for bundle = minimum stock across all component products
- `BundleItemRow` sub-component handles quantity changes and removal with stock warnings
- `ProductBundleCard` export for displaying single bundle on product detail pages
- `ProductBundleBadge` export shows "In X bundle(s)" badge for products included in bundles
- Loading states with Skeleton components, empty states with helpful prompts
- All CRUD operations properly invalidate product and bundle query caches
- Delete confirmation dialog before bundle deletion
- All logging uses `logger` from `@/lib/logger` — no console.log statements
- Proper imports using `@/` alias, lucide-react icons imported from esm paths
- All database queries filter by tenant_id for multi-tenant isolation

## task-103: Create product performance analytics card
- Created `src/components/admin/products/ProductPerformanceCard.tsx` for product analytics
- Integrated into ProductDetailsPage.tsx on the "info" tab
- Shows units sold for 7d/30d/90d periods with revenue breakdowns
- Uses TanStack Query with `useProductPerformance()` hook for data fetching
- Fetches from order_items with inner join on orders, filtered by tenant_id
- Sales trend chart using recharts LineChart showing last 30 days of sales
- Customer segments breakdown showing which tiers/types buy this product
- Day of week performance analysis with best performing day highlighted
- Category comparison: calculates average revenue for products in same category
- Performance vs category percentage badge when category data is available
- StatCard sub-component for consistent metric display with trend indicators
- SalesTrendChart renders responsive line chart with proper Tooltip styling
- CustomerSegmentsDisplay shows horizontal bar charts with percentages
- DayPerformanceDisplay visualizes daily revenue with best day highlighted
- Tabs component for switching between Trend, Customers, and By Day views
- Loading state with Skeleton components matching layout
- Empty state when no sales data available with helpful messaging
- Error state with fallback UI and warning logging
- All logging uses `logger` from `@/lib/logger` — no console.log statements
- Proper imports using `@/` alias, lucide-react icons from esm paths
- Query data is stale after 5 minutes for reasonable cache behavior
- All database queries filter by tenant_id for multi-tenant isolation

## Task 104: Create product QR code generator

Created `src/components/admin/products/ProductQR.tsx` with comprehensive QR code generation features:

- **Link Destinations**: QR codes can link to storefront product page or specific disposable menu
- **Disposable Menu Integration**: Fetches active menus from `disposable_menus` table filtered by tenant_id
- **Options**: Include price in QR display, include lab results URL badge
- **Bulk Generation**: Multi-select products with search/filter, select all/clear functionality
- **Download**: Individual PNG download or bulk download all QR codes with staggered timing
- **Print**: Opens print window with grid layout of all generated QR codes
- **Product Search**: Filter products by name, SKU, or category in real-time
- **URL Copy**: Copy individual QR URLs to clipboard with visual feedback
- **Dialog Mode**: Can render as dialog with `asDialog={true}` prop
- **Lab Results**: Shows badge for products with `lab_results_url` field
- Uses `QRCodeSVG` from `qrcode.react` for high-quality SVG QR rendering
- Uses `useTenantAdminAuth()` for tenant context and slug-based URL building
- TanStack Query for products and menus with proper queryKeys
- ScrollArea for product list with fixed height and scrolling
- Loading, error, and empty states with Skeleton components
- All logging via `logger` from `@/lib/logger`
- All imports use `@/` alias, lucide-react icons from esm paths
- Full tenant_id filtering on all database queries

## task-105: Create inventory dashboard page
Enhanced `src/pages/admin/InventoryDashboard.tsx` with comprehensive inventory overview features:

- **Stats Cards**: Total Products, Total Stock Value (currency formatted), Low Stock Count, Out of Stock Count
- **Stock Level Distribution Chart**: Pie chart using Recharts showing products grouped by stock status (Out of Stock, Critical, Low Stock, Adequate, Overstocked)
- **Category-wise Stock Breakdown**: Horizontal bar chart showing inventory value by product category with detailed stats
- **Recent Inventory Changes Timeline**: Integrated existing `InventoryHistoryTimeline` component in a dedicated tab
- **Low Stock Alerts with One-Click Reorder**: Filterable list of products needing restocking with visual severity badges (Out of Stock, Critical, Low Stock), one-click reorder button navigates to purchase order creation with product pre-selected
- **Multiple TanStack Queries**: Separate queries for stats, category breakdown, stock distribution, and low stock products with proper error/loading states
- **Realtime Updates**: Supabase channel subscription for product changes with query invalidation
- **Tabs Organization**: Overview tab (charts), Low Stock Alerts tab (with badge count), Recent Changes tab (timeline)
- All database queries filter by `tenant_id` using `useTenantAdminAuth()`
- Tenant-aware navigation with `tenantSlug` in URLs
- Loading states with Skeleton components and Loader2 spinners
- Error handling with logger from `@/lib/logger` — no console.log
- Uses Recharts (PieChart, BarChart), lucide-react icons, shadcn/ui components
- Responsive design with grid layouts and proper mobile breakpoints

## task-106: Create inventory movement report
Created `src/components/admin/inventory/MovementReport.tsx` — comprehensive inventory movement reporting component:

- **Date Range Filtering**: Quick presets (Today, 7/30/90 days, All Time) + custom calendar pickers for start/end dates
- **Multi-Filter Support**: Filter by product (dropdown from products table), reason (receiving, sale, return, adjustment, damage, theft, quality, count, transfer, disposal, audit, other), and user (from tenant_users)
- **Search Functionality**: Client-side search across product name, SKU, reason, and notes
- **Sortable Columns**: Click column headers to sort by date, product name, change amount, reason, or user (toggles asc/desc with visual indicators)
- **Rich Data Table**: Shows date, product (name + SKU), change amount (colored +/-), previous/new quantity, reason badge, order reference (linked if from order), user email
- **Totals Row**: Footer row with movement count, total increase, total decrease, and net change (all color-coded)
- **CSV Export**: Export button generates full report with all columns plus summary totals, properly quoted/escaped
- **Order Reference Linking**: Fetches order_number from orders table via reference_id for movements tied to orders
- **User Resolution**: Joins to tenant_users to show email instead of just user_id
- **Pagination**: Server-side pagination with page size 25, previous/next navigation, page count display
- All queries filter by `tenant_id` via `useTenantAdminAuth()` hook
- Uses TanStack Query with proper query keys from `@/lib/queryKeys`
- Error handling with loading skeletons and EnhancedEmptyState for no results
- Logger from `@/lib/logger` for export tracking and errors — no console.log
- Proper `@/` alias imports, lucide-react icons from esm paths

## task-107: Create inventory audit tool
Created `src/pages/admin/InventoryAudit.tsx` — comprehensive physical inventory audit workflow:

- **Dual Tab Interface**: "Current Audit" tab for active audit session, "History" tab for past audit records
- **Product Count Entry**: Lists all tenant products with expected stock quantity and editable input for actual count
- **Discrepancy Highlighting**: Rows with non-zero variance highlighted in amber, visual badges for status (OK/Diff)
- **Statistics Dashboard**: Cards showing total products, counted items, discrepancy count, and net change
- **Search Filtering**: Filter products by name, SKU, or category during audit
- **Per-Product Notes**: Optional notes field for each product to document observations
- **Audit Notes**: General notes textarea for the entire audit session
- **Submit Workflow**: Confirmation dialog summarizing discrepancies before creating adjustments
- **Inventory History Integration**: Creates `inventory_history` entries with reason "audit" for each discrepancy
- **Product Quantity Updates**: Updates `available_quantity` on products table for all adjusted items
- **PDF Report Generation**: Uses jsPDF to generate professional audit report with:
  - Header with date, business name, auditor email
  - Summary statistics
  - Full product table with expected/actual/variance columns
  - Color-coded variances (green for gains, red for losses)
- **Audit History Tracking**: Queries past audit entries from inventory_history grouped by session
- **Permission Gating**: Route wrapped in `RoleProtectedRoute` requiring 'owner' or 'admin' roles
- **Route Registration**: Added lazy import and route at `/inventory-audit` in App.tsx
- Uses `useTenantAdminAuth()` for tenant context, all queries filter by `tenant_id`
- TanStack Query with `useMutation` for submit, `useQuery` for products and history
- Proper invalidation via `invalidateOnEvent()` after submission
- Loading skeletons, error states with retry, and empty states
- Logger from `@/lib/logger` — no console.log usage
- All imports use `@/` alias, lucide icons from esm paths

## task-108: Create inventory valuation report
- Created `src/components/admin/inventory/ValuationReport.tsx` — comprehensive inventory valuation component
- Shows total inventory value by product and category using `price × stock_quantity`
- Supports cost basis calculation using `cost_per_unit` field when available
- Calculates margin and margin percentage for products with cost data
- Period comparison: compares current value to 30 days ago using `inventory_history` table
- Three view modes: Summary (category totals), By Category (collapsible product lists), By Product (flat table)
- Summary cards show: Total Retail Value, Total Cost Value, Total Units, Avg Margin with trend indicators
- Category filter dropdown for focused analysis
- CSV export with all product details and summary totals
- Follows all project patterns: `useTenantAdminAuth()`, `tenant_id` filtering, TanStack Query, logger, @/ imports
- Uses Collapsible component for category expansion in by_category view
- Error and loading states properly handled with skeleton loaders
- No console.log — all logging via `@/lib/logger`

## task-109: Create inventory alerts settings page
- Created `src/components/admin/settings/InventoryAlerts.tsx` for configuring inventory alert thresholds
- Global settings stored in `tenant_settings` table with fields: inventory_alerts_enabled, inventory_low_stock_threshold, inventory_critical_stock_threshold, inventory_notification_inapp, inventory_notification_email, inventory_recheck_frequency
- Per-product overrides use existing product columns: low_stock_alert, critical_stock_alert
- Used React Hook Form with Zod for form validation
- Followed patterns from `OrderAutoAssign.tsx` for settings upsert with `onConflict: 'tenant_id'`
- Implemented notification channels toggle (in-app, email)
- Added recheck frequency selector with options from 15 minutes to daily
- Products table with search, inline editing, and status badges (OK, Low, Critical)
- All queries filter by `tenant_id` using `.eq('tenant_id', tenant.id)`
- Used `useTenantAdminAuth()` for tenant context
- All logging uses `logger` from `@/lib/logger` — no console.log
- Proper loading states (Skeleton), error states (Alert), and success/error toasts
- Used `.maybeSingle()` for optional tenant_settings data
- Imports use `@/` alias as required

## task-110: Create product-order velocity calculation
- Created `src/hooks/useProductVelocity.ts` — calculates how fast a product sells
- Returns `units_per_day`, `days_until_stockout`, `reorder_urgency` (normal/soon/urgent/overdue)
- Calculates from `unified_order_items` joined with `unified_orders` over last 30 days
- Only counts orders with valid statuses: completed, delivered, processing, confirmed
- `useProductVelocity()` hook for single product velocity with tenant filtering
- `useBulkProductVelocity()` hook for efficient batch calculation across multiple products
- Added trend analysis: compares first 15 days vs last 15 days to detect increasing/decreasing/stable sales
- Tracks weekly and monthly unit totals along with last sale date
- Utility functions: `getVelocityUrgencyLabel()`, `getVelocityUrgencyColor()`, `getTrendLabel()`, `getTrendIcon()`
- Custom query keys: `velocityQueryKeys.single()`, `velocityQueryKeys.bulk()` for proper cache management
- 5-minute stale time for TanStack Query caching
- All queries filter by `tenant_id` using `useTenantAdminAuth()`
- All logging uses `logger` from `@/lib/logger` — no console.log
- Used `.maybeSingle()` for product fetch
- All imports use `@/` alias as required

## task-111: Create stock transfer between locations
- Created `src/components/admin/inventory/StockTransfer.tsx` — full stock transfer flow between locations
- Component checks if tenant has multiple locations; shows helpful message if only one location exists
- Location selection: source and destination dropdowns with city info, filters prevent selecting same location
- Product selection: fetches products with stock > 0 from source location, shows available quantity
- Transfer items management: add/remove products with quantity validation against available stock
- Creates paired `inventory_history` entries:
  - Source: `change_type: 'transfer_out'`, negative change amount, `reference_type: 'stock_transfer'`
  - Destination: `change_type: 'transfer_in'`, positive change amount, `reference_type: 'stock_transfer'`
- Transfer tracking with status workflow: pending → in_transit → completed (or cancelled)
- Status update buttons: "Start Transit" (pending→in_transit), "Complete" (in_transit→completed)
- Notification to destination location admin via `notifications` table insert
- Activity logging via `logActivity()` from `@/lib/activityLog`:
  - Logs `ActivityAction.CREATED` with transfer details on creation
  - Logs `ActivityAction.UPDATED` on status changes
- UI features:
  - Recent transfers list with source→destination display, item count, and date
  - Status badges with icons (Clock, ArrowRight, CheckCircle, XCircle)
  - Loading states with Skeleton components
  - EnhancedEmptyState for no transfers or no multiple locations
- All queries filter by `tenant_id` for tenant isolation
- Uses `useTenantAdminAuth()` from `@/contexts/TenantAdminAuthContext`
- Uses `queryKeys.inventory.transfers()` from `@/lib/queryKeys`
- All logging uses `logger` from `@/lib/logger` — no console.log
- All imports use `@/` alias as required

## task-112: Create product archive with data preservation
- Created migration `supabase/migrations/20260210050509_add_product_archive.sql`:
  - Added `archived_at TIMESTAMPTZ` column to products table (NULL = active)
  - Created indexes for efficient filtering: `idx_products_archived_at` and `idx_products_active`
  - Created `archive_product(p_product_id, p_tenant_id)` RPC function that:
    - Sets `archived_at` timestamp
    - Removes product from all menu_products (menu sync)
    - Sets `menu_visibility = FALSE`
  - Created `unarchive_product(p_product_id, p_tenant_id)` RPC function
  - Both functions are `SECURITY DEFINER` with proper tenant isolation
- Created `src/hooks/useProductArchive.ts`:
  - Uses TanStack Query mutations for archive/unarchive operations
  - Calls RPC functions for atomic operations
  - Logs activity via `useActivityLog` hook (action: 'archived'/'unarchived', type: 'product')
  - Shows toast notifications on success/error
  - Invalidates `queryKeys.products.all` and `queryKeys.menus.all` after mutations
- Updated `ProductAdvancedFilters.tsx`:
  - Added `ArchiveStatus = 'active' | 'archived' | 'all'` type
  - Added `archiveStatus` to ProductFilters interface with default 'active'
  - Added archive status dropdown in filter panel
  - Added archive status badge display
- Updated `ProductsListPage.tsx`:
  - Extended Product type to include `archived_at`
  - Added archive status filtering in filteredProducts memo
  - Added Archive/ArchiveRestore icons import
  - Added archive/unarchive actions in row dropdown menu
  - Shows "Archived" badge next to product name when archived
- Updated `ProductDetailsPage.tsx`:
  - Added Archive/ArchiveRestore buttons in header
  - Shows "Archived" badge in product name when archived
  - Uses useProductArchive hook for archive/unarchive actions
- Key learnings:
  - Use RPC functions for atomic multi-table operations (archive + menu sync)
  - Extended types with `& { archived_at?: string | null }` for new columns
  - Default filter to 'active' to hide archived by default
  - Archive is soft-delete: preserves order history and analytics data

## task-113: Create product tags system
- Extended existing useProductTags.ts hook with full CRUD functionality
- Added query keys for product tags in queryKeys.ts (productTags.list, productTags.popular, productTags.byProduct)
- Created hooks: useProductTags, usePopularProductTags, useProductTagAssignments, useCreateProductTag, useUpdateProductTag, useDeleteProductTag, useAssignProductTag, useRemoveProductTag, useBatchAssignProductTags, useSearchProductTags, useProductTagsByIds
- Created ProductTagsManager.tsx - full CRUD UI for managing tags with color picker and preview
- Created ProductTagBadge.tsx - colored chip display for tags with removable mode and sizes (sm/md/lg)
- Created ProductTagBadgeList.tsx - list display with optional max count and '+N more' indicator
- Created ProductTagFilter.tsx - filter bar component with popover, search, checkboxes, and popular tags section
- Created ProductTagInput.tsx - autocomplete input for assigning tags to products with inline tag creation
- All components use logger from @/lib/logger (no console.log)
- All database queries filter by tenant_id for multi-tenant isolation
- Used useTenantAdminAuth() for tenant context as required
- Graceful handling of missing tables (42P01 error code)
- TAG_COLORS constant exported for consistent color palette across components
- Used sonner toast for success/error notifications

## task-114: Create Supabase migration for product_tags table
- Discovered that a shared `tags` table already exists (20260123000001_customer_tags_system.sql)
- The existing tags table has: id, tenant_id, name, color, description, created_at, updated_at
- Similar junction tables exist: customer_tags (for contacts) and order_tags (for unified_orders)
- Created product_tag_assignments junction table following the same pattern
- Table structure: id UUID PK, tenant_id UUID, product_id UUID, tag_id UUID, created_at
- Added UNIQUE constraint on (product_id, tag_id) to prevent duplicates
- Created indexes: tenant_id, product_id, tag_id, and composite (tenant_id, tag_id)
- RLS policies use `profiles.tenant_id` pattern for tenant isolation
- Added SELECT, INSERT, UPDATE, DELETE policies for CRUD operations
- Key learning: Reuse existing tables when available - no need to duplicate tags table

## task-115: Create product comparison view
- Created ProductComparison.tsx component for comparing 2-4 products side by side
- Compares the following metrics: wholesale price, retail price, stock levels, sales velocity, revenue (30d), vendor, category, compliance status, days until stockout
- Uses useBulkProductVelocity hook for efficient batch velocity calculation
- Created useProductRevenueData hook to fetch 30-day revenue from order_items
- Highlights best/worst values with green/red backgrounds using getMetricHighlight()
- Shows trend indicators (increasing/decreasing/stable) for sales velocity
- Compliance status determined by presence of COA/lab results and test date expiration
- Displays reorder urgency badges for products approaching stockout
- Integrated into ProductsListPage with "Compare" button appearing when 2-4 products are selected
- Dialog uses shadcn/ui Dialog with ScrollArea for scrollable comparison table
- All database queries filter by tenant_id for multi-tenant isolation
- Uses logger from @/lib/logger (no console.log statements)
- TypeScript strict mode compliant with proper typing throughout

## task-116: Create product storefront preview
- Created ProductStorefrontPreview.tsx component in src/components/admin/products/
- Added "Preview on Storefront" button to ProductDetailsPage header (next to Edit/Archive buttons)
- Opens a dialog showing exactly how the product appears on storefronts and active menus
- Features:
  - Store selector dropdown to switch between active storefronts
  - Toggle between Card View and Detail View preview modes
  - Shows product as customers see it with dark luxury theme styling
  - Displays custom pricing when set on storefront/menu
  - Shows visibility status (visible/hidden) and featured badges
  - Lists all active menus featuring this product
  - "Open Live" button to open actual storefront in new tab
  - Product data summary showing display price, stock, category, visibility
- Uses useProductStorefrontData hook to fetch:
  - marketplace_product_settings with marketplace_stores for store appearances
  - disposable_menu_products with disposable_menus for menu appearances
- Preview components:
  - StorefrontProductCard: Mimics storefront product card with image, pricing, THC/CBD, badges
  - StorefrontProductDetail: Mimics product detail page layout with full specs
  - VisibilityStatus: Shows visible/hidden status with check/x icons
- All queries filter by tenant_id for multi-tenant isolation
- Uses logger from @/lib/logger (no console.log statements)
- All imports use @/ alias, proper import order maintained
- Loading and error states included throughout
- TypeScript strict mode compliant

## task-117: Create product cost tracking
- cost_per_unit field already existed in products table from previous migrations
- Product detail page already had margin calculation and display
- Created ProductMarginBadge component for visual margin display with tooltips
- Created ProductMarginAlert component for prominent low-margin warnings
- Added Margin column to ProductManagement table (hidden by default)
- Integrated ColumnVisibilityControl to toggle column visibility
- Persisted visible columns in table preferences
- Added margin threshold of 20% for alerts
- Alert shows suggested price to meet threshold
- Export now includes cost_per_unit and margin_percent columns
- ProductDetailsPage shows ProductMarginAlert after stats cards
- Margin sorting already existed in filteredProducts
- No console.log used — all state is React-managed
- Verified TypeScript compiles with no errors


## task-118: Create inventory forecasting
- Created src/hooks/useInventoryForecast.ts with full stockout prediction system
- Returns forecast_stockout_date, recommended_reorder_date, recommended_reorder_quantity
- Uses 30-day rolling window from unified_order_items for velocity calculation
- Calculates daily/weekly/monthly units sold, trend direction
- Warning levels: critical, warning, soon, healthy with messages
- Main hook useInventoryForecast for single product forecast
- Bulk hook useBulkInventoryForecast for multiple products (inventory dashboard)
- Dashboard hook useInventoryForecastDashboard for at-risk items view
- Configurable leadTimeDays and targetStockDays parameters
- Utility functions: getWarningLevelBadgeVariant, formatForecastDate
- Added inventoryForecast query keys to queryKeys.ts
- Follows existing useProductVelocity pattern but adds reorder recommendations
- All queries filter by tenant_id, uses logger not console.log
- TypeScript strict mode compliant, proper @/ import aliases

## task-119: Create product related products suggestion
- Created src/hooks/useRelatedProducts.ts with co-occurrence-based product suggestions
- Main hook useRelatedProducts: suggests products frequently bought together
- Calculates from unified_order_items — finds products in the same completed orders
- Returns RelatedProduct[] with coOccurrenceCount and coOccurrenceScore (normalized 0-1)
- Configurable limit and minCoOccurrence threshold parameters
- Uses 90-day analysis window for sufficient order history
- Weekly stale time (7 days) for caching as per task spec
- Added useBulkRelatedProducts for fetching related products for multiple products at once
- Added useStorefrontRelatedProducts for public storefront use (no tenant admin auth required)
- Storefront hook fetches tenant_id from storefront_settings, only shows in-stock products
- Utility functions: getCoOccurrenceLabel, formatCoOccurrenceCount for display
- Used Array.from() for Map/Set iteration to avoid downlevelIteration TypeScript issues
- All queries filter by tenant_id (or derive it from store), uses logger not console.log
- Proper error handling with loading states, follows existing hook patterns
- TypeScript strict mode compliant with ProductData interface for type safety

## task-120: Create inventory low stock email digest
- Created supabase/functions/low-stock-email-digest/index.ts Edge Function
- Daily scheduled function (0 8 * * * cron) sends email digests to tenant admins
- Queries wholesale_inventory for products below reorder_point threshold per tenant
- Formats email with product name, current stock, reorder point, days until stockout
- Days until stockout calculated from avg_daily_usage (30-day moving average from movements)
- Sends to admin email configured in tenant.alert_settings.digest_recipients (or owner_email)
- Configurable per-tenant: email_digest_enabled, low_stock_threshold_override, digest_recipients
- Creates in-app notification alongside email for visibility in dashboard
- Logs audit_events when digest is sent for tracking
- Created migration 20260210055422_add_tenant_alert_settings.sql:
  - Adds alert_settings JSONB column to tenants table
  - Adds tenant_id to inventory_alerts for proper tenant scoping
  - Creates get_low_stock_products() RPC function for dashboard use
  - Updates RLS policy for tenant-scoped inventory alerts
- Uses shared deps.ts and logger.ts for consistent patterns
- Service role key auth for cron jobs, JWT validation for manual triggers
- HTML email template with urgency colors (red/orange/yellow) based on stockout timeline
- Summary shows critical products (≤3 days) vs warning products separately

## task-121: Create product weight and dimension tracking
- Created migration supabase/migrations/20260210120000_add_product_dimensions.sql:
  - Adds weight_kg, length_cm, width_cm, height_cm columns to products table
  - Uses numeric types for precision (10,3 for weight, 10,2 for dimensions)
  - Created index on tenant_id for products with dimensions for route optimization queries
  - Added column comments documenting purpose (shipping weight, package dimensions)
- Updated src/components/admin/product-form/BasicInfoStep.tsx:
  - Added "Shipping Dimensions" section with weight_kg, length_cm, width_cm, height_cm inputs
  - Includes descriptive label about usage for shipping cost calculation and delivery optimization
  - Used Input components with number type, proper step values, and unit labels (kg, cm)
- Updated src/components/admin/product-form/ReviewStep.tsx:
  - Added dimension fields to optionalFields list for validation display
  - Added Package icon and "Shipping Dimensions" section in review
  - Shows weight, dimensions (L×W×H), and calculated volume in liters
  - Only renders section if any dimension values are present
- Extended src/components/admin/products/ProductExport.tsx:
  - Added 'shipping' group to ExportFieldOption type and FIELD_GROUPS
  - Added weight_kg, length_cm, width_cm, height_cm to EXPORT_FIELD_OPTIONS
- Extended src/components/admin/products/ProductBulkImport.tsx:
  - Added 4 new SYSTEM_FIELDS for shipping dimensions
  - Updated numericFields array for validation
  - Updated insert statement to include weight_kg, length_cm, width_cm, height_cm
- Created src/components/admin/orders/OrderDimensionsCard.tsx:
  - New component for displaying aggregated shipping dimensions in order summary
  - Shows total weight across all items (with quantity factored in)
  - Shows largest item dimensions and volume
  - Displays coverage (items with dimensions vs total)
  - Warns about items missing dimensions with expandable list
  - Supports compact mode for inline display
- All files use @/ imports, logger (not console.log), TypeScript strict mode compliant

## task-122: Create customer detail page with order history
- Created src/components/admin/customers/CustomerOrderHistoryTab.tsx component
- Uses DataTable for complete order history with pagination (10 per page)
- Table columns: Order # (clickable link), Date, Total, Status, Items count, Payment status
- Order number uses OrderLink for navigation to order detail page
- Stats cards above table show: Total Orders, Lifetime Value, Avg. Order Value, Completed count
- Filter by order status (all/pending/confirmed/processing/ready/out_for_delivery/completed/cancelled)
- Date range filter using Calendar popover with range selection
- Clear filters button when filters are active, shows filtered vs total count
- Data fetched via TanStack Query with tenant_id filtering for multi-tenant security
- Uses useTenantAdminAuth() for tenant context
- Replaced legacy orders tab in CustomerDetails.tsx with new component
- All queries filter by tenant_id using supabase RLS-compatible approach
- Proper loading states (skeleton cards + placeholder)
- Error handling with logger (no console.log)
- All imports use @/ alias pattern
- Sorted newest first by default (order by created_at descending)
- Empty state with action to create new order via POS

## task-123: Create customer detail page with payment history
- Created src/components/admin/customers/CustomerPaymentHistoryTab.tsx component
- Shows all payments across all orders for a customer
- Table columns: Date (with time), Amount, Method (with icon), Order Reference (clickable OrderLink), Status, Ref #
- Stats cards: Total Paid, Outstanding Balance (red if >0), Pending Payments, Avg. Payment
- Running total calculation comparing orders total vs payments received
- Payment trends chart using Recharts LineChart showing last 6 months of payment activity
- Filter by payment status (all/completed/pending/failed/refunded)
- Date range filter using Calendar popover with range selection
- Clear filters button when filters are active, shows filtered vs total count
- Data fetched via TanStack Query with tenant_id filtering for multi-tenant security
- Uses useTenantAdminAuth() for tenant context
- Added new "Payment History" tab to CustomerDetails.tsx TabsList
- Both queries (payments and orders for balance calc) filter by tenant_id
- Proper loading states with Skeleton components
- Error handling with logger (no console.log)
- All imports use @/ alias pattern
- Empty state with action to record payment
- Quick actions: Record Payment and Create Invoice buttons
- Payment method icons for visual distinction (card, cash, check, bank, crypto)
- Status badges with color-coded styling (green=completed, amber=pending, red=failed, purple=refunded)

## Task 124: Create customer detail page with delivery addresses

### Files Created:
- supabase/migrations/20260210000001_add_customer_delivery_addresses.sql
- src/components/admin/customers/CustomerDeliveryAddressesTab.tsx

### Implementation Details:
- Created customer_delivery_addresses table with proper RLS and tenant_id filtering
- Table includes: id, tenant_id, customer_id, label, street_address, apartment, city, state, zip_code, country, latitude, longitude, is_primary, delivery_instructions, timestamps
- Added trigger to ensure only one primary address per customer (automatically unsets others when setting new primary)
- Added indexes for fast lookups by customer_id and tenant_id

### Component Features:
- CustomerDeliveryAddressesTab component with full CRUD operations
- Primary address marked with star badge
- Edit and delete functionality with confirmation dialogs
- Add new address with Zod form validation using React Hook Form
- Geocoding via OpenStreetMap Nominatim API (free, no API key required)
- "Open in Maps" button to view address in Google Maps
- Set primary address functionality
- Delivery instructions field for special notes
- US state selector with all 50 states
- Link to Delivery Zones page for zone mapping integration
- Loading states with Skeleton components
- Error handling with retry button
- Empty state with action to add first address

### Integration:
- Added new "Addresses" tab to CustomerDetails.tsx TabsList
- Tab positioned after Overview for easy access
- Uses useTenantAdminAuth() for tenant context
- All queries filter by tenant_id for multi-tenant security
- Uses TanStack Query for data fetching with proper cache invalidation
- All imports use @/ alias pattern
- Uses logger (no console.log)
- Proper TypeScript types with no 'any' usage


---

## Task 125: Create customer lifetime value calculation

**Date:** 2026-02-10

### What was implemented:
Created `src/hooks/useCustomerLTV.ts` - a comprehensive customer lifetime value calculation hook.

### Key Features:
- **LTV Metrics**: Total spend, order count, average order value
- **Order Frequency**: Calculates average days between orders
- **Predicted Next Order**: Based on order frequency patterns
- **Customer Since Date**: From contact creation or first order
- **LTV Segments**: new/regular/valuable/vip based on spend and order count thresholds
  - VIP: $10,000+ spend OR 50+ orders
  - Valuable: $2,500+ spend OR 15+ orders
  - Regular: $500+ spend OR 3+ orders
  - New: Everyone else

### Hooks Provided:
- `useCustomerLTV`: Single customer LTV calculation
- `useBulkCustomerLTV`: Efficient bulk calculation for multiple customers

### Utility Functions:
- `getSegmentLabel()`: Human-readable segment names
- `getSegmentColor()`: Badge color variants
- `getSegmentColorClasses()`: Tailwind classes for styling
- `sortByLTV()`, `sortByOrderCount()`, `sortBySegment()`: Sorting helpers
- `formatLTVCurrency()`: Currency formatting
- `formatOrderFrequency()`: Human-readable frequency (e.g., "Weekly", "Every 3 days")

### Technical Notes:
- Uses unified_orders table for order data
- Uses contacts table for customer data
- Filters by tenant_id for multi-tenant security
- Calculates daysSinceLastOrder for activity tracking
- Stale time of 5 minutes for query caching
- All queries filter by valid order statuses (completed, delivered, paid)
- Properly typed Map for customer lookup in bulk operations

### Project Rules Followed:
- Uses logger from @/lib/logger (no console.log)
- Uses @/ alias for all imports
- All queries filter by tenant_id
- Uses useTenantAdminAuth() for tenant context
- Uses .maybeSingle() for optional data
- No 'any' type usage
- Proper error handling with logger

## task-126: Create customer segmentation engine
- Created `src/hooks/useCustomerSegments.ts` with behavioral customer segmentation
- Created `src/components/admin/customers/CustomerSegmentBadge.tsx` for segment display

### Segments Implemented:
- `new`: First order within 30 days
- `active`: Ordered within 60 days  
- `at_risk`: No order in 60-90 days
- `churned`: No order in 90+ days
- `vip`: Top 10% by lifetime value (spend)

### Features:
- `useCustomerSegment(customerId)` — Get segment for single customer
- `useCustomerSegments()` — Get all customer segments in bulk (more efficient)
- `useSegmentCounts()` — Lightweight hook for dashboard counts only
- `filterBySegment(segment)` — Filter customer list by segment
- `getSegment(customerId)` — Lookup segment from pre-fetched map
- Segment counts object with new/active/at_risk/churned/vip/total

### Display Components:
- `CustomerSegmentBadge` — Shows colored badge with icon and tooltip
- `SegmentCountsDisplay` — Shows all segment counts as clickable badges
- Supports size variants (sm/md/lg)
- Color-coded by segment (amber=VIP, emerald=active, blue=new, orange=at_risk, red=churned)

### Utility Functions:
- `getSegmentLabel(segment)` — Human-readable label
- `getSegmentBadgeVariant(segment)` — Badge variant for shadcn/ui
- `getSegmentColorClasses(segment)` — Tailwind color classes
- `getSegmentIcon(segment)` — Icon name suggestion
- `getSegmentPriority(segment)` — For sorting (VIP=0, churned=4)
- `sortBySegment(a, b)` — Sort customers by segment priority
- `getSegmentDescription(segment)` — Tooltip descriptions
- `getSegmentThresholds()` — Get configurable threshold values

### Technical Notes:
- VIP threshold calculated dynamically as top 10% of spenders
- ActivitySegment type separates behavioral from value-based segmentation
- CustomerSegmentData includes both `segment` (final) and `activitySegment` + `isVip` flags
- Uses unified_orders table with status filter (completed/delivered/paid)
- 5-minute stale time for query caching
- Bulk query groups orders by customer first, then calculates VIP threshold once

### Project Rules Followed:
- Uses logger from @/lib/logger (no console.log)
- Uses @/ alias for all imports
- All queries filter by tenant_id
- Uses useTenantAdminAuth() for tenant context
- Uses .maybeSingle() for optional data
- No 'any' type usage
- React.memo for CustomerSegmentBadge component
- Proper useMemo for derived values (segmentMap, counts, filterBySegment)

---

## Task 127: Create customer tag system
**Date**: 2026-02-10
**Status**: ✅ Completed

### What Was Implemented

Customer tagging system that enables categorizing customers with multiple tags, filtering customer list by tags, displaying tags on customer cards, and auto-tag rules based on customer attributes.

### Implementation Details

**Component: src/components/admin/customers/CustomerTagFilter.tsx**
- Multi-select filter for customer list by assigned tags
- Uses Command component for searchable tag selection
- Shows selected tags as removable badges
- Clear all filters option
- Loading skeleton while tags load

**Component: src/components/admin/customers/CustomerTagBadges.tsx**
- Read-only display component for customer tags
- Configurable max visible tags with "+N more" tooltip
- Size variants (sm/md) for different contexts
- Used in customer list rows and mobile cards
- Tooltip shows hidden tags on overflow

**Hook: src/hooks/useAutoTagRules.ts**
- Auto-tag rules engine for automatic customer tagging
- Predefined tag names: vip, wholesale, retail, preferred, flagged, at_risk, special_pricing, new_customer
- Predefined tag colors for consistency
- Rule conditions: ltv_threshold, customer_type, loyalty_tier, days_since_order, order_count
- `useEnsureAutoTag()` — Creates tag if doesn't exist
- `useApplyAutoTags()` — Evaluates and applies rules to customer
- `useCustomersByTags()` — Get customer IDs filtered by tags
- `useTagCounts()` — Get customer counts per tag

**Page Updates: src/pages/admin/CustomerManagement.tsx**
- Added CustomerTagFilter to filter bar
- Added Tags column in desktop table view
- Added CustomerTagBadges in mobile card view
- Filter logic updated to include tag filtering
- State for filterTagIds with useCustomersByTags hook

### Existing Components Used
- `useCustomerTags.ts` — Already existed with CRUD operations for tags
- `TagManager.tsx` — Already existed for editing customer tags
- `queryKeys.ts` — Already had tags and customerTags keys defined

### Auto-Tag Rule Examples
```typescript
const DEFAULT_AUTO_TAG_RULES = [
  { name: 'VIP by LTV', tagName: 'vip', condition: 'ltv_threshold', threshold: 5000 },
  { name: 'Wholesale Customers', tagName: 'wholesale', condition: 'customer_type', value: 'wholesale' },
  { name: 'At Risk (Inactive)', tagName: 'at_risk', condition: 'days_since_order', threshold: 60 },
  { name: 'New Customers', tagName: 'new_customer', condition: 'order_count', threshold: 1 },
];
```

### Project Rules Followed
- Uses logger from @/lib/logger (no console.log)
- Uses @/ alias for all imports
- All queries filter by tenant_id
- Uses useTenantAdminAuth() for tenant context
- Uses .maybeSingle() for optional data
- No 'any' type usage — uses 'unknown' with proper type guards
- Loading states included in all async operations
- Error handling with toast notifications


## task-128: Create Supabase migration for customer_tags table
- Migration already exists at supabase/migrations/20260123000001_customer_tags_system.sql
- Implementation uses a normalized approach with two tables:
  - `tags` table: id, tenant_id, name, color, description, created_at, updated_at
  - `customer_tags` junction table: id, tenant_id, contact_id, tag_id (with unique constraint)
- Added proper indexes for performance: tenant_id, name, contact_id, tag_id
- RLS enabled on both tables with policies for SELECT, INSERT, UPDATE, DELETE
- Added trigger for auto-updating updated_at timestamp on tags table
- Uses tenant_id from profiles table via auth.uid() for RLS
- Foreign keys cascade deletes from tenants and contacts tables
- Unique constraint on (tenant_id, name) prevents duplicate tag names within a tenant
