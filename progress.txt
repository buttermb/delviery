# FloraIQ Interconnectivity Build — Progress Log
# Ralph Wiggum appends learnings here each iteration

## task-001: Create shared event bus utility
- Created `src/lib/eventBus.ts` with typed publish/subscribe pattern
- Used TypeScript generics (`EventPayloads` interface) to type all event payloads
- Events: order_created, order_updated, inventory_changed, customer_updated, product_updated, storefront_synced, menu_published, notification_sent
- Exported `subscribe`, `publish`, `unsubscribe`, `getSubscriberCount`, `clearAllSubscriptions`
- Internal storage uses `Map<string, Set<callback>>` as specified
- Added `logger.debug` calls for subscribe, unsubscribe, and publish operations
- No console.log used — all logging via `@/lib/logger`
- Subscribe returns unsubscribe function for convenient cleanup
- Error handling in publish prevents one handler failure from affecting others

## task-002: Create useEventBus hook
- Created `src/hooks/useEventBus.ts` as React hook wrapper around eventBus
- Main `useEventBus<T>` hook accepts eventName and callback, auto-unsubscribes on unmount
- Used `useRef` to keep callback stable and avoid re-subscribing on every render
- Returns `{ publish }` function typed to the specific event payload
- Added `useEventPublisher` helper for components that only emit events (no subscription)
- Added `useMultiEventBus` for subscribing to multiple events at once
- All logging uses `logger` from `@/lib/logger` — no console.log
- Proper useEffect cleanup returns unsubscribe function
- Imports use `@/` alias as required

## task-003: Create cross-module query key factory
- Extended existing `src/lib/queryKeys.ts` with standardized query key patterns
- Added standard sub-keys to all required modules: `list`, `detail`, `byTenant`, `search`, `related`
- Updated modules: orders, products, inventory, customers, vendors, menus, storefront, analytics, deliveries, compliance, payments
- Added NEW factories: `notifications` and `messages` (were missing)
- Pattern: `queryKeys.module.list(tenantId, filters)`, `queryKeys.module.detail(tenantId, entityId)`, `queryKeys.module.search(tenantId, query)`
- All factories follow tenant-first parameter pattern for consistent tenant isolation
- Added module-specific related queries (e.g., vendors.products, menus.products, compliance.audits)
- Used `as const` for proper type inference with TanStack Query
- No breaking changes to existing factories — backward compatible extensions

## task-004: Create useQueryInvalidation hook
- Created `src/hooks/useQueryInvalidation.ts` to centralize TanStack Query invalidation logic
- Uses `useQueryClient` from TanStack Query to access the query client
- All invalidation methods are memoized with `useCallback` to prevent unnecessary re-renders
- Methods handle cross-module dependencies (e.g., `invalidateOrder` also invalidates dashboard, analytics, inventory)
- Key methods implemented:
  - `invalidateOrder(tenantId, orderId)` — invalidates orders.detail, orders.list, dashboard stats, analytics, inventory
  - `invalidateProduct(tenantId, productId)` — invalidates products, inventory, dashboard, analytics, stock alerts
  - `invalidateCustomer(tenantId, customerId)` — invalidates customers, CRM, tags, analytics, dashboard
  - `invalidateInventory(tenantId, inventoryId?)` — invalidates inventory, alerts, stock alerts, dashboard
  - Plus: invalidateVendor, invalidateMenu, invalidateStorefront, invalidateDelivery, invalidateCompliance, invalidatePayments
- Added list-only variants for bulk updates (e.g., `invalidateOrderList`, `invalidateProductList`)
- `invalidateAll(tenantId)` for full tenant data refresh (expensive, use sparingly)
- All logging uses `logger.debug` from `@/lib/logger` — no console.log
- Uses `Promise.all` for parallel invalidation of independent queries
- Exposes `queryClient` for edge cases requiring direct access
- Imports use `@/` alias as required

## task-005: Create useTenantContext unified hook
- Created `src/hooks/useTenantContext.ts` that wraps `useTenantAdminAuth()` from TenantAdminAuthContext
- Provides commonly needed derived state with memoization:
  - `tenantId`, `tenantSlug`, `userId`, `userRole` — basic identity values
  - `isAdmin`, `isStaff`, `isSuperAdmin`, `isOwner`, `isManager`, `isCourier` — role-based boolean flags
  - `permissions` array — derived from role using `ROLE_PERMISSIONS` mapping
  - `hasPermission(perm)`, `hasAnyPermission(perms)`, `hasAllPermissions(perms)` — permission check helpers
  - `isReady` — convenience flag combining loading, isAuthenticated, tenantId, userId
- All derived values use `useMemo` for optimal performance
- Defined `Permission` type with 26 common permission strings (view:*, manage:*, access:*, impersonate:*)
- Created `ROLE_PERMISSIONS` map for 7 roles: super_admin, admin, owner, manager, staff, viewer, courier
- Role hierarchy: super_admin > admin/owner > manager > staff > viewer/courier
- Exposes parent context's `logout` and `refreshTenant` actions for convenience
- Debug logging for context not ready states using `logger` from `@/lib/logger`
- No console.log — all logging via logger
- Imports use `@/` alias as required
- Existing `useTenantContextSafe.ts` provides safe access pattern — this new hook provides derived values

## task-006: Create shared TypeScript interfaces file
- Created `src/types/interconnected.ts` with shared interfaces for cross-module communication
- Core connected entity types:
  - `OrderWithCustomer` — Order with embedded customer relationship
  - `OrderWithProducts` — Order with full product details for each line item
  - `ProductWithInventory` — Product with inventory levels across all locations
  - `CustomerWithOrders` — Customer with order history summary and lifetime value
  - `VendorWithProducts` — Vendor with their product catalog summary
  - `MenuWithProducts` — Menu with its associated products and display settings
- Dashboard & Analytics types:
  - `DashboardStats` — Aggregated statistics for orders, revenue, inventory, customers, deliveries
  - `PartialDashboardStats` — Partial type for specific widget needs
- Activity & Audit types:
  - `ActivityLogEntry` — Standard audit trail entry with user, action, entity, and metadata
  - `ActivityAction` — 18 action types (created, updated, deleted, viewed, exported, etc.)
  - `EntityType` — 18 entity types (order, product, inventory, customer, etc.)
- Notification types:
  - `NotificationPayload` — Full notification with title, message, type, priority, linkage
  - `NotificationType` — 9 notification types (info, success, warning, error, order, etc.)
  - `NotificationPriority` — 4 priority levels (low, normal, high, urgent)
- Sync & Status types:
  - `SyncStatus` — Synchronization status for cross-module data sync with progress tracking
  - `SyncType` — 10 sync operation types (inventory, products, orders, etc.)
- Delivery & Logistics types:
  - `DeliveryWithDetails` — Delivery with order, courier, addresses, and tracking info
  - `CourierSummary`, `AddressInfo`, `GeoLocation` — Supporting types
  - `DeliveryStatus` — 10 delivery status values
- Added type guards for runtime type checking:
  - `isOrderWithCustomer`, `isProductWithInventory`, `isActivityLogEntry`, `isNotificationPayload`, `isSyncStatus`
- Imported existing types from `@/types/order` and `@/types/product` to extend them
- All types exported for use across modules
- No console.log — types file only
- Imports use `@/` alias as required

## task-007: Create useRealTimeSubscription hook
- Created `src/hooks/useRealTimeSubscription.ts` wrapping Supabase realtime subscriptions
- Tenant isolation via required `tenantId` parameter and `filter: tenant_id=eq.${tenantId}` on subscription
- Options interface accepts: table, tenantId, callback, event, enabled, publishToEvent, filterColumn, schema
- Auto-cleanup on unmount via useEffect cleanup function that removes the Supabase channel
- Publishes to eventBus when `publishToEvent` option is set — maps table changes to typed event payloads
- `buildEventPayload` helper maps each event type (order_created, inventory_changed, etc.) to proper payload structure
- Exponential backoff reconnection with configurable parameters:
  - Initial delay: 1000ms, max delay: 30000ms, multiplier: 2, max retries: 10
  - Added jitter (±20%) to prevent thundering herd on reconnect
- Connection status tracking via React state: 'connecting' | 'connected' | 'disconnected' | 'error'
- Returns `{ status, reconnect, disconnect }` for manual control
- Lifecycle logging with logger.debug for: setup, cleanup, status changes, received events, errors
- Used `mountedRef` to prevent state updates after unmount
- Channel naming convention: `realtime:${schema}:${table}:${tenantId}` for uniqueness
- Supports all Postgres events: INSERT, UPDATE, DELETE, or '*' for all
- TypeScript generic `<T>` for typed payload in callback
- No console.log — all logging via `@/lib/logger`
- Imports use `@/` alias as required

## task-008: Create activity log utility
- Created `src/lib/activityLog.ts` with function `logActivity(tenantId, userId, action, entityType, entityId, metadata)`
- Inserts into `activity_log` table via Supabase direct insert (not RPC like existing activityLogger.ts)
- Action types defined as const object: `created`, `updated`, `deleted`, `viewed`, `exported`, `synced`
- Entity types defined as const object: order, product, customer, inventory, menu, storefront, delivery, payment, invoice, user, settings, report, supplier, purchase_order, return, coupon, loyalty
- Type exports: `ActivityActionType`, `EntityTypeValue`, `ActivityMetadata`, `ActivityLogEntry`
- Added `logActivities` for batch operations — useful for bulk imports/exports
- Added `createActivityMetadata` helper for building structured metadata with changes, previousValues, and timestamp
- Error handling: logs errors but doesn't throw — activity logging failures shouldn't break the app
- All logging uses `logger` from `@/lib/logger` — no console.log
- Imports use `@/` alias as required
- Also added `activity` query keys factory to `queryKeys.ts` for task-009 to use:
  - `queryKeys.activity.list(tenantId, filters)`
  - `queryKeys.activity.detail(tenantId, activityId)`
  - `queryKeys.activity.byTenant(tenantId)`
  - `queryKeys.activity.byEntity(tenantId, entityType, entityId)`
  - `queryKeys.activity.byUser(tenantId, userId)`
  - `queryKeys.activity.search(tenantId, query)`
  - `queryKeys.activity.recent(tenantId, limit)`

## task-009: Create useActivityLog hook
- Created `src/hooks/useActivityLog.ts` wrapping the activityLog utility for React components
- Hook integrates with `useTenantContext` to auto-fill tenant_id and user_id — components don't need to pass these manually
- Provides `logActivity(action, entityType, entityId?, metadata?)` function with context auto-fill
- Uses TanStack Query's `useQuery` for fetching activity logs with filters:
  - `entityType` — filter by entity type (order, product, etc.)
  - `entityId` — filter by specific entity ID
  - `userId` — filter by user who performed the action
  - `action` — filter by action type (created, updated, deleted, etc.)
  - `limit` — number of records to return (default: 50)
- Query keys use `queryKeys.activity` factory from `@/lib/queryKeys`:
  - `queryKeys.activity.byEntity(tenantId, entityType, entityId)` — for entity-specific queries
  - `queryKeys.activity.byUser(tenantId, userId)` — for user-specific queries
  - `queryKeys.activity.list(tenantId, filters)` — for general list queries
- Returns object with:
  - `logActivity` — memoized function with useCallback for stable reference
  - `recentActivity` — array of ActivityLogEntry
  - `isLoading`, `isFetching` — loading states
  - `error` — Error | null
  - `refetch` — trigger manual refetch
  - `invalidateActivity` — invalidate activity cache for tenant
  - `isReady` — boolean indicating context is ready for logging
- After logging, automatically invalidates activity queries via `queryClient.invalidateQueries`
- Fetch function filters by `tenant_id` for tenant isolation (RLS)
- Re-exports `ActivityAction` and `EntityType` constants for convenience
- All logging via `logger` from `@/lib/logger` — no console.log
- Imports use `@/` alias as required
- Options accept `enabled` flag to disable query and `refetchInterval` for auto-refresh
- Default staleTime of 30 seconds to reduce unnecessary fetches

## task-010: Create Supabase migration for activity_log table
- Created `supabase/migrations/add_activity_log_table.sql` as specified in task description
- Table structure matches task requirements exactly:
  - `id UUID PRIMARY KEY DEFAULT gen_random_uuid()` — unique identifier
  - `tenant_id UUID NOT NULL REFERENCES public.tenants(id)` — with ON DELETE CASCADE for cleanup
  - `user_id UUID REFERENCES auth.users(id)` — nullable for system actions, ON DELETE SET NULL
  - `action TEXT NOT NULL` — action performed (created, updated, deleted, etc.)
  - `entity_type TEXT NOT NULL` — type of entity affected (order, product, customer, etc.)
  - `entity_id UUID` — nullable for actions not tied to specific entity
  - `metadata JSONB DEFAULT '{}'::jsonb` — additional context data
  - `created_at TIMESTAMPTZ DEFAULT NOW()` — timestamp of activity
- RLS policies implemented for tenant isolation:
  - `activity_log_tenant_read_policy` — users can only SELECT activity from their tenant via tenant_users lookup
  - `activity_log_tenant_insert_policy` — users can only INSERT activity for their tenant via tenant_users lookup
  - `activity_log_service_role_policy` — service_role can do anything for system-level logging
- Indexes created for efficient querying:
  - `idx_activity_log_tenant_entity_created` — composite index on (tenant_id, entity_type, created_at DESC) as required
  - `idx_activity_log_tenant_id` — single column index for tenant filtering
  - `idx_activity_log_entity_id` — partial index for entity lookups (WHERE entity_id IS NOT NULL)
  - `idx_activity_log_user_id` — partial index for user activity queries (WHERE user_id IS NOT NULL)
  - `idx_activity_log_action` — index on action for action-type filtering
- Added COMMENT statements for table and column documentation
- Granted SELECT and INSERT to authenticated role, ALL to service_role
- Note: existing `activity_logs` (plural) table in 20250101000001 migration uses `resource`/`resource_id` columns
  - New `activity_log` (singular) table uses `entity_type`/`entity_id` as specified in task-008/009 utilities

## task-011: Create useNotificationDispatcher hook
- Created `src/hooks/useNotificationDispatcher.ts` that listens to eventBus events and creates in-app notifications
- Subscribes to three eventBus events:
  - `order_created` — creates a success notification for admins with order ID
  - `inventory_changed` — creates warning notification when stock <= threshold, error when stock <= 0
  - `customer_updated` — logs the event but doesn't create notification (per task spec: "log it")
- Tenant isolation via `useTenantContext`:
  - Extracts `tenantId` from context for all operations
  - Each event handler checks `payload.tenantId !== tenantId` to ignore events from other tenants
  - All notifications are created with tenant_id set
- Low stock threshold:
  - Uses `METRICS_CONSTANTS.DEFAULT_LOW_STOCK_THRESHOLD` (10) from `@/lib/constants/dashboard`
  - Configurable via options parameter: `useNotificationDispatcher({ lowStockThreshold: 5 })`
- Notification storage:
  - Inserts directly into `notifications` table via Supabase client
  - Notification structure: tenant_id, user_id (null for all admins), title, message, type, entity_type, entity_id, read=false
  - Four notification types exported: 'info' | 'warning' | 'error' | 'success'
- Hook returns:
  - `isReady` — boolean indicating dispatcher is active and subscribed
  - `dispatchNotification` — manual function to create custom notifications
- Uses `mountedRef` pattern to prevent state updates after unmount
- Proper useEffect cleanup unsubscribes from all events
- All logging via `logger` from `@/lib/logger` — no console.log
- Imports use `@/` alias as required
- Note: Assumes `notifications` table exists (task-012 creates it)
